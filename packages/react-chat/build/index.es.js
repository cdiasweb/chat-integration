import * as Fe from "react";
import Tn, { forwardRef as Xf, createElement as Zf, createContext as Qf, useCallback as ra, useMemo as ua, useState as _n, useRef as Xn, useContext as jn, useEffect as Sr, useLayoutEffect as L1, PureComponent as AS, memo as _S } from "react";
import { createPortal as yS } from "react-dom";
var SS = function(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, a = t.length, i; r < a; r++)
      (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
  return e.concat(i || Array.prototype.slice.call(t));
};
function CS(e, t, n) {
  var r = e.length - t.length, a = Array.from(t);
  if (r === 0)
    return e.apply(void 0, a);
  if (r === 1) {
    var i = function(s) {
      return e.apply(void 0, SS([s], a, !1));
    };
    return (n || e.lazy) && (i.lazy = n || e.lazy, i.lazyArgs = t), i;
  }
  throw new Error("Wrong number of arguments");
}
function OS(e) {
  return !!e && !Array.isArray(e) && typeof e == "object";
}
function Ro() {
  return CS(IS, arguments);
}
function IS(e, t) {
  var n = new Set(t);
  return Object.entries(e).reduce(function(r, a) {
    var i = a[0], s = a[1];
    return n.has(i) || (r[i] = s), r;
  }, {});
}
var je = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ft(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Jf(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var a = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, a.get ? a : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var nc = { exports: {} }, zi = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bm;
function xS() {
  if (bm)
    return zi;
  bm = 1;
  var e = Tn, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, a = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(o, u, l) {
    var f, h = {}, p = null, b = null;
    l !== void 0 && (p = "" + l), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (b = u.ref);
    for (f in u)
      r.call(u, f) && !i.hasOwnProperty(f) && (h[f] = u[f]);
    if (o && o.defaultProps)
      for (f in u = o.defaultProps, u)
        h[f] === void 0 && (h[f] = u[f]);
    return { $$typeof: t, type: o, key: p, ref: b, props: h, _owner: a.current };
  }
  return zi.Fragment = n, zi.jsx = s, zi.jsxs = s, zi;
}
var Vi = {}, Em;
function NS() {
  if (Em)
    return Vi;
  Em = 1;
  var e = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return e.NODE_ENV !== "production" && function() {
    var t = Tn, n = Symbol.for("react.element"), r = Symbol.for("react.portal"), a = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), u = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), b = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), E = Symbol.iterator, y = "@@iterator";
    function N(F) {
      if (F === null || typeof F != "object")
        return null;
      var le = E && F[E] || F[y];
      return typeof le == "function" ? le : null;
    }
    var A = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function I(F) {
      {
        for (var le = arguments.length, ve = new Array(le > 1 ? le - 1 : 0), Be = 1; Be < le; Be++)
          ve[Be - 1] = arguments[Be];
        j("error", F, ve);
      }
    }
    function j(F, le, ve) {
      {
        var Be = A.ReactDebugCurrentFrame, ht = Be.getStackAddendum();
        ht !== "" && (le += "%s", ve = ve.concat([ht]));
        var bt = ve.map(function(at) {
          return String(at);
        });
        bt.unshift("Warning: " + le), Function.prototype.apply.call(console[F], console, bt);
      }
    }
    var $ = !1, _ = !1, M = !1, V = !1, G = !1, O;
    O = Symbol.for("react.module.reference");
    function Q(F) {
      return !!(typeof F == "string" || typeof F == "function" || F === a || F === s || G || F === i || F === f || F === h || V || F === v || $ || _ || M || typeof F == "object" && F !== null && (F.$$typeof === b || F.$$typeof === p || F.$$typeof === o || F.$$typeof === u || F.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      F.$$typeof === O || F.getModuleId !== void 0));
    }
    function ee(F, le, ve) {
      var Be = F.displayName;
      if (Be)
        return Be;
      var ht = le.displayName || le.name || "";
      return ht !== "" ? ve + "(" + ht + ")" : ve;
    }
    function H(F) {
      return F.displayName || "Context";
    }
    function D(F) {
      if (F == null)
        return null;
      if (typeof F.tag == "number" && I("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof F == "function")
        return F.displayName || F.name || null;
      if (typeof F == "string")
        return F;
      switch (F) {
        case a:
          return "Fragment";
        case r:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case f:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof F == "object")
        switch (F.$$typeof) {
          case u:
            var le = F;
            return H(le) + ".Consumer";
          case o:
            var ve = F;
            return H(ve._context) + ".Provider";
          case l:
            return ee(F, F.render, "ForwardRef");
          case p:
            var Be = F.displayName || null;
            return Be !== null ? Be : D(F.type) || "Memo";
          case b: {
            var ht = F, bt = ht._payload, at = ht._init;
            try {
              return D(at(bt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var R = Object.assign, Y = 0, P, Z, W, C, pe, me, w;
    function Ne() {
    }
    Ne.__reactDisabledLog = !0;
    function Re() {
      {
        if (Y === 0) {
          P = console.log, Z = console.info, W = console.warn, C = console.error, pe = console.group, me = console.groupCollapsed, w = console.groupEnd;
          var F = {
            configurable: !0,
            enumerable: !0,
            value: Ne,
            writable: !0
          };
          Object.defineProperties(console, {
            info: F,
            log: F,
            warn: F,
            error: F,
            group: F,
            groupCollapsed: F,
            groupEnd: F
          });
        }
        Y++;
      }
    }
    function De() {
      {
        if (Y--, Y === 0) {
          var F = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: R({}, F, {
              value: P
            }),
            info: R({}, F, {
              value: Z
            }),
            warn: R({}, F, {
              value: W
            }),
            error: R({}, F, {
              value: C
            }),
            group: R({}, F, {
              value: pe
            }),
            groupCollapsed: R({}, F, {
              value: me
            }),
            groupEnd: R({}, F, {
              value: w
            })
          });
        }
        Y < 0 && I("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Qe = A.ReactCurrentDispatcher, Ue;
    function Ae(F, le, ve) {
      {
        if (Ue === void 0)
          try {
            throw Error();
          } catch (ht) {
            var Be = ht.stack.trim().match(/\n( *(at )?)/);
            Ue = Be && Be[1] || "";
          }
        return `
` + Ue + F;
      }
    }
    var Me = !1, it;
    {
      var pt = typeof WeakMap == "function" ? WeakMap : Map;
      it = new pt();
    }
    function Kt(F, le) {
      if (!F || Me)
        return "";
      {
        var ve = it.get(F);
        if (ve !== void 0)
          return ve;
      }
      var Be;
      Me = !0;
      var ht = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var bt;
      bt = Qe.current, Qe.current = null, Re();
      try {
        if (le) {
          var at = function() {
            throw Error();
          };
          if (Object.defineProperty(at.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(at, []);
            } catch (tr) {
              Be = tr;
            }
            Reflect.construct(F, [], at);
          } else {
            try {
              at.call();
            } catch (tr) {
              Be = tr;
            }
            F.call(at.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (tr) {
            Be = tr;
          }
          F();
        }
      } catch (tr) {
        if (tr && Be && typeof tr.stack == "string") {
          for (var qe = tr.stack.split(`
`), nn = Be.stack.split(`
`), Dt = qe.length - 1, Ut = nn.length - 1; Dt >= 1 && Ut >= 0 && qe[Dt] !== nn[Ut]; )
            Ut--;
          for (; Dt >= 1 && Ut >= 0; Dt--, Ut--)
            if (qe[Dt] !== nn[Ut]) {
              if (Dt !== 1 || Ut !== 1)
                do
                  if (Dt--, Ut--, Ut < 0 || qe[Dt] !== nn[Ut]) {
                    var On = `
` + qe[Dt].replace(" at new ", " at ");
                    return F.displayName && On.includes("<anonymous>") && (On = On.replace("<anonymous>", F.displayName)), typeof F == "function" && it.set(F, On), On;
                  }
                while (Dt >= 1 && Ut >= 0);
              break;
            }
        }
      } finally {
        Me = !1, Qe.current = bt, De(), Error.prepareStackTrace = ht;
      }
      var kr = F ? F.displayName || F.name : "", no = kr ? Ae(kr) : "";
      return typeof F == "function" && it.set(F, no), no;
    }
    function Xt(F, le, ve) {
      return Kt(F, !1);
    }
    function un(F) {
      var le = F.prototype;
      return !!(le && le.isReactComponent);
    }
    function wn(F, le, ve) {
      if (F == null)
        return "";
      if (typeof F == "function")
        return Kt(F, un(F));
      if (typeof F == "string")
        return Ae(F);
      switch (F) {
        case f:
          return Ae("Suspense");
        case h:
          return Ae("SuspenseList");
      }
      if (typeof F == "object")
        switch (F.$$typeof) {
          case l:
            return Xt(F.render);
          case p:
            return wn(F.type, le, ve);
          case b: {
            var Be = F, ht = Be._payload, bt = Be._init;
            try {
              return wn(bt(ht), le, ve);
            } catch {
            }
          }
        }
      return "";
    }
    var br = Object.prototype.hasOwnProperty, Gn = {}, Nr = A.ReactDebugCurrentFrame;
    function Dn(F) {
      if (F) {
        var le = F._owner, ve = wn(F.type, F._source, le ? le.type : null);
        Nr.setExtraStackFrame(ve);
      } else
        Nr.setExtraStackFrame(null);
    }
    function Er(F, le, ve, Be, ht) {
      {
        var bt = Function.call.bind(br);
        for (var at in F)
          if (bt(F, at)) {
            var qe = void 0;
            try {
              if (typeof F[at] != "function") {
                var nn = Error((Be || "React class") + ": " + ve + " type `" + at + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof F[at] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw nn.name = "Invariant Violation", nn;
              }
              qe = F[at](le, at, Be, ve, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Dt) {
              qe = Dt;
            }
            qe && !(qe instanceof Error) && (Dn(ht), I("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Be || "React class", ve, at, typeof qe), Dn(null)), qe instanceof Error && !(qe.message in Gn) && (Gn[qe.message] = !0, Dn(ht), I("Failed %s type: %s", ve, qe.message), Dn(null));
          }
      }
    }
    var Pn = Array.isArray;
    function er(F) {
      return Pn(F);
    }
    function Rr(F) {
      {
        var le = typeof Symbol == "function" && Symbol.toStringTag, ve = le && F[Symbol.toStringTag] || F.constructor.name || "Object";
        return ve;
      }
    }
    function ne(F) {
      try {
        return be(F), !1;
      } catch {
        return !0;
      }
    }
    function be(F) {
      return "" + F;
    }
    function ke(F) {
      if (ne(F))
        return I("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Rr(F)), be(F);
    }
    var Pe = A.ReactCurrentOwner, Je = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Vt, Gt, tn;
    tn = {};
    function Yn(F) {
      if (br.call(F, "ref")) {
        var le = Object.getOwnPropertyDescriptor(F, "ref").get;
        if (le && le.isReactWarning)
          return !1;
      }
      return F.ref !== void 0;
    }
    function Cn(F) {
      if (br.call(F, "key")) {
        var le = Object.getOwnPropertyDescriptor(F, "key").get;
        if (le && le.isReactWarning)
          return !1;
      }
      return F.key !== void 0;
    }
    function qt(F, le) {
      if (typeof F.ref == "string" && Pe.current && le && Pe.current.stateNode !== le) {
        var ve = D(Pe.current.type);
        tn[ve] || (I('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', D(Pe.current.type), F.ref), tn[ve] = !0);
      }
    }
    function Wn(F, le) {
      {
        var ve = function() {
          Vt || (Vt = !0, I("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", le));
        };
        ve.isReactWarning = !0, Object.defineProperty(F, "key", {
          get: ve,
          configurable: !0
        });
      }
    }
    function ln(F, le) {
      {
        var ve = function() {
          Gt || (Gt = !0, I("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", le));
        };
        ve.isReactWarning = !0, Object.defineProperty(F, "ref", {
          get: ve,
          configurable: !0
        });
      }
    }
    var Ga = function(F, le, ve, Be, ht, bt, at) {
      var qe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: F,
        key: le,
        ref: ve,
        props: at,
        // Record the component responsible for creating this element.
        _owner: bt
      };
      return qe._store = {}, Object.defineProperty(qe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(qe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Be
      }), Object.defineProperty(qe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ht
      }), Object.freeze && (Object.freeze(qe.props), Object.freeze(qe)), qe;
    };
    function Mi(F, le, ve, Be, ht) {
      {
        var bt, at = {}, qe = null, nn = null;
        ve !== void 0 && (ke(ve), qe = "" + ve), Cn(le) && (ke(le.key), qe = "" + le.key), Yn(le) && (nn = le.ref, qt(le, ht));
        for (bt in le)
          br.call(le, bt) && !Je.hasOwnProperty(bt) && (at[bt] = le[bt]);
        if (F && F.defaultProps) {
          var Dt = F.defaultProps;
          for (bt in Dt)
            at[bt] === void 0 && (at[bt] = Dt[bt]);
        }
        if (qe || nn) {
          var Ut = typeof F == "function" ? F.displayName || F.name || "Unknown" : F;
          qe && Wn(at, Ut), nn && ln(at, Ut);
        }
        return Ga(F, qe, nn, ht, Be, Pe.current, at);
      }
    }
    var ha = A.ReactCurrentOwner, Xs = A.ReactDebugCurrentFrame;
    function zr(F) {
      if (F) {
        var le = F._owner, ve = wn(F.type, F._source, le ? le.type : null);
        Xs.setExtraStackFrame(ve);
      } else
        Xs.setExtraStackFrame(null);
    }
    var $i;
    $i = !1;
    function Bi(F) {
      return typeof F == "object" && F !== null && F.$$typeof === n;
    }
    function Zs() {
      {
        if (ha.current) {
          var F = D(ha.current.type);
          if (F)
            return `

Check the render method of \`` + F + "`.";
        }
        return "";
      }
    }
    function Gu(F) {
      {
        if (F !== void 0) {
          var le = F.fileName.replace(/^.*[\\\/]/, ""), ve = F.lineNumber;
          return `

Check your code at ` + le + ":" + ve + ".";
        }
        return "";
      }
    }
    var Qs = {};
    function Yu(F) {
      {
        var le = Zs();
        if (!le) {
          var ve = typeof F == "string" ? F : F.displayName || F.name;
          ve && (le = `

Check the top-level render call using <` + ve + ">.");
        }
        return le;
      }
    }
    function Js(F, le) {
      {
        if (!F._store || F._store.validated || F.key != null)
          return;
        F._store.validated = !0;
        var ve = Yu(le);
        if (Qs[ve])
          return;
        Qs[ve] = !0;
        var Be = "";
        F && F._owner && F._owner !== ha.current && (Be = " It was passed a child from " + D(F._owner.type) + "."), zr(F), I('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ve, Be), zr(null);
      }
    }
    function eo(F, le) {
      {
        if (typeof F != "object")
          return;
        if (er(F))
          for (var ve = 0; ve < F.length; ve++) {
            var Be = F[ve];
            Bi(Be) && Js(Be, le);
          }
        else if (Bi(F))
          F._store && (F._store.validated = !0);
        else if (F) {
          var ht = N(F);
          if (typeof ht == "function" && ht !== F.entries)
            for (var bt = ht.call(F), at; !(at = bt.next()).done; )
              Bi(at.value) && Js(at.value, le);
        }
      }
    }
    function Wu(F) {
      {
        var le = F.type;
        if (le == null || typeof le == "string")
          return;
        var ve;
        if (typeof le == "function")
          ve = le.propTypes;
        else if (typeof le == "object" && (le.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        le.$$typeof === p))
          ve = le.propTypes;
        else
          return;
        if (ve) {
          var Be = D(le);
          Er(ve, F.props, "prop", Be, F);
        } else if (le.PropTypes !== void 0 && !$i) {
          $i = !0;
          var ht = D(le);
          I("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ht || "Unknown");
        }
        typeof le.getDefaultProps == "function" && !le.getDefaultProps.isReactClassApproved && I("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function to(F) {
      {
        for (var le = Object.keys(F.props), ve = 0; ve < le.length; ve++) {
          var Be = le[ve];
          if (Be !== "children" && Be !== "key") {
            zr(F), I("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Be), zr(null);
            break;
          }
        }
        F.ref !== null && (zr(F), I("Invalid attribute `ref` supplied to `React.Fragment`."), zr(null));
      }
    }
    function Fi(F, le, ve, Be, ht, bt) {
      {
        var at = Q(F);
        if (!at) {
          var qe = "";
          (F === void 0 || typeof F == "object" && F !== null && Object.keys(F).length === 0) && (qe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var nn = Gu(ht);
          nn ? qe += nn : qe += Zs();
          var Dt;
          F === null ? Dt = "null" : er(F) ? Dt = "array" : F !== void 0 && F.$$typeof === n ? (Dt = "<" + (D(F.type) || "Unknown") + " />", qe = " Did you accidentally export a JSX literal instead of a component?") : Dt = typeof F, I("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Dt, qe);
        }
        var Ut = Mi(F, le, ve, ht, bt);
        if (Ut == null)
          return Ut;
        if (at) {
          var On = le.children;
          if (On !== void 0)
            if (Be)
              if (er(On)) {
                for (var kr = 0; kr < On.length; kr++)
                  eo(On[kr], F);
                Object.freeze && Object.freeze(On);
              } else
                I("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              eo(On, F);
        }
        return F === a ? to(Ut) : Wu(Ut), Ut;
      }
    }
    function qu(F, le, ve) {
      return Fi(F, le, ve, !0);
    }
    function Ku(F, le, ve) {
      return Fi(F, le, ve, !1);
    }
    var Xu = Ku, Ya = qu;
    Vi.Fragment = a, Vi.jsx = Xu, Vi.jsxs = Ya;
  }(), Vi;
}
var RS = {};
RS.NODE_ENV === "production" ? nc.exports = xS() : nc.exports = NS();
var J = nc.exports, yt = /* @__PURE__ */ ((e) => (e.ASSISTANT_INFO = "vfrc-assistant-info", e.AVATAR = "vfrc-avatar", e.BUBBLE = "vfrc-bubble", e.BUTTON = "vfrc-button", e.CARD = "vfrc-card", e.CAROUSEL = "vfrc-carousel", e.CHAT = "vfrc-chat", e.CHAT_INPUT = "vfrc-chat-input", e.FEEDBACK = "vfrc-feedback", e.FOOTER = "vfrc-footer", e.HEADER = "vfrc-header", e.ICON = "vfrc-icon", e.IMAGE = "vfrc-image", e.INPUT = "vfrc-input", e.LAUNCHER = "vfrc-launcher", e.LOADER = "vfrc-loader", e.MESSAGE = "vfrc-message", e.PROMPT = "vfrc-prompt", e.SYSTEM_RESPONSE = "vfrc-system-response", e.TIMESTAMP = "vfrc-timestamp", e.TOOLTIP = "vfrc-tooltip", e.TYPING_INDICATOR = "vfrc-typing-indicator", e.USER_RESPONSE = "vfrc-user-response", e.WIDGET = "vfrc-widget", e.PROACTIVE_CLOSE = "vfrc-proactive-close", e.PROACTIVE_MESSAGE = "vfrc-proactive-message", e.PROACTIVE = "vfrc-proactive", e))(yt || {});
function M1(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number")
    r += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = M1(e[t])) && (r && (r += " "), r += n);
    else
      for (t in e)
        e[t] && (r && (r += " "), r += t);
  return r;
}
function kS() {
  for (var e, t, n = 0, r = ""; n < arguments.length; )
    (e = arguments[n++]) && (t = M1(e)) && (r && (r += " "), r += t);
  return r;
}
const Ot = (e) => (t, n) => Xf(
  (r, a) => Zf(t, {
    ...r,
    ref: a,
    className: kS(n ? `${e}--${n}` : e, r.className)
  })
);
var _t = "colors", gn = "sizes", Ie = "space", wS = { gap: Ie, gridGap: Ie, columnGap: Ie, gridColumnGap: Ie, rowGap: Ie, gridRowGap: Ie, inset: Ie, insetBlock: Ie, insetBlockEnd: Ie, insetBlockStart: Ie, insetInline: Ie, insetInlineEnd: Ie, insetInlineStart: Ie, margin: Ie, marginTop: Ie, marginRight: Ie, marginBottom: Ie, marginLeft: Ie, marginBlock: Ie, marginBlockEnd: Ie, marginBlockStart: Ie, marginInline: Ie, marginInlineEnd: Ie, marginInlineStart: Ie, padding: Ie, paddingTop: Ie, paddingRight: Ie, paddingBottom: Ie, paddingLeft: Ie, paddingBlock: Ie, paddingBlockEnd: Ie, paddingBlockStart: Ie, paddingInline: Ie, paddingInlineEnd: Ie, paddingInlineStart: Ie, top: Ie, right: Ie, bottom: Ie, left: Ie, scrollMargin: Ie, scrollMarginTop: Ie, scrollMarginRight: Ie, scrollMarginBottom: Ie, scrollMarginLeft: Ie, scrollMarginX: Ie, scrollMarginY: Ie, scrollMarginBlock: Ie, scrollMarginBlockEnd: Ie, scrollMarginBlockStart: Ie, scrollMarginInline: Ie, scrollMarginInlineEnd: Ie, scrollMarginInlineStart: Ie, scrollPadding: Ie, scrollPaddingTop: Ie, scrollPaddingRight: Ie, scrollPaddingBottom: Ie, scrollPaddingLeft: Ie, scrollPaddingX: Ie, scrollPaddingY: Ie, scrollPaddingBlock: Ie, scrollPaddingBlockEnd: Ie, scrollPaddingBlockStart: Ie, scrollPaddingInline: Ie, scrollPaddingInlineEnd: Ie, scrollPaddingInlineStart: Ie, fontSize: "fontSizes", background: _t, backgroundColor: _t, backgroundImage: _t, borderImage: _t, border: _t, borderBlock: _t, borderBlockEnd: _t, borderBlockStart: _t, borderBottom: _t, borderBottomColor: _t, borderColor: _t, borderInline: _t, borderInlineEnd: _t, borderInlineStart: _t, borderLeft: _t, borderLeftColor: _t, borderRight: _t, borderRightColor: _t, borderTop: _t, borderTopColor: _t, caretColor: _t, color: _t, columnRuleColor: _t, fill: _t, outline: _t, outlineColor: _t, stroke: _t, textDecorationColor: _t, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: gn, minBlockSize: gn, maxBlockSize: gn, inlineSize: gn, minInlineSize: gn, maxInlineSize: gn, width: gn, minWidth: gn, maxWidth: gn, height: gn, minHeight: gn, maxHeight: gn, flexBasis: gn, gridTemplateColumns: gn, gridTemplateRows: gn, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" }, { parse: Bz, stringify: DS } = JSON, PS = String, LS = (e, t) => t, vm = (e, t, n) => {
  const r = PS(t.push(n) - 1);
  return e.set(n, r), r;
}, MS = (e, t, n) => {
  const r = t && typeof t == "object" ? (f, h) => f === "" || -1 < t.indexOf(f) ? h : void 0 : t || LS, a = /* @__PURE__ */ new Map(), i = [], s = [];
  let o = +vm(a, i, r.call({ "": e }, "", e)), u = !o;
  for (; o < i.length; )
    u = !0, s[o] = DS(i[o++], l, n);
  return "[" + s.join(",") + "]";
  function l(f, h) {
    if (u)
      return u = !u, h;
    const p = r.call(this, f, h);
    switch (typeof p) {
      case "object":
        if (p === null)
          return p;
      case "string":
        return a.get(p) || vm(a, i, p);
    }
    return p;
  }
}, Ai = () => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t, n, ...r) => {
    const a = ((i) => MS(i))(t);
    return a in e ? e[a] : e[a] = n(t, ...r);
  };
}, Ca = Symbol.for("sxs.internal"), ed = (e, t) => Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)), Tm = (e) => {
  for (const t in e)
    return !0;
  return !1;
}, { hasOwnProperty: $S } = Object.prototype, rc = (e) => e.includes("-") ? e : e.replace(/[A-Z]/g, (t) => "-" + t.toLowerCase()), BS = /\s+(?![^()]*\))/, ri = (e) => (t) => e(...typeof t == "string" ? String(t).split(BS) : [t]), Am = { appearance: (e) => ({ WebkitAppearance: e, appearance: e }), backfaceVisibility: (e) => ({ WebkitBackfaceVisibility: e, backfaceVisibility: e }), backdropFilter: (e) => ({ WebkitBackdropFilter: e, backdropFilter: e }), backgroundClip: (e) => ({ WebkitBackgroundClip: e, backgroundClip: e }), boxDecorationBreak: (e) => ({ WebkitBoxDecorationBreak: e, boxDecorationBreak: e }), clipPath: (e) => ({ WebkitClipPath: e, clipPath: e }), content: (e) => ({ content: e.includes('"') || e.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e) ? e : `"${e}"` }), hyphens: (e) => ({ WebkitHyphens: e, hyphens: e }), maskImage: (e) => ({ WebkitMaskImage: e, maskImage: e }), maskSize: (e) => ({ WebkitMaskSize: e, maskSize: e }), textSizeAdjust: (e) => ({ WebkitTextSizeAdjust: e, textSizeAdjust: e }), userSelect: (e) => ({ WebkitUserSelect: e, userSelect: e }), marginBlock: ri((e, t) => ({ marginBlockStart: e, marginBlockEnd: t || e })), marginInline: ri((e, t) => ({ marginInlineStart: e, marginInlineEnd: t || e })), maxSize: ri((e, t) => ({ maxBlockSize: e, maxInlineSize: t || e })), minSize: ri((e, t) => ({ minBlockSize: e, minInlineSize: t || e })), paddingBlock: ri((e, t) => ({ paddingBlockStart: e, paddingBlockEnd: t || e })), paddingInline: ri((e, t) => ({ paddingInlineStart: e, paddingInlineEnd: t || e })) }, Sl = /([\d.]+)([^]*)/, FS = (e, t) => e.length ? e.reduce((n, r) => (n.push(...t.map((a) => a.includes("&") ? a.replace(/&/g, /[ +>|~]/.test(r) && /&.*&/.test(a) ? `:is(${r})` : r) : r + " " + a)), n), []) : t, US = (e, t) => e in HS && typeof t == "string" ? t.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (n, r, a, i) => r + (a === "stretch" ? `-moz-available${i};${rc(e)}:${r}-webkit-fill-available` : `-moz-fit-content${i};${rc(e)}:${r}fit-content`) + i) : String(t), HS = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 }, Br = (e) => e ? e + "-" : "", $1 = (e, t, n) => e.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (r, a, i, s, o) => s == "$" == !!i ? r : (a || s == "--" ? "calc(" : "") + "var(--" + (s === "$" ? Br(t) + (o.includes("$") ? "" : Br(n)) + o.replace(/\$/g, "-") : o) + ")" + (a || s == "--" ? "*" + (a || "") + (i || "1") + ")" : "")), jS = /\s*,\s*(?![^()]*\))/, zS = Object.prototype.toString, ci = (e, t, n, r, a) => {
  let i, s, o;
  const u = (l, f, h) => {
    let p, b;
    const v = (E) => {
      for (p in E) {
        const A = p.charCodeAt(0) === 64, I = A && Array.isArray(E[p]) ? E[p] : [E[p]];
        for (b of I) {
          const j = /[A-Z]/.test(N = p) ? N : N.replace(/-[^]/g, (_) => _[1].toUpperCase()), $ = typeof b == "object" && b && b.toString === zS && (!r.utils[j] || !f.length);
          if (j in r.utils && !$) {
            const _ = r.utils[j];
            if (_ !== s) {
              s = _, v(_(b)), s = null;
              continue;
            }
          } else if (j in Am) {
            const _ = Am[j];
            if (_ !== o) {
              o = _, v(_(b)), o = null;
              continue;
            }
          }
          if (A && (y = p.slice(1) in r.media ? "@media " + r.media[p.slice(1)] : p, p = y.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (_, M, V, G, O, Q) => {
            const ee = Sl.test(M), H = 0.0625 * (ee ? -1 : 1), [D, R] = ee ? [G, M] : [M, G];
            return "(" + (V[0] === "=" ? "" : V[0] === ">" === ee ? "max-" : "min-") + D + ":" + (V[0] !== "=" && V.length === 1 ? R.replace(Sl, (Y, P, Z) => Number(P) + H * (V === ">" ? 1 : -1) + Z) : R) + (O ? ") and (" + (O[0] === ">" ? "min-" : "max-") + D + ":" + (O.length === 1 ? Q.replace(Sl, (Y, P, Z) => Number(P) + H * (O === ">" ? -1 : 1) + Z) : Q) : "") + ")";
          })), $) {
            const _ = A ? h.concat(p) : [...h], M = A ? [...f] : FS(f, p.split(jS));
            i !== void 0 && a(_m(...i)), i = void 0, u(b, M, _);
          } else
            i === void 0 && (i = [[], f, h]), p = A || p.charCodeAt(0) !== 36 ? p : `--${Br(r.prefix)}${p.slice(1).replace(/\$/g, "-")}`, b = $ ? b : typeof b == "number" ? b && !(j in VS) && p.charCodeAt(0) !== 45 ? String(b) + "px" : String(b) : $1(US(j, b ?? ""), r.prefix, r.themeMap[j]), i[0].push(`${A ? `${p} ` : `${rc(p)}:`}${b}`);
        }
      }
      var y, N;
    };
    v(l), i !== void 0 && a(_m(...i)), i = void 0;
  };
  u(e, t, n);
}, _m = (e, t, n) => `${n.map((r) => `${r}{`).join("")}${t.length ? `${t.join(",")}{` : ""}${e.join(";")}${t.length ? "}" : ""}${Array(n.length ? n.length + 1 : 0).join("}")}`, VS = { animationIterationCount: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }, ym = (e) => String.fromCharCode(e + (e > 25 ? 39 : 97)), Oa = (e) => ((t) => {
  let n, r = "";
  for (n = Math.abs(t); n > 52; n = n / 52 | 0)
    r = ym(n % 52) + r;
  return ym(n % 52) + r;
})(((t, n) => {
  let r = n.length;
  for (; r; )
    t = 33 * t ^ n.charCodeAt(--r);
  return t;
})(5381, JSON.stringify(e)) >>> 0), fi = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"], GS = (e) => {
  if (e.href && !e.href.startsWith(location.origin))
    return !1;
  try {
    return !!e.cssRules;
  } catch {
    return !1;
  }
}, YS = (e) => {
  let t;
  const n = () => {
    const { cssRules: a } = t.sheet;
    return [].map.call(a, (i, s) => {
      const { cssText: o } = i;
      let u = "";
      if (o.startsWith("--sxs"))
        return "";
      if (a[s - 1] && (u = a[s - 1].cssText).startsWith("--sxs")) {
        if (!i.cssRules.length)
          return "";
        for (const l in t.rules)
          if (t.rules[l].group === i)
            return `--sxs{--sxs:${[...t.rules[l].cache].join(" ")}}${o}`;
        return i.cssRules.length ? `${u}${o}` : "";
      }
      return o;
    }).join("");
  }, r = () => {
    if (t) {
      const { rules: o, sheet: u } = t;
      if (!u.deleteRule) {
        for (; Object(Object(u.cssRules)[0]).type === 3; )
          u.cssRules.splice(0, 1);
        u.cssRules = [];
      }
      for (const l in o)
        delete o[l];
    }
    const a = Object(e).styleSheets || [];
    for (const o of a)
      if (GS(o)) {
        for (let u = 0, l = o.cssRules; l[u]; ++u) {
          const f = Object(l[u]);
          if (f.type !== 1)
            continue;
          const h = Object(l[u + 1]);
          if (h.type !== 4)
            continue;
          ++u;
          const { cssText: p } = f;
          if (!p.startsWith("--sxs"))
            continue;
          const b = p.slice(14, -3).trim().split(/\s+/), v = fi[b[0]];
          v && (t || (t = { sheet: o, reset: r, rules: {}, toString: n }), t.rules[v] = { group: h, index: u, cache: new Set(b) });
        }
        if (t)
          break;
      }
    if (!t) {
      const o = (u, l) => ({ type: l, cssRules: [], insertRule(f, h) {
        this.cssRules.splice(h, 0, o(f, { import: 3, undefined: 1 }[(f.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return u === "@media{}" ? `@media{${[].map.call(this.cssRules, (f) => f.cssText).join("")}}` : u;
      } });
      t = { sheet: (() => {
        if (!e)
          return o("", "text/css");
        const u = document.createElement("style"), l = window.__webpack_nonce__ !== void 0 ? window.__webpack_nonce__ : window.nonce !== void 0 ? window.nonce : null;
        return l && u.setAttribute("nonce", l), (e.head || e).appendChild(u).sheet;
      })(), rules: {}, reset: r, toString: n };
    }
    const { sheet: i, rules: s } = t;
    for (let o = fi.length - 1; o >= 0; --o) {
      const u = fi[o];
      if (!s[u]) {
        const l = fi[o + 1], f = s[l] ? s[l].index : i.cssRules.length;
        i.insertRule("@media{}", f), i.insertRule(`--sxs{--sxs:${o}}`, f), s[u] = { group: i.cssRules[f + 1], index: f, cache: /* @__PURE__ */ new Set([o]) };
      }
      WS(s[u]);
    }
  };
  return r(), t;
}, WS = (e) => {
  let t = e.group.cssRules.length;
  e.apply = (n) => {
    try {
      e.group.insertRule(n, t), ++t;
    } catch {
    }
  };
}, Gi = Symbol(), qS = Ai(), Sm = (e, t) => qS(e, () => {
  const n = (a, i = {}) => {
    let s = { type: null, composers: /* @__PURE__ */ new Set() };
    for (const o of a)
      if (o != null)
        if (o[Ca]) {
          s.type == null && (s.type = o[Ca].type);
          for (const u of o[Ca].composers)
            s.composers.add(u);
        } else
          o.constructor !== Object || o.$$typeof ? s.type == null && (s.type = o) : s.composers.add(KS(o, e, i));
    return s.type == null && (s.type = "span"), s.composers.size || s.composers.add(["PJLV", {}, [], [], {}, []]), XS(e, s, t, i);
  }, r = (...a) => n(a);
  return r.withConfig = (a) => (...i) => n(i, a), r;
}), KS = ({ variants: e, compoundVariants: t, defaultVariants: n, ...r }, a, { componentId: i, displayName: s }) => {
  const o = i || Oa(r), u = s ? "c-" + s : "c", l = `${Br(a.prefix)}${u}-${o}`, f = [], h = [], p = /* @__PURE__ */ Object.create(null), b = [];
  for (const y in n)
    p[y] = String(n[y]);
  if (typeof e == "object" && e)
    for (const y in e) {
      v = p, E = y, $S.call(v, E) || (p[y] = "undefined");
      const N = e[y];
      for (const A in N) {
        const I = { [y]: String(A) };
        String(A) === "undefined" && b.push(y);
        const j = N[A], $ = [I, j, !Tm(j)];
        f.push($);
      }
    }
  var v, E;
  if (typeof t == "object" && t)
    for (const y of t) {
      let { css: N, ...A } = y;
      N = typeof N == "object" && N || {};
      for (const j in A)
        A[j] = String(A[j]);
      const I = [A, N, !Tm(N)];
      h.push(I);
    }
  return [l, r, f, h, p, b];
}, XS = (e, t, n, { shouldForwardStitchesProp: r }) => {
  const [a, i, s, o] = ZS(t.composers), u = typeof t.type == "function" || t.type.$$typeof ? ((p) => {
    function b() {
      for (let v = 0; v < b[Gi].length; v++) {
        const [E, y] = b[Gi][v];
        p.rules[E].apply(y);
      }
      return b[Gi] = [], null;
    }
    return b[Gi] = [], b.rules = {}, fi.forEach((v) => b.rules[v] = { apply: (E) => b[Gi].push([v, E]) }), b;
  })(n) : null, l = (u || n).rules, f = `.${a}${i.length > 1 ? `:where(.${i.slice(1).join(".")})` : ""}`, h = (p) => {
    p = typeof p == "object" && p || QS;
    const { ...b } = p, v = {};
    for (const A in s)
      if (A in p) {
        r != null && r(A) || delete b[A];
        let I = p[A];
        typeof I == "object" && I ? v[A] = { "@initial": s[A], ...I } : (I = String(I), v[A] = I !== "undefined" || o.has(A) ? I : s[A]);
      } else
        v[A] = s[A];
    const E = /* @__PURE__ */ new Set([...i]);
    for (const [A, I, j, $] of t.composers) {
      n.rules.styled.cache.has(A) || (n.rules.styled.cache.add(A), ci(I, [`.${A}`], [], e, (V) => {
        l.styled.apply(V);
      }));
      const _ = Cm(j, v, e.media), M = Cm($, v, e.media, !0);
      for (const V of _)
        if (V !== void 0)
          for (const [G, O, Q] of V) {
            const ee = `${A}-${Oa(O)}-${G}`;
            E.add(ee);
            const H = (Q ? n.rules.resonevar : n.rules.onevar).cache, D = Q ? l.resonevar : l.onevar;
            H.has(ee) || (H.add(ee), ci(O, [`.${ee}`], [], e, (R) => {
              D.apply(R);
            }));
          }
      for (const V of M)
        if (V !== void 0)
          for (const [G, O] of V) {
            const Q = `${A}-${Oa(O)}-${G}`;
            E.add(Q), n.rules.allvar.cache.has(Q) || (n.rules.allvar.cache.add(Q), ci(O, [`.${Q}`], [], e, (ee) => {
              l.allvar.apply(ee);
            }));
          }
    }
    const y = b.css;
    if (typeof y == "object" && y) {
      r != null && r("css") || delete b.css;
      const A = `${a}-i${Oa(y)}-css`;
      E.add(A), n.rules.inline.cache.has(A) || (n.rules.inline.cache.add(A), ci(y, [`.${A}`], [], e, (I) => {
        l.inline.apply(I);
      }));
    }
    for (const A of String(p.className || "").trim().split(/\s+/))
      A && E.add(A);
    const N = b.className = [...E].join(" ");
    return { type: t.type, className: N, selector: f, props: b, toString: () => N, deferredInjector: u };
  };
  return ed(h, { className: a, selector: f, [Ca]: t, toString: () => (n.rules.styled.cache.has(a) || h(), a) });
}, ZS = (e) => {
  let t = "";
  const n = [], r = {}, a = [];
  for (const [i, , , , s, o] of e) {
    t === "" && (t = i), n.push(i), a.push(...o);
    for (const u in s) {
      const l = s[u];
      (r[u] === void 0 || l !== "undefined" || o.includes(l)) && (r[u] = l);
    }
  }
  return [t, n, r, new Set(a)];
}, Cm = (e, t, n, r) => {
  const a = [];
  e:
    for (let [i, s, o] of e) {
      if (o)
        continue;
      let u, l = 0, f = !1;
      for (u in i) {
        const h = i[u];
        let p = t[u];
        if (p !== h) {
          if (typeof p != "object" || !p)
            continue e;
          {
            let b, v, E = 0;
            for (const y in p) {
              if (h === String(p[y])) {
                if (y !== "@initial") {
                  const N = y.slice(1);
                  (v = v || []).push(N in n ? n[N] : y.replace(/^@media ?/, "")), f = !0;
                }
                l += E, b = !0;
              }
              ++E;
            }
            if (v && v.length && (s = { ["@media " + v.join(", ")]: s }), !b)
              continue e;
          }
        }
      }
      (a[l] = a[l] || []).push([r ? "cv" : `${u}-${i[u]}`, s, f]);
    }
  return a;
}, QS = {}, JS = Ai(), eC = (e, t) => JS(e, () => (...n) => {
  const r = () => {
    for (let a of n) {
      a = typeof a == "object" && a || {};
      let i = Oa(a);
      if (!t.rules.global.cache.has(i)) {
        if (t.rules.global.cache.add(i), "@import" in a) {
          let s = [].indexOf.call(t.sheet.cssRules, t.rules.themed.group) - 1;
          for (let o of [].concat(a["@import"]))
            o = o.includes('"') || o.includes("'") ? o : `"${o}"`, t.sheet.insertRule(`@import ${o};`, s++);
          delete a["@import"];
        }
        ci(a, [], [], e, (s) => {
          t.rules.global.apply(s);
        });
      }
    }
    return "";
  };
  return ed(r, { toString: r });
}), tC = Ai(), nC = (e, t) => tC(e, () => (n) => {
  const r = `${Br(e.prefix)}k-${Oa(n)}`, a = () => {
    if (!t.rules.global.cache.has(r)) {
      t.rules.global.cache.add(r);
      const i = [];
      ci(n, [], [], e, (o) => i.push(o));
      const s = `@keyframes ${r}{${i.join("")}}`;
      t.rules.global.apply(s);
    }
    return r;
  };
  return ed(a, { get name() {
    return a();
  }, toString: a });
}), rC = class {
  constructor(t, n, r, a) {
    this.token = t == null ? "" : String(t), this.value = n == null ? "" : String(n), this.scale = r == null ? "" : String(r), this.prefix = a == null ? "" : String(a);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + Br(this.prefix) + Br(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
}, aC = Ai(), iC = (e, t, n) => aC(e, () => (r, a) => {
  a = typeof r == "object" && r || Object(a);
  const i = `.${r = (r = typeof r == "string" ? r : "") || `${Br(e.prefix)}t-${Oa(a)}`}`, s = {}, o = [];
  for (const l in a) {
    s[l] = {};
    for (const f in a[l]) {
      const h = `--${Br(e.prefix)}${l}-${f}`, p = $1(String(a[l][f]), e.prefix, l);
      s[l][f] = new rC(f, p, l, e.prefix), o.push(`${h}:${p}`);
    }
  }
  const u = () => {
    if (o.length && !t.rules.themed.cache.has(r)) {
      t.rules.themed.cache.add(r);
      const l = () => n ? ":host," : ":root,", f = `${a === e.theme ? l() : ""}.${r}{${o.join(";")}}`;
      t.rules.themed.apply(f);
    }
    return r;
  };
  return { ...s, get className() {
    return u();
  }, selector: i, toString: u };
}), sC = Ai(), oC = Ai(), uC = (e, t = !0) => {
  const n = ((r, a = !0) => {
    let i = !1;
    const s = sC(r, (o) => {
      i = !0;
      const u = "prefix" in (o = typeof o == "object" && o || {}) ? String(o.prefix) : "", l = typeof o.media == "object" && o.media || {}, f = typeof o.root == "object" ? o.root || null : globalThis.document || null, h = typeof o.theme == "object" && o.theme || {}, p = { prefix: u, media: l, theme: h, themeMap: typeof o.themeMap == "object" && o.themeMap || { ...wS }, utils: typeof o.utils == "object" && o.utils || {} }, b = YS(f), v = { css: Sm(p, b), globalCss: eC(p, b), keyframes: nC(p, b), createTheme: iC(p, b, a), reset() {
        b.reset(), v.theme.toString();
      }, transplant(E) {
        const { cssRules: y, ownerNode: N } = b.sheet, A = E.appendChild(N);
        Array.from(y).forEach((I, j) => {
          A.sheet.insertRule(I.cssText, j);
        }), fi.forEach((I, j) => {
          b.rules[I].group = A.sheet.cssRules[2 * j + 1];
        });
      }, theme: {}, sheet: b, config: p, prefix: u, getCssText: b.toString, toString: b.toString };
      return String(v.theme = v.createTheme(h)), v;
    });
    return i || s.reset(), s;
  })(e, t);
  return n.styled = (({ config: r, sheet: a }) => oC(r, () => {
    const i = Sm(r, a), s = (u, l = i, { displayName: f, shouldForwardStitchesProp: h } = {}) => {
      const p = l(...u), b = p[Ca].type, v = h == null ? void 0 : h("as"), E = Tn.forwardRef((y, N) => {
        const A = y != null && y.as && !v ? y == null ? void 0 : y.as : b, { props: I, deferredInjector: j } = p(y);
        return v || delete I.as, I.ref = N, j ? Tn.createElement(Tn.Fragment, null, Tn.createElement(A, I), Tn.createElement(j, null)) : Tn.createElement(A, I);
      });
      return E.className = p.className, E.displayName = f || `Styled.${b.displayName || b.name || b}`, E.selector = p.selector, E.toString = () => p.selector, E[Ca] = p[Ca], E;
    }, o = (...u) => s(u);
    return o.withConfig = (u) => (...l) => {
      const f = i.withConfig(u);
      return s(l, f, u);
    }, o;
  }))(n), n;
};
/*! (c) 2020 Andrea Giammarchi */
var B1 = { exports: {} };
/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    for (var n = function(m, g, T) {
      return g === void 0 && (g = 0), T === void 0 && (T = 1), m < g ? g : m > T ? T : m;
    }, r = n, a = function(m) {
      m._clipped = !1, m._unclipped = m.slice(0);
      for (var g = 0; g <= 3; g++)
        g < 3 ? ((m[g] < 0 || m[g] > 255) && (m._clipped = !0), m[g] = r(m[g], 0, 255)) : g === 3 && (m[g] = r(m[g], 0, 1));
      return m;
    }, i = {}, s = 0, o = ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"]; s < o.length; s += 1) {
      var u = o[s];
      i["[object " + u + "]"] = u.toLowerCase();
    }
    var l = function(m) {
      return i[Object.prototype.toString.call(m)] || "object";
    }, f = l, h = function(m, g) {
      return g === void 0 && (g = null), m.length >= 3 ? Array.prototype.slice.call(m) : f(m[0]) == "object" && g ? g.split("").filter(function(T) {
        return m[0][T] !== void 0;
      }).map(function(T) {
        return m[0][T];
      }) : m[0];
    }, p = l, b = function(m) {
      if (m.length < 2)
        return null;
      var g = m.length - 1;
      return p(m[g]) == "string" ? m[g].toLowerCase() : null;
    }, v = Math.PI, E = {
      clip_rgb: a,
      limit: n,
      type: l,
      unpack: h,
      last: b,
      PI: v,
      TWOPI: v * 2,
      PITHIRD: v / 3,
      DEG2RAD: v / 180,
      RAD2DEG: 180 / v
    }, y = {
      format: {},
      autodetect: []
    }, N = E.last, A = E.clip_rgb, I = E.type, j = y, $ = function() {
      for (var g = [], T = arguments.length; T--; )
        g[T] = arguments[T];
      var k = this;
      if (I(g[0]) === "object" && g[0].constructor && g[0].constructor === this.constructor)
        return g[0];
      var U = N(g), z = !1;
      if (!U) {
        z = !0, j.sorted || (j.autodetect = j.autodetect.sort(function(ue, Te) {
          return Te.p - ue.p;
        }), j.sorted = !0);
        for (var B = 0, q = j.autodetect; B < q.length; B += 1) {
          var X = q[B];
          if (U = X.test.apply(X, g), U)
            break;
        }
      }
      if (j.format[U]) {
        var ie = j.format[U].apply(null, z ? g : g.slice(0, -1));
        k._rgb = A(ie);
      } else
        throw new Error("unknown format: " + g);
      k._rgb.length === 3 && k._rgb.push(1);
    };
    $.prototype.toString = function() {
      return I(this.hex) == "function" ? this.hex() : "[" + this._rgb.join(",") + "]";
    };
    var _ = $, M = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(M.Color, [null].concat(m)))();
    };
    M.Color = _, M.version = "2.4.2";
    var V = M, G = E.unpack, O = Math.max, Q = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = G(m, "rgb"), k = T[0], U = T[1], z = T[2];
      k = k / 255, U = U / 255, z = z / 255;
      var B = 1 - O(k, O(U, z)), q = B < 1 ? 1 / (1 - B) : 0, X = (1 - k - B) * q, ie = (1 - U - B) * q, ue = (1 - z - B) * q;
      return [X, ie, ue, B];
    }, ee = Q, H = E.unpack, D = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      m = H(m, "cmyk");
      var T = m[0], k = m[1], U = m[2], z = m[3], B = m.length > 4 ? m[4] : 1;
      return z === 1 ? [0, 0, 0, B] : [
        T >= 1 ? 0 : 255 * (1 - T) * (1 - z),
        // r
        k >= 1 ? 0 : 255 * (1 - k) * (1 - z),
        // g
        U >= 1 ? 0 : 255 * (1 - U) * (1 - z),
        // b
        B
      ];
    }, R = D, Y = V, P = _, Z = y, W = E.unpack, C = E.type, pe = ee;
    P.prototype.cmyk = function() {
      return pe(this._rgb);
    }, Y.cmyk = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(P, [null].concat(m, ["cmyk"])))();
    }, Z.format.cmyk = R, Z.autodetect.push({
      p: 2,
      test: function() {
        for (var m = [], g = arguments.length; g--; )
          m[g] = arguments[g];
        if (m = W(m, "cmyk"), C(m) === "array" && m.length === 4)
          return "cmyk";
      }
    });
    var me = E.unpack, w = E.last, Ne = function(m) {
      return Math.round(m * 100) / 100;
    }, Re = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = me(m, "hsla"), k = w(m) || "lsa";
      return T[0] = Ne(T[0] || 0), T[1] = Ne(T[1] * 100) + "%", T[2] = Ne(T[2] * 100) + "%", k === "hsla" || T.length > 3 && T[3] < 1 ? (T[3] = T.length > 3 ? T[3] : 1, k = "hsla") : T.length = 3, k + "(" + T.join(",") + ")";
    }, De = Re, Qe = E.unpack, Ue = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      m = Qe(m, "rgba");
      var T = m[0], k = m[1], U = m[2];
      T /= 255, k /= 255, U /= 255;
      var z = Math.min(T, k, U), B = Math.max(T, k, U), q = (B + z) / 2, X, ie;
      return B === z ? (X = 0, ie = Number.NaN) : X = q < 0.5 ? (B - z) / (B + z) : (B - z) / (2 - B - z), T == B ? ie = (k - U) / (B - z) : k == B ? ie = 2 + (U - T) / (B - z) : U == B && (ie = 4 + (T - k) / (B - z)), ie *= 60, ie < 0 && (ie += 360), m.length > 3 && m[3] !== void 0 ? [ie, X, q, m[3]] : [ie, X, q];
    }, Ae = Ue, Me = E.unpack, it = E.last, pt = De, Kt = Ae, Xt = Math.round, un = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = Me(m, "rgba"), k = it(m) || "rgb";
      return k.substr(0, 3) == "hsl" ? pt(Kt(T), k) : (T[0] = Xt(T[0]), T[1] = Xt(T[1]), T[2] = Xt(T[2]), (k === "rgba" || T.length > 3 && T[3] < 1) && (T[3] = T.length > 3 ? T[3] : 1, k = "rgba"), k + "(" + T.slice(0, k === "rgb" ? 3 : 4).join(",") + ")");
    }, wn = un, br = E.unpack, Gn = Math.round, Nr = function() {
      for (var m, g = [], T = arguments.length; T--; )
        g[T] = arguments[T];
      g = br(g, "hsl");
      var k = g[0], U = g[1], z = g[2], B, q, X;
      if (U === 0)
        B = q = X = z * 255;
      else {
        var ie = [0, 0, 0], ue = [0, 0, 0], Te = z < 0.5 ? z * (1 + U) : z + U - z * U, fe = 2 * z - Te, Oe = k / 360;
        ie[0] = Oe + 1 / 3, ie[1] = Oe, ie[2] = Oe - 1 / 3;
        for (var Se = 0; Se < 3; Se++)
          ie[Se] < 0 && (ie[Se] += 1), ie[Se] > 1 && (ie[Se] -= 1), 6 * ie[Se] < 1 ? ue[Se] = fe + (Te - fe) * 6 * ie[Se] : 2 * ie[Se] < 1 ? ue[Se] = Te : 3 * ie[Se] < 2 ? ue[Se] = fe + (Te - fe) * (2 / 3 - ie[Se]) * 6 : ue[Se] = fe;
        m = [Gn(ue[0] * 255), Gn(ue[1] * 255), Gn(ue[2] * 255)], B = m[0], q = m[1], X = m[2];
      }
      return g.length > 3 ? [B, q, X, g[3]] : [B, q, X, 1];
    }, Dn = Nr, Er = Dn, Pn = y, er = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/, Rr = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/, ne = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/, be = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, ke = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/, Pe = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, Je = Math.round, Vt = function(m) {
      m = m.toLowerCase().trim();
      var g;
      if (Pn.format.named)
        try {
          return Pn.format.named(m);
        } catch {
        }
      if (g = m.match(er)) {
        for (var T = g.slice(1, 4), k = 0; k < 3; k++)
          T[k] = +T[k];
        return T[3] = 1, T;
      }
      if (g = m.match(Rr)) {
        for (var U = g.slice(1, 5), z = 0; z < 4; z++)
          U[z] = +U[z];
        return U;
      }
      if (g = m.match(ne)) {
        for (var B = g.slice(1, 4), q = 0; q < 3; q++)
          B[q] = Je(B[q] * 2.55);
        return B[3] = 1, B;
      }
      if (g = m.match(be)) {
        for (var X = g.slice(1, 5), ie = 0; ie < 3; ie++)
          X[ie] = Je(X[ie] * 2.55);
        return X[3] = +X[3], X;
      }
      if (g = m.match(ke)) {
        var ue = g.slice(1, 4);
        ue[1] *= 0.01, ue[2] *= 0.01;
        var Te = Er(ue);
        return Te[3] = 1, Te;
      }
      if (g = m.match(Pe)) {
        var fe = g.slice(1, 4);
        fe[1] *= 0.01, fe[2] *= 0.01;
        var Oe = Er(fe);
        return Oe[3] = +g[4], Oe;
      }
    };
    Vt.test = function(m) {
      return er.test(m) || Rr.test(m) || ne.test(m) || be.test(m) || ke.test(m) || Pe.test(m);
    };
    var Gt = Vt, tn = V, Yn = _, Cn = y, qt = E.type, Wn = wn, ln = Gt;
    Yn.prototype.css = function(m) {
      return Wn(this._rgb, m);
    }, tn.css = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(Yn, [null].concat(m, ["css"])))();
    }, Cn.format.css = ln, Cn.autodetect.push({
      p: 5,
      test: function(m) {
        for (var g = [], T = arguments.length - 1; T-- > 0; )
          g[T] = arguments[T + 1];
        if (!g.length && qt(m) === "string" && ln.test(m))
          return "css";
      }
    });
    var Ga = _, Mi = V, ha = y, Xs = E.unpack;
    ha.format.gl = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = Xs(m, "rgba");
      return T[0] *= 255, T[1] *= 255, T[2] *= 255, T;
    }, Mi.gl = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(Ga, [null].concat(m, ["gl"])))();
    }, Ga.prototype.gl = function() {
      var m = this._rgb;
      return [m[0] / 255, m[1] / 255, m[2] / 255, m[3]];
    };
    var zr = E.unpack, $i = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = zr(m, "rgb"), k = T[0], U = T[1], z = T[2], B = Math.min(k, U, z), q = Math.max(k, U, z), X = q - B, ie = X * 100 / 255, ue = B / (255 - X) * 100, Te;
      return X === 0 ? Te = Number.NaN : (k === q && (Te = (U - z) / X), U === q && (Te = 2 + (z - k) / X), z === q && (Te = 4 + (k - U) / X), Te *= 60, Te < 0 && (Te += 360)), [Te, ie, ue];
    }, Bi = $i, Zs = E.unpack, Gu = Math.floor, Qs = function() {
      for (var m, g, T, k, U, z, B = [], q = arguments.length; q--; )
        B[q] = arguments[q];
      B = Zs(B, "hcg");
      var X = B[0], ie = B[1], ue = B[2], Te, fe, Oe;
      ue = ue * 255;
      var Se = ie * 255;
      if (ie === 0)
        Te = fe = Oe = ue;
      else {
        X === 360 && (X = 0), X > 360 && (X -= 360), X < 0 && (X += 360), X /= 60;
        var Ke = Gu(X), tt = X - Ke, ct = ue * (1 - ie), gt = ct + Se * (1 - tt), rn = ct + Se * tt, Qt = ct + Se;
        switch (Ke) {
          case 0:
            m = [Qt, rn, ct], Te = m[0], fe = m[1], Oe = m[2];
            break;
          case 1:
            g = [gt, Qt, ct], Te = g[0], fe = g[1], Oe = g[2];
            break;
          case 2:
            T = [ct, Qt, rn], Te = T[0], fe = T[1], Oe = T[2];
            break;
          case 3:
            k = [ct, gt, Qt], Te = k[0], fe = k[1], Oe = k[2];
            break;
          case 4:
            U = [rn, ct, Qt], Te = U[0], fe = U[1], Oe = U[2];
            break;
          case 5:
            z = [Qt, ct, gt], Te = z[0], fe = z[1], Oe = z[2];
            break;
        }
      }
      return [Te, fe, Oe, B.length > 3 ? B[3] : 1];
    }, Yu = Qs, Js = E.unpack, eo = E.type, Wu = V, to = _, Fi = y, qu = Bi;
    to.prototype.hcg = function() {
      return qu(this._rgb);
    }, Wu.hcg = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(to, [null].concat(m, ["hcg"])))();
    }, Fi.format.hcg = Yu, Fi.autodetect.push({
      p: 1,
      test: function() {
        for (var m = [], g = arguments.length; g--; )
          m[g] = arguments[g];
        if (m = Js(m, "hcg"), eo(m) === "array" && m.length === 3)
          return "hcg";
      }
    });
    var Ku = E.unpack, Xu = E.last, Ya = Math.round, F = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = Ku(m, "rgba"), k = T[0], U = T[1], z = T[2], B = T[3], q = Xu(m) || "auto";
      B === void 0 && (B = 1), q === "auto" && (q = B < 1 ? "rgba" : "rgb"), k = Ya(k), U = Ya(U), z = Ya(z);
      var X = k << 16 | U << 8 | z, ie = "000000" + X.toString(16);
      ie = ie.substr(ie.length - 6);
      var ue = "0" + Ya(B * 255).toString(16);
      switch (ue = ue.substr(ue.length - 2), q.toLowerCase()) {
        case "rgba":
          return "#" + ie + ue;
        case "argb":
          return "#" + ue + ie;
        default:
          return "#" + ie;
      }
    }, le = F, ve = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, Be = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/, ht = function(m) {
      if (m.match(ve)) {
        (m.length === 4 || m.length === 7) && (m = m.substr(1)), m.length === 3 && (m = m.split(""), m = m[0] + m[0] + m[1] + m[1] + m[2] + m[2]);
        var g = parseInt(m, 16), T = g >> 16, k = g >> 8 & 255, U = g & 255;
        return [T, k, U, 1];
      }
      if (m.match(Be)) {
        (m.length === 5 || m.length === 9) && (m = m.substr(1)), m.length === 4 && (m = m.split(""), m = m[0] + m[0] + m[1] + m[1] + m[2] + m[2] + m[3] + m[3]);
        var z = parseInt(m, 16), B = z >> 24 & 255, q = z >> 16 & 255, X = z >> 8 & 255, ie = Math.round((z & 255) / 255 * 100) / 100;
        return [B, q, X, ie];
      }
      throw new Error("unknown hex color: " + m);
    }, bt = ht, at = V, qe = _, nn = E.type, Dt = y, Ut = le;
    qe.prototype.hex = function(m) {
      return Ut(this._rgb, m);
    }, at.hex = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(qe, [null].concat(m, ["hex"])))();
    }, Dt.format.hex = bt, Dt.autodetect.push({
      p: 4,
      test: function(m) {
        for (var g = [], T = arguments.length - 1; T-- > 0; )
          g[T] = arguments[T + 1];
        if (!g.length && nn(m) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(m.length) >= 0)
          return "hex";
      }
    });
    var On = E.unpack, kr = E.TWOPI, no = Math.min, tr = Math.sqrt, ZA = Math.acos, QA = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = On(m, "rgb"), k = T[0], U = T[1], z = T[2];
      k /= 255, U /= 255, z /= 255;
      var B, q = no(k, U, z), X = (k + U + z) / 3, ie = X > 0 ? 1 - q / X : 0;
      return ie === 0 ? B = NaN : (B = (k - U + (k - z)) / 2, B /= tr((k - U) * (k - U) + (k - z) * (U - z)), B = ZA(B), z > U && (B = kr - B), B /= kr), [B * 360, ie, X];
    }, JA = QA, e_ = E.unpack, Zu = E.limit, Wa = E.TWOPI, Qu = E.PITHIRD, qa = Math.cos, t_ = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      m = e_(m, "hsi");
      var T = m[0], k = m[1], U = m[2], z, B, q;
      return isNaN(T) && (T = 0), isNaN(k) && (k = 0), T > 360 && (T -= 360), T < 0 && (T += 360), T /= 360, T < 1 / 3 ? (q = (1 - k) / 3, z = (1 + k * qa(Wa * T) / qa(Qu - Wa * T)) / 3, B = 1 - (q + z)) : T < 2 / 3 ? (T -= 1 / 3, z = (1 - k) / 3, B = (1 + k * qa(Wa * T) / qa(Qu - Wa * T)) / 3, q = 1 - (z + B)) : (T -= 2 / 3, B = (1 - k) / 3, q = (1 + k * qa(Wa * T) / qa(Qu - Wa * T)) / 3, z = 1 - (B + q)), z = Zu(U * z * 3), B = Zu(U * B * 3), q = Zu(U * q * 3), [z * 255, B * 255, q * 255, m.length > 3 ? m[3] : 1];
    }, n_ = t_, r_ = E.unpack, a_ = E.type, i_ = V, dh = _, hh = y, s_ = JA;
    dh.prototype.hsi = function() {
      return s_(this._rgb);
    }, i_.hsi = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(dh, [null].concat(m, ["hsi"])))();
    }, hh.format.hsi = n_, hh.autodetect.push({
      p: 2,
      test: function() {
        for (var m = [], g = arguments.length; g--; )
          m[g] = arguments[g];
        if (m = r_(m, "hsi"), a_(m) === "array" && m.length === 3)
          return "hsi";
      }
    });
    var o_ = E.unpack, u_ = E.type, l_ = V, mh = _, ph = y, c_ = Ae;
    mh.prototype.hsl = function() {
      return c_(this._rgb);
    }, l_.hsl = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(mh, [null].concat(m, ["hsl"])))();
    }, ph.format.hsl = Dn, ph.autodetect.push({
      p: 2,
      test: function() {
        for (var m = [], g = arguments.length; g--; )
          m[g] = arguments[g];
        if (m = o_(m, "hsl"), u_(m) === "array" && m.length === 3)
          return "hsl";
      }
    });
    var f_ = E.unpack, d_ = Math.min, h_ = Math.max, m_ = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      m = f_(m, "rgb");
      var T = m[0], k = m[1], U = m[2], z = d_(T, k, U), B = h_(T, k, U), q = B - z, X, ie, ue;
      return ue = B / 255, B === 0 ? (X = Number.NaN, ie = 0) : (ie = q / B, T === B && (X = (k - U) / q), k === B && (X = 2 + (U - T) / q), U === B && (X = 4 + (T - k) / q), X *= 60, X < 0 && (X += 360)), [X, ie, ue];
    }, p_ = m_, g_ = E.unpack, b_ = Math.floor, E_ = function() {
      for (var m, g, T, k, U, z, B = [], q = arguments.length; q--; )
        B[q] = arguments[q];
      B = g_(B, "hsv");
      var X = B[0], ie = B[1], ue = B[2], Te, fe, Oe;
      if (ue *= 255, ie === 0)
        Te = fe = Oe = ue;
      else {
        X === 360 && (X = 0), X > 360 && (X -= 360), X < 0 && (X += 360), X /= 60;
        var Se = b_(X), Ke = X - Se, tt = ue * (1 - ie), ct = ue * (1 - ie * Ke), gt = ue * (1 - ie * (1 - Ke));
        switch (Se) {
          case 0:
            m = [ue, gt, tt], Te = m[0], fe = m[1], Oe = m[2];
            break;
          case 1:
            g = [ct, ue, tt], Te = g[0], fe = g[1], Oe = g[2];
            break;
          case 2:
            T = [tt, ue, gt], Te = T[0], fe = T[1], Oe = T[2];
            break;
          case 3:
            k = [tt, ct, ue], Te = k[0], fe = k[1], Oe = k[2];
            break;
          case 4:
            U = [gt, tt, ue], Te = U[0], fe = U[1], Oe = U[2];
            break;
          case 5:
            z = [ue, tt, ct], Te = z[0], fe = z[1], Oe = z[2];
            break;
        }
      }
      return [Te, fe, Oe, B.length > 3 ? B[3] : 1];
    }, v_ = E_, T_ = E.unpack, A_ = E.type, __ = V, gh = _, bh = y, y_ = p_;
    gh.prototype.hsv = function() {
      return y_(this._rgb);
    }, __.hsv = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(gh, [null].concat(m, ["hsv"])))();
    }, bh.format.hsv = v_, bh.autodetect.push({
      p: 2,
      test: function() {
        for (var m = [], g = arguments.length; g--; )
          m[g] = arguments[g];
        if (m = T_(m, "hsv"), A_(m) === "array" && m.length === 3)
          return "hsv";
      }
    });
    var ro = {
      // Corresponds roughly to RGB brighter/darker
      Kn: 18,
      // D65 standard referent
      Xn: 0.95047,
      Yn: 1,
      Zn: 1.08883,
      t0: 0.137931034,
      // 4 / 29
      t1: 0.206896552,
      // 6 / 29
      t2: 0.12841855,
      // 3 * t1 * t1
      t3: 8856452e-9
      // t1 * t1 * t1
    }, Ka = ro, S_ = E.unpack, Eh = Math.pow, C_ = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = S_(m, "rgb"), k = T[0], U = T[1], z = T[2], B = O_(k, U, z), q = B[0], X = B[1], ie = B[2], ue = 116 * X - 16;
      return [ue < 0 ? 0 : ue, 500 * (q - X), 200 * (X - ie)];
    }, Ju = function(m) {
      return (m /= 255) <= 0.04045 ? m / 12.92 : Eh((m + 0.055) / 1.055, 2.4);
    }, el = function(m) {
      return m > Ka.t3 ? Eh(m, 1 / 3) : m / Ka.t2 + Ka.t0;
    }, O_ = function(m, g, T) {
      m = Ju(m), g = Ju(g), T = Ju(T);
      var k = el((0.4124564 * m + 0.3575761 * g + 0.1804375 * T) / Ka.Xn), U = el((0.2126729 * m + 0.7151522 * g + 0.072175 * T) / Ka.Yn), z = el((0.0193339 * m + 0.119192 * g + 0.9503041 * T) / Ka.Zn);
      return [k, U, z];
    }, vh = C_, Xa = ro, I_ = E.unpack, x_ = Math.pow, N_ = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      m = I_(m, "lab");
      var T = m[0], k = m[1], U = m[2], z, B, q, X, ie, ue;
      return B = (T + 16) / 116, z = isNaN(k) ? B : B + k / 500, q = isNaN(U) ? B : B - U / 200, B = Xa.Yn * nl(B), z = Xa.Xn * nl(z), q = Xa.Zn * nl(q), X = tl(3.2404542 * z - 1.5371385 * B - 0.4985314 * q), ie = tl(-0.969266 * z + 1.8760108 * B + 0.041556 * q), ue = tl(0.0556434 * z - 0.2040259 * B + 1.0572252 * q), [X, ie, ue, m.length > 3 ? m[3] : 1];
    }, tl = function(m) {
      return 255 * (m <= 304e-5 ? 12.92 * m : 1.055 * x_(m, 1 / 2.4) - 0.055);
    }, nl = function(m) {
      return m > Xa.t1 ? m * m * m : Xa.t2 * (m - Xa.t0);
    }, Th = N_, R_ = E.unpack, k_ = E.type, w_ = V, Ah = _, _h = y, D_ = vh;
    Ah.prototype.lab = function() {
      return D_(this._rgb);
    }, w_.lab = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(Ah, [null].concat(m, ["lab"])))();
    }, _h.format.lab = Th, _h.autodetect.push({
      p: 2,
      test: function() {
        for (var m = [], g = arguments.length; g--; )
          m[g] = arguments[g];
        if (m = R_(m, "lab"), k_(m) === "array" && m.length === 3)
          return "lab";
      }
    });
    var P_ = E.unpack, L_ = E.RAD2DEG, M_ = Math.sqrt, $_ = Math.atan2, B_ = Math.round, F_ = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = P_(m, "lab"), k = T[0], U = T[1], z = T[2], B = M_(U * U + z * z), q = ($_(z, U) * L_ + 360) % 360;
      return B_(B * 1e4) === 0 && (q = Number.NaN), [k, B, q];
    }, yh = F_, U_ = E.unpack, H_ = vh, j_ = yh, z_ = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = U_(m, "rgb"), k = T[0], U = T[1], z = T[2], B = H_(k, U, z), q = B[0], X = B[1], ie = B[2];
      return j_(q, X, ie);
    }, V_ = z_, G_ = E.unpack, Y_ = E.DEG2RAD, W_ = Math.sin, q_ = Math.cos, K_ = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = G_(m, "lch"), k = T[0], U = T[1], z = T[2];
      return isNaN(z) && (z = 0), z = z * Y_, [k, q_(z) * U, W_(z) * U];
    }, Sh = K_, X_ = E.unpack, Z_ = Sh, Q_ = Th, J_ = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      m = X_(m, "lch");
      var T = m[0], k = m[1], U = m[2], z = Z_(T, k, U), B = z[0], q = z[1], X = z[2], ie = Q_(B, q, X), ue = ie[0], Te = ie[1], fe = ie[2];
      return [ue, Te, fe, m.length > 3 ? m[3] : 1];
    }, Ch = J_, ey = E.unpack, ty = Ch, ny = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = ey(m, "hcl").reverse();
      return ty.apply(void 0, T);
    }, ry = ny, ay = E.unpack, iy = E.type, Oh = V, ao = _, rl = y, Ih = V_;
    ao.prototype.lch = function() {
      return Ih(this._rgb);
    }, ao.prototype.hcl = function() {
      return Ih(this._rgb).reverse();
    }, Oh.lch = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(ao, [null].concat(m, ["lch"])))();
    }, Oh.hcl = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(ao, [null].concat(m, ["hcl"])))();
    }, rl.format.lch = Ch, rl.format.hcl = ry, ["lch", "hcl"].forEach(function(m) {
      return rl.autodetect.push({
        p: 2,
        test: function() {
          for (var g = [], T = arguments.length; T--; )
            g[T] = arguments[T];
          if (g = ay(g, m), iy(g) === "array" && g.length === 3)
            return m;
        }
      });
    });
    var sy = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflower: "#6495ed",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      laserlemon: "#ffff54",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrod: "#fafad2",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      maroon2: "#7f0000",
      maroon3: "#b03060",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      purple2: "#7f007f",
      purple3: "#a020f0",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    }, xh = sy, oy = _, Nh = y, uy = E.type, Ui = xh, ly = bt, cy = le;
    oy.prototype.name = function() {
      for (var m = cy(this._rgb, "rgb"), g = 0, T = Object.keys(Ui); g < T.length; g += 1) {
        var k = T[g];
        if (Ui[k] === m)
          return k.toLowerCase();
      }
      return m;
    }, Nh.format.named = function(m) {
      if (m = m.toLowerCase(), Ui[m])
        return ly(Ui[m]);
      throw new Error("unknown color name: " + m);
    }, Nh.autodetect.push({
      p: 5,
      test: function(m) {
        for (var g = [], T = arguments.length - 1; T-- > 0; )
          g[T] = arguments[T + 1];
        if (!g.length && uy(m) === "string" && Ui[m.toLowerCase()])
          return "named";
      }
    });
    var fy = E.unpack, dy = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = fy(m, "rgb"), k = T[0], U = T[1], z = T[2];
      return (k << 16) + (U << 8) + z;
    }, hy = dy, my = E.type, py = function(m) {
      if (my(m) == "number" && m >= 0 && m <= 16777215) {
        var g = m >> 16, T = m >> 8 & 255, k = m & 255;
        return [g, T, k, 1];
      }
      throw new Error("unknown num color: " + m);
    }, gy = py, by = V, Rh = _, kh = y, Ey = E.type, vy = hy;
    Rh.prototype.num = function() {
      return vy(this._rgb);
    }, by.num = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(Rh, [null].concat(m, ["num"])))();
    }, kh.format.num = gy, kh.autodetect.push({
      p: 5,
      test: function() {
        for (var m = [], g = arguments.length; g--; )
          m[g] = arguments[g];
        if (m.length === 1 && Ey(m[0]) === "number" && m[0] >= 0 && m[0] <= 16777215)
          return "num";
      }
    });
    var Ty = V, al = _, wh = y, Dh = E.unpack, Ph = E.type, Lh = Math.round;
    al.prototype.rgb = function(m) {
      return m === void 0 && (m = !0), m === !1 ? this._rgb.slice(0, 3) : this._rgb.slice(0, 3).map(Lh);
    }, al.prototype.rgba = function(m) {
      return m === void 0 && (m = !0), this._rgb.slice(0, 4).map(function(g, T) {
        return T < 3 ? m === !1 ? g : Lh(g) : g;
      });
    }, Ty.rgb = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(al, [null].concat(m, ["rgb"])))();
    }, wh.format.rgb = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = Dh(m, "rgba");
      return T[3] === void 0 && (T[3] = 1), T;
    }, wh.autodetect.push({
      p: 3,
      test: function() {
        for (var m = [], g = arguments.length; g--; )
          m[g] = arguments[g];
        if (m = Dh(m, "rgba"), Ph(m) === "array" && (m.length === 3 || m.length === 4 && Ph(m[3]) == "number" && m[3] >= 0 && m[3] <= 1))
          return "rgb";
      }
    });
    var io = Math.log, Ay = function(m) {
      var g = m / 100, T, k, U;
      return g < 66 ? (T = 255, k = g < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (k = g - 2) + 104.49216199393888 * io(k), U = g < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (U = g - 10) + 115.67994401066147 * io(U)) : (T = 351.97690566805693 + 0.114206453784165 * (T = g - 55) - 40.25366309332127 * io(T), k = 325.4494125711974 + 0.07943456536662342 * (k = g - 50) - 28.0852963507957 * io(k), U = 255), [T, k, U, 1];
    }, Mh = Ay, _y = Mh, yy = E.unpack, Sy = Math.round, Cy = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      for (var T = yy(m, "rgb"), k = T[0], U = T[2], z = 1e3, B = 4e4, q = 0.4, X; B - z > q; ) {
        X = (B + z) * 0.5;
        var ie = _y(X);
        ie[2] / ie[0] >= U / k ? B = X : z = X;
      }
      return Sy(X);
    }, Oy = Cy, il = V, so = _, sl = y, Iy = Oy;
    so.prototype.temp = so.prototype.kelvin = so.prototype.temperature = function() {
      return Iy(this._rgb);
    }, il.temp = il.kelvin = il.temperature = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(so, [null].concat(m, ["temp"])))();
    }, sl.format.temp = sl.format.kelvin = sl.format.temperature = Mh;
    var xy = E.unpack, ol = Math.cbrt, Ny = Math.pow, Ry = Math.sign, ky = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = xy(m, "rgb"), k = T[0], U = T[1], z = T[2], B = [ul(k / 255), ul(U / 255), ul(z / 255)], q = B[0], X = B[1], ie = B[2], ue = ol(0.4122214708 * q + 0.5363325363 * X + 0.0514459929 * ie), Te = ol(0.2119034982 * q + 0.6806995451 * X + 0.1073969566 * ie), fe = ol(0.0883024619 * q + 0.2817188376 * X + 0.6299787005 * ie);
      return [
        0.2104542553 * ue + 0.793617785 * Te - 0.0040720468 * fe,
        1.9779984951 * ue - 2.428592205 * Te + 0.4505937099 * fe,
        0.0259040371 * ue + 0.7827717662 * Te - 0.808675766 * fe
      ];
    }, $h = ky;
    function ul(m) {
      var g = Math.abs(m);
      return g < 0.04045 ? m / 12.92 : (Ry(m) || 1) * Ny((g + 0.055) / 1.055, 2.4);
    }
    var wy = E.unpack, oo = Math.pow, Dy = Math.sign, Py = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      m = wy(m, "lab");
      var T = m[0], k = m[1], U = m[2], z = oo(T + 0.3963377774 * k + 0.2158037573 * U, 3), B = oo(T - 0.1055613458 * k - 0.0638541728 * U, 3), q = oo(T - 0.0894841775 * k - 1.291485548 * U, 3);
      return [
        255 * ll(4.0767416621 * z - 3.3077115913 * B + 0.2309699292 * q),
        255 * ll(-1.2684380046 * z + 2.6097574011 * B - 0.3413193965 * q),
        255 * ll(-0.0041960863 * z - 0.7034186147 * B + 1.707614701 * q),
        m.length > 3 ? m[3] : 1
      ];
    }, Bh = Py;
    function ll(m) {
      var g = Math.abs(m);
      return g > 31308e-7 ? (Dy(m) || 1) * (1.055 * oo(g, 1 / 2.4) - 0.055) : m * 12.92;
    }
    var Ly = E.unpack, My = E.type, $y = V, Fh = _, Uh = y, By = $h;
    Fh.prototype.oklab = function() {
      return By(this._rgb);
    }, $y.oklab = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(Fh, [null].concat(m, ["oklab"])))();
    }, Uh.format.oklab = Bh, Uh.autodetect.push({
      p: 3,
      test: function() {
        for (var m = [], g = arguments.length; g--; )
          m[g] = arguments[g];
        if (m = Ly(m, "oklab"), My(m) === "array" && m.length === 3)
          return "oklab";
      }
    });
    var Fy = E.unpack, Uy = $h, Hy = yh, jy = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      var T = Fy(m, "rgb"), k = T[0], U = T[1], z = T[2], B = Uy(k, U, z), q = B[0], X = B[1], ie = B[2];
      return Hy(q, X, ie);
    }, zy = jy, Vy = E.unpack, Gy = Sh, Yy = Bh, Wy = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      m = Vy(m, "lch");
      var T = m[0], k = m[1], U = m[2], z = Gy(T, k, U), B = z[0], q = z[1], X = z[2], ie = Yy(B, q, X), ue = ie[0], Te = ie[1], fe = ie[2];
      return [ue, Te, fe, m.length > 3 ? m[3] : 1];
    }, qy = Wy, Ky = E.unpack, Xy = E.type, Zy = V, Hh = _, jh = y, Qy = zy;
    Hh.prototype.oklch = function() {
      return Qy(this._rgb);
    }, Zy.oklch = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      return new (Function.prototype.bind.apply(Hh, [null].concat(m, ["oklch"])))();
    }, jh.format.oklch = qy, jh.autodetect.push({
      p: 3,
      test: function() {
        for (var m = [], g = arguments.length; g--; )
          m[g] = arguments[g];
        if (m = Ky(m, "oklch"), Xy(m) === "array" && m.length === 3)
          return "oklch";
      }
    });
    var zh = _, Jy = E.type;
    zh.prototype.alpha = function(m, g) {
      return g === void 0 && (g = !1), m !== void 0 && Jy(m) === "number" ? g ? (this._rgb[3] = m, this) : new zh([this._rgb[0], this._rgb[1], this._rgb[2], m], "rgb") : this._rgb[3];
    };
    var e2 = _;
    e2.prototype.clipped = function() {
      return this._rgb._clipped || !1;
    };
    var ma = _, t2 = ro;
    ma.prototype.darken = function(m) {
      m === void 0 && (m = 1);
      var g = this, T = g.lab();
      return T[0] -= t2.Kn * m, new ma(T, "lab").alpha(g.alpha(), !0);
    }, ma.prototype.brighten = function(m) {
      return m === void 0 && (m = 1), this.darken(-m);
    }, ma.prototype.darker = ma.prototype.darken, ma.prototype.brighter = ma.prototype.brighten;
    var n2 = _;
    n2.prototype.get = function(m) {
      var g = m.split("."), T = g[0], k = g[1], U = this[T]();
      if (k) {
        var z = T.indexOf(k) - (T.substr(0, 2) === "ok" ? 2 : 0);
        if (z > -1)
          return U[z];
        throw new Error("unknown channel " + k + " in mode " + T);
      } else
        return U;
    };
    var Za = _, r2 = E.type, a2 = Math.pow, i2 = 1e-7, s2 = 20;
    Za.prototype.luminance = function(m) {
      if (m !== void 0 && r2(m) === "number") {
        if (m === 0)
          return new Za([0, 0, 0, this._rgb[3]], "rgb");
        if (m === 1)
          return new Za([255, 255, 255, this._rgb[3]], "rgb");
        var g = this.luminance(), T = "rgb", k = s2, U = function(B, q) {
          var X = B.interpolate(q, 0.5, T), ie = X.luminance();
          return Math.abs(m - ie) < i2 || !k-- ? X : ie > m ? U(B, X) : U(X, q);
        }, z = (g > m ? U(new Za([0, 0, 0]), this) : U(this, new Za([255, 255, 255]))).rgb();
        return new Za(z.concat([this._rgb[3]]));
      }
      return o2.apply(void 0, this._rgb.slice(0, 3));
    };
    var o2 = function(m, g, T) {
      return m = cl(m), g = cl(g), T = cl(T), 0.2126 * m + 0.7152 * g + 0.0722 * T;
    }, cl = function(m) {
      return m /= 255, m <= 0.03928 ? m / 12.92 : a2((m + 0.055) / 1.055, 2.4);
    }, Ln = {}, Vh = _, Gh = E.type, uo = Ln, Yh = function(m, g, T) {
      T === void 0 && (T = 0.5);
      for (var k = [], U = arguments.length - 3; U-- > 0; )
        k[U] = arguments[U + 3];
      var z = k[0] || "lrgb";
      if (!uo[z] && !k.length && (z = Object.keys(uo)[0]), !uo[z])
        throw new Error("interpolation mode " + z + " is not defined");
      return Gh(m) !== "object" && (m = new Vh(m)), Gh(g) !== "object" && (g = new Vh(g)), uo[z](m, g, T).alpha(m.alpha() + T * (g.alpha() - m.alpha()));
    }, Wh = _, u2 = Yh;
    Wh.prototype.mix = Wh.prototype.interpolate = function(m, g) {
      g === void 0 && (g = 0.5);
      for (var T = [], k = arguments.length - 2; k-- > 0; )
        T[k] = arguments[k + 2];
      return u2.apply(void 0, [this, m, g].concat(T));
    };
    var qh = _;
    qh.prototype.premultiply = function(m) {
      m === void 0 && (m = !1);
      var g = this._rgb, T = g[3];
      return m ? (this._rgb = [g[0] * T, g[1] * T, g[2] * T, T], this) : new qh([g[0] * T, g[1] * T, g[2] * T, T], "rgb");
    };
    var fl = _, l2 = ro;
    fl.prototype.saturate = function(m) {
      m === void 0 && (m = 1);
      var g = this, T = g.lch();
      return T[1] += l2.Kn * m, T[1] < 0 && (T[1] = 0), new fl(T, "lch").alpha(g.alpha(), !0);
    }, fl.prototype.desaturate = function(m) {
      return m === void 0 && (m = 1), this.saturate(-m);
    };
    var Kh = _, Xh = E.type;
    Kh.prototype.set = function(m, g, T) {
      T === void 0 && (T = !1);
      var k = m.split("."), U = k[0], z = k[1], B = this[U]();
      if (z) {
        var q = U.indexOf(z) - (U.substr(0, 2) === "ok" ? 2 : 0);
        if (q > -1) {
          if (Xh(g) == "string")
            switch (g.charAt(0)) {
              case "+":
                B[q] += +g;
                break;
              case "-":
                B[q] += +g;
                break;
              case "*":
                B[q] *= +g.substr(1);
                break;
              case "/":
                B[q] /= +g.substr(1);
                break;
              default:
                B[q] = +g;
            }
          else if (Xh(g) === "number")
            B[q] = g;
          else
            throw new Error("unsupported value for Color.set");
          var X = new Kh(B, U);
          return T ? (this._rgb = X._rgb, this) : X;
        }
        throw new Error("unknown channel " + z + " in mode " + U);
      } else
        return B;
    };
    var c2 = _, f2 = function(m, g, T) {
      var k = m._rgb, U = g._rgb;
      return new c2(
        k[0] + T * (U[0] - k[0]),
        k[1] + T * (U[1] - k[1]),
        k[2] + T * (U[2] - k[2]),
        "rgb"
      );
    };
    Ln.rgb = f2;
    var d2 = _, dl = Math.sqrt, Qa = Math.pow, h2 = function(m, g, T) {
      var k = m._rgb, U = k[0], z = k[1], B = k[2], q = g._rgb, X = q[0], ie = q[1], ue = q[2];
      return new d2(
        dl(Qa(U, 2) * (1 - T) + Qa(X, 2) * T),
        dl(Qa(z, 2) * (1 - T) + Qa(ie, 2) * T),
        dl(Qa(B, 2) * (1 - T) + Qa(ue, 2) * T),
        "rgb"
      );
    };
    Ln.lrgb = h2;
    var m2 = _, p2 = function(m, g, T) {
      var k = m.lab(), U = g.lab();
      return new m2(
        k[0] + T * (U[0] - k[0]),
        k[1] + T * (U[1] - k[1]),
        k[2] + T * (U[2] - k[2]),
        "lab"
      );
    };
    Ln.lab = p2;
    var Zh = _, Ja = function(m, g, T, k) {
      var U, z, B, q;
      k === "hsl" ? (B = m.hsl(), q = g.hsl()) : k === "hsv" ? (B = m.hsv(), q = g.hsv()) : k === "hcg" ? (B = m.hcg(), q = g.hcg()) : k === "hsi" ? (B = m.hsi(), q = g.hsi()) : k === "lch" || k === "hcl" ? (k = "hcl", B = m.hcl(), q = g.hcl()) : k === "oklch" && (B = m.oklch().reverse(), q = g.oklch().reverse());
      var X, ie, ue, Te, fe, Oe;
      (k.substr(0, 1) === "h" || k === "oklch") && (U = B, X = U[0], ue = U[1], fe = U[2], z = q, ie = z[0], Te = z[1], Oe = z[2]);
      var Se, Ke, tt, ct;
      return !isNaN(X) && !isNaN(ie) ? (ie > X && ie - X > 180 ? ct = ie - (X + 360) : ie < X && X - ie > 180 ? ct = ie + 360 - X : ct = ie - X, Ke = X + T * ct) : isNaN(X) ? isNaN(ie) ? Ke = Number.NaN : (Ke = ie, (fe == 1 || fe == 0) && k != "hsv" && (Se = Te)) : (Ke = X, (Oe == 1 || Oe == 0) && k != "hsv" && (Se = ue)), Se === void 0 && (Se = ue + T * (Te - ue)), tt = fe + T * (Oe - fe), k === "oklch" ? new Zh([tt, Se, Ke], k) : new Zh([Ke, Se, tt], k);
    }, g2 = Ja, Qh = function(m, g, T) {
      return g2(m, g, T, "lch");
    };
    Ln.lch = Qh, Ln.hcl = Qh;
    var b2 = _, E2 = function(m, g, T) {
      var k = m.num(), U = g.num();
      return new b2(k + T * (U - k), "num");
    };
    Ln.num = E2;
    var v2 = Ja, T2 = function(m, g, T) {
      return v2(m, g, T, "hcg");
    };
    Ln.hcg = T2;
    var A2 = Ja, _2 = function(m, g, T) {
      return A2(m, g, T, "hsi");
    };
    Ln.hsi = _2;
    var y2 = Ja, S2 = function(m, g, T) {
      return y2(m, g, T, "hsl");
    };
    Ln.hsl = S2;
    var C2 = Ja, O2 = function(m, g, T) {
      return C2(m, g, T, "hsv");
    };
    Ln.hsv = O2;
    var I2 = _, x2 = function(m, g, T) {
      var k = m.oklab(), U = g.oklab();
      return new I2(
        k[0] + T * (U[0] - k[0]),
        k[1] + T * (U[1] - k[1]),
        k[2] + T * (U[2] - k[2]),
        "oklab"
      );
    };
    Ln.oklab = x2;
    var N2 = Ja, R2 = function(m, g, T) {
      return N2(m, g, T, "oklch");
    };
    Ln.oklch = R2;
    var hl = _, k2 = E.clip_rgb, ml = Math.pow, pl = Math.sqrt, gl = Math.PI, Jh = Math.cos, em = Math.sin, w2 = Math.atan2, D2 = function(m, g, T) {
      g === void 0 && (g = "lrgb"), T === void 0 && (T = null);
      var k = m.length;
      T || (T = Array.from(new Array(k)).map(function() {
        return 1;
      }));
      var U = k / T.reduce(function(Ke, tt) {
        return Ke + tt;
      });
      if (T.forEach(function(Ke, tt) {
        T[tt] *= U;
      }), m = m.map(function(Ke) {
        return new hl(Ke);
      }), g === "lrgb")
        return P2(m, T);
      for (var z = m.shift(), B = z.get(g), q = [], X = 0, ie = 0, ue = 0; ue < B.length; ue++)
        if (B[ue] = (B[ue] || 0) * T[0], q.push(isNaN(B[ue]) ? 0 : T[0]), g.charAt(ue) === "h" && !isNaN(B[ue])) {
          var Te = B[ue] / 180 * gl;
          X += Jh(Te) * T[0], ie += em(Te) * T[0];
        }
      var fe = z.alpha() * T[0];
      m.forEach(function(Ke, tt) {
        var ct = Ke.get(g);
        fe += Ke.alpha() * T[tt + 1];
        for (var gt = 0; gt < B.length; gt++)
          if (!isNaN(ct[gt]))
            if (q[gt] += T[tt + 1], g.charAt(gt) === "h") {
              var rn = ct[gt] / 180 * gl;
              X += Jh(rn) * T[tt + 1], ie += em(rn) * T[tt + 1];
            } else
              B[gt] += ct[gt] * T[tt + 1];
      });
      for (var Oe = 0; Oe < B.length; Oe++)
        if (g.charAt(Oe) === "h") {
          for (var Se = w2(ie / q[Oe], X / q[Oe]) / gl * 180; Se < 0; )
            Se += 360;
          for (; Se >= 360; )
            Se -= 360;
          B[Oe] = Se;
        } else
          B[Oe] = B[Oe] / q[Oe];
      return fe /= k, new hl(B, g).alpha(fe > 0.99999 ? 1 : fe, !0);
    }, P2 = function(m, g) {
      for (var T = m.length, k = [0, 0, 0, 0], U = 0; U < m.length; U++) {
        var z = m[U], B = g[U] / T, q = z._rgb;
        k[0] += ml(q[0], 2) * B, k[1] += ml(q[1], 2) * B, k[2] += ml(q[2], 2) * B, k[3] += q[3] * B;
      }
      return k[0] = pl(k[0]), k[1] = pl(k[1]), k[2] = pl(k[2]), k[3] > 0.9999999 && (k[3] = 1), new hl(k2(k));
    }, nr = V, ei = E.type, L2 = Math.pow, bl = function(m) {
      var g = "rgb", T = nr("#ccc"), k = 0, U = [0, 1], z = [], B = [0, 0], q = !1, X = [], ie = !1, ue = 0, Te = 1, fe = !1, Oe = {}, Se = !0, Ke = 1, tt = function(de) {
        if (de = de || ["#fff", "#000"], de && ei(de) === "string" && nr.brewer && nr.brewer[de.toLowerCase()] && (de = nr.brewer[de.toLowerCase()]), ei(de) === "array") {
          de.length === 1 && (de = [de[0], de[0]]), de = de.slice(0);
          for (var Le = 0; Le < de.length; Le++)
            de[Le] = nr(de[Le]);
          z.length = 0;
          for (var et = 0; et < de.length; et++)
            z.push(et / (de.length - 1));
        }
        return In(), X = de;
      }, ct = function(de) {
        if (q != null) {
          for (var Le = q.length - 1, et = 0; et < Le && de >= q[et]; )
            et++;
          return et - 1;
        }
        return 0;
      }, gt = function(de) {
        return de;
      }, rn = function(de) {
        return de;
      }, Qt = function(de, Le) {
        var et, Xe;
        if (Le == null && (Le = !1), isNaN(de) || de === null)
          return T;
        if (Le)
          Xe = de;
        else if (q && q.length > 2) {
          var an = ct(de);
          Xe = an / (q.length - 2);
        } else
          Te !== ue ? Xe = (de - ue) / (Te - ue) : Xe = 1;
        Xe = rn(Xe), Le || (Xe = gt(Xe)), Ke !== 1 && (Xe = L2(Xe, Ke)), Xe = B[0] + Xe * (1 - B[0] - B[1]), Xe = Math.min(1, Math.max(0, Xe));
        var It = Math.floor(Xe * 1e4);
        if (Se && Oe[It])
          et = Oe[It];
        else {
          if (ei(X) === "array")
            for (var ft = 0; ft < z.length; ft++) {
              var Et = z[ft];
              if (Xe <= Et) {
                et = X[ft];
                break;
              }
              if (Xe >= Et && ft === z.length - 1) {
                et = X[ft];
                break;
              }
              if (Xe > Et && Xe < z[ft + 1]) {
                Xe = (Xe - Et) / (z[ft + 1] - Et), et = nr.interpolate(X[ft], X[ft + 1], Xe, g);
                break;
              }
            }
          else
            ei(X) === "function" && (et = X(Xe));
          Se && (Oe[It] = et);
        }
        return et;
      }, In = function() {
        return Oe = {};
      };
      tt(m);
      var st = function(de) {
        var Le = nr(Qt(de));
        return ie && Le[ie] ? Le[ie]() : Le;
      };
      return st.classes = function(de) {
        if (de != null) {
          if (ei(de) === "array")
            q = de, U = [de[0], de[de.length - 1]];
          else {
            var Le = nr.analyze(U);
            de === 0 ? q = [Le.min, Le.max] : q = nr.limits(Le, "e", de);
          }
          return st;
        }
        return q;
      }, st.domain = function(de) {
        if (!arguments.length)
          return U;
        ue = de[0], Te = de[de.length - 1], z = [];
        var Le = X.length;
        if (de.length === Le && ue !== Te)
          for (var et = 0, Xe = Array.from(de); et < Xe.length; et += 1) {
            var an = Xe[et];
            z.push((an - ue) / (Te - ue));
          }
        else {
          for (var It = 0; It < Le; It++)
            z.push(It / (Le - 1));
          if (de.length > 2) {
            var ft = de.map(function(vt, At) {
              return At / (de.length - 1);
            }), Et = de.map(function(vt) {
              return (vt - ue) / (Te - ue);
            });
            Et.every(function(vt, At) {
              return ft[At] === vt;
            }) || (rn = function(vt) {
              if (vt <= 0 || vt >= 1)
                return vt;
              for (var At = 0; vt >= Et[At + 1]; )
                At++;
              var ar = (vt - Et[At]) / (Et[At + 1] - Et[At]), Yr = ft[At] + ar * (ft[At + 1] - ft[At]);
              return Yr;
            });
          }
        }
        return U = [ue, Te], st;
      }, st.mode = function(de) {
        return arguments.length ? (g = de, In(), st) : g;
      }, st.range = function(de, Le) {
        return tt(de), st;
      }, st.out = function(de) {
        return ie = de, st;
      }, st.spread = function(de) {
        return arguments.length ? (k = de, st) : k;
      }, st.correctLightness = function(de) {
        return de == null && (de = !0), fe = de, In(), fe ? gt = function(Le) {
          for (var et = Qt(0, !0).lab()[0], Xe = Qt(1, !0).lab()[0], an = et > Xe, It = Qt(Le, !0).lab()[0], ft = et + (Xe - et) * Le, Et = It - ft, vt = 0, At = 1, ar = 20; Math.abs(Et) > 0.01 && ar-- > 0; )
            (function() {
              return an && (Et *= -1), Et < 0 ? (vt = Le, Le += (At - Le) * 0.5) : (At = Le, Le += (vt - Le) * 0.5), It = Qt(Le, !0).lab()[0], Et = It - ft;
            })();
          return Le;
        } : gt = function(Le) {
          return Le;
        }, st;
      }, st.padding = function(de) {
        return de != null ? (ei(de) === "number" && (de = [de, de]), B = de, st) : B;
      }, st.colors = function(de, Le) {
        arguments.length < 2 && (Le = "hex");
        var et = [];
        if (arguments.length === 0)
          et = X.slice(0);
        else if (de === 1)
          et = [st(0.5)];
        else if (de > 1) {
          var Xe = U[0], an = U[1] - Xe;
          et = M2(0, de, !1).map(function(At) {
            return st(Xe + At / (de - 1) * an);
          });
        } else {
          m = [];
          var It = [];
          if (q && q.length > 2)
            for (var ft = 1, Et = q.length, vt = 1 <= Et; vt ? ft < Et : ft > Et; vt ? ft++ : ft--)
              It.push((q[ft - 1] + q[ft]) * 0.5);
          else
            It = U;
          et = It.map(function(At) {
            return st(At);
          });
        }
        return nr[Le] && (et = et.map(function(At) {
          return At[Le]();
        })), et;
      }, st.cache = function(de) {
        return de != null ? (Se = de, st) : Se;
      }, st.gamma = function(de) {
        return de != null ? (Ke = de, st) : Ke;
      }, st.nodata = function(de) {
        return de != null ? (T = nr(de), st) : T;
      }, st;
    };
    function M2(m, g, T) {
      for (var k = [], U = m < g, z = T ? U ? g + 1 : g - 1 : g, B = m; U ? B < z : B > z; U ? B++ : B--)
        k.push(B);
      return k;
    }
    var Hi = _, $2 = bl, B2 = function(m) {
      for (var g = [1, 1], T = 1; T < m; T++) {
        for (var k = [1], U = 1; U <= g.length; U++)
          k[U] = (g[U] || 0) + g[U - 1];
        g = k;
      }
      return g;
    }, F2 = function(m) {
      var g, T, k, U, z, B, q;
      if (m = m.map(function(fe) {
        return new Hi(fe);
      }), m.length === 2)
        g = m.map(function(fe) {
          return fe.lab();
        }), z = g[0], B = g[1], U = function(fe) {
          var Oe = [0, 1, 2].map(function(Se) {
            return z[Se] + fe * (B[Se] - z[Se]);
          });
          return new Hi(Oe, "lab");
        };
      else if (m.length === 3)
        T = m.map(function(fe) {
          return fe.lab();
        }), z = T[0], B = T[1], q = T[2], U = function(fe) {
          var Oe = [0, 1, 2].map(function(Se) {
            return (1 - fe) * (1 - fe) * z[Se] + 2 * (1 - fe) * fe * B[Se] + fe * fe * q[Se];
          });
          return new Hi(Oe, "lab");
        };
      else if (m.length === 4) {
        var X;
        k = m.map(function(fe) {
          return fe.lab();
        }), z = k[0], B = k[1], q = k[2], X = k[3], U = function(fe) {
          var Oe = [0, 1, 2].map(function(Se) {
            return (1 - fe) * (1 - fe) * (1 - fe) * z[Se] + 3 * (1 - fe) * (1 - fe) * fe * B[Se] + 3 * (1 - fe) * fe * fe * q[Se] + fe * fe * fe * X[Se];
          });
          return new Hi(Oe, "lab");
        };
      } else if (m.length >= 5) {
        var ie, ue, Te;
        ie = m.map(function(fe) {
          return fe.lab();
        }), Te = m.length - 1, ue = B2(Te), U = function(fe) {
          var Oe = 1 - fe, Se = [0, 1, 2].map(function(Ke) {
            return ie.reduce(function(tt, ct, gt) {
              return tt + ue[gt] * Math.pow(Oe, Te - gt) * Math.pow(fe, gt) * ct[Ke];
            }, 0);
          });
          return new Hi(Se, "lab");
        };
      } else
        throw new RangeError("No point in running bezier with only one color.");
      return U;
    }, U2 = function(m) {
      var g = F2(m);
      return g.scale = function() {
        return $2(g);
      }, g;
    }, El = V, rr = function(m, g, T) {
      if (!rr[T])
        throw new Error("unknown blend mode " + T);
      return rr[T](m, g);
    }, Vr = function(m) {
      return function(g, T) {
        var k = El(T).rgb(), U = El(g).rgb();
        return El.rgb(m(k, U));
      };
    }, Gr = function(m) {
      return function(g, T) {
        var k = [];
        return k[0] = m(g[0], T[0]), k[1] = m(g[1], T[1]), k[2] = m(g[2], T[2]), k;
      };
    }, H2 = function(m) {
      return m;
    }, j2 = function(m, g) {
      return m * g / 255;
    }, z2 = function(m, g) {
      return m > g ? g : m;
    }, V2 = function(m, g) {
      return m > g ? m : g;
    }, G2 = function(m, g) {
      return 255 * (1 - (1 - m / 255) * (1 - g / 255));
    }, Y2 = function(m, g) {
      return g < 128 ? 2 * m * g / 255 : 255 * (1 - 2 * (1 - m / 255) * (1 - g / 255));
    }, W2 = function(m, g) {
      return 255 * (1 - (1 - g / 255) / (m / 255));
    }, q2 = function(m, g) {
      return m === 255 ? 255 : (m = 255 * (g / 255) / (1 - m / 255), m > 255 ? 255 : m);
    };
    rr.normal = Vr(Gr(H2)), rr.multiply = Vr(Gr(j2)), rr.screen = Vr(Gr(G2)), rr.overlay = Vr(Gr(Y2)), rr.darken = Vr(Gr(z2)), rr.lighten = Vr(Gr(V2)), rr.dodge = Vr(Gr(q2)), rr.burn = Vr(Gr(W2));
    for (var K2 = rr, vl = E.type, X2 = E.clip_rgb, Z2 = E.TWOPI, Q2 = Math.pow, J2 = Math.sin, eS = Math.cos, tm = V, tS = function(m, g, T, k, U) {
      m === void 0 && (m = 300), g === void 0 && (g = -1.5), T === void 0 && (T = 1), k === void 0 && (k = 1), U === void 0 && (U = [0, 1]);
      var z = 0, B;
      vl(U) === "array" ? B = U[1] - U[0] : (B = 0, U = [U, U]);
      var q = function(X) {
        var ie = Z2 * ((m + 120) / 360 + g * X), ue = Q2(U[0] + B * X, k), Te = z !== 0 ? T[0] + X * z : T, fe = Te * ue * (1 - ue) / 2, Oe = eS(ie), Se = J2(ie), Ke = ue + fe * (-0.14861 * Oe + 1.78277 * Se), tt = ue + fe * (-0.29227 * Oe - 0.90649 * Se), ct = ue + fe * (1.97294 * Oe);
        return tm(X2([Ke * 255, tt * 255, ct * 255, 1]));
      };
      return q.start = function(X) {
        return X == null ? m : (m = X, q);
      }, q.rotations = function(X) {
        return X == null ? g : (g = X, q);
      }, q.gamma = function(X) {
        return X == null ? k : (k = X, q);
      }, q.hue = function(X) {
        return X == null ? T : (T = X, vl(T) === "array" ? (z = T[1] - T[0], z === 0 && (T = T[1])) : z = 0, q);
      }, q.lightness = function(X) {
        return X == null ? U : (vl(X) === "array" ? (U = X, B = X[1] - X[0]) : (U = [X, X], B = 0), q);
      }, q.scale = function() {
        return tm.scale(q);
      }, q.hue(T), q;
    }, nS = _, rS = "0123456789abcdef", aS = Math.floor, iS = Math.random, sS = function() {
      for (var m = "#", g = 0; g < 6; g++)
        m += rS.charAt(aS(iS() * 16));
      return new nS(m, "hex");
    }, Tl = l, nm = Math.log, oS = Math.pow, uS = Math.floor, lS = Math.abs, rm = function(m, g) {
      g === void 0 && (g = null);
      var T = {
        min: Number.MAX_VALUE,
        max: Number.MAX_VALUE * -1,
        sum: 0,
        values: [],
        count: 0
      };
      return Tl(m) === "object" && (m = Object.values(m)), m.forEach(function(k) {
        g && Tl(k) === "object" && (k = k[g]), k != null && !isNaN(k) && (T.values.push(k), T.sum += k, k < T.min && (T.min = k), k > T.max && (T.max = k), T.count += 1);
      }), T.domain = [T.min, T.max], T.limits = function(k, U) {
        return am(T, k, U);
      }, T;
    }, am = function(m, g, T) {
      g === void 0 && (g = "equal"), T === void 0 && (T = 7), Tl(m) == "array" && (m = rm(m));
      var k = m.min, U = m.max, z = m.values.sort(function(_l, yl) {
        return _l - yl;
      });
      if (T === 1)
        return [k, U];
      var B = [];
      if (g.substr(0, 1) === "c" && (B.push(k), B.push(U)), g.substr(0, 1) === "e") {
        B.push(k);
        for (var q = 1; q < T; q++)
          B.push(k + q / T * (U - k));
        B.push(U);
      } else if (g.substr(0, 1) === "l") {
        if (k <= 0)
          throw new Error("Logarithmic scales are only possible for values > 0");
        var X = Math.LOG10E * nm(k), ie = Math.LOG10E * nm(U);
        B.push(k);
        for (var ue = 1; ue < T; ue++)
          B.push(oS(10, X + ue / T * (ie - X)));
        B.push(U);
      } else if (g.substr(0, 1) === "q") {
        B.push(k);
        for (var Te = 1; Te < T; Te++) {
          var fe = (z.length - 1) * Te / T, Oe = uS(fe);
          if (Oe === fe)
            B.push(z[Oe]);
          else {
            var Se = fe - Oe;
            B.push(z[Oe] * (1 - Se) + z[Oe + 1] * Se);
          }
        }
        B.push(U);
      } else if (g.substr(0, 1) === "k") {
        var Ke, tt = z.length, ct = new Array(tt), gt = new Array(T), rn = !0, Qt = 0, In = null;
        In = [], In.push(k);
        for (var st = 1; st < T; st++)
          In.push(k + st / T * (U - k));
        for (In.push(U); rn; ) {
          for (var de = 0; de < T; de++)
            gt[de] = 0;
          for (var Le = 0; Le < tt; Le++)
            for (var et = z[Le], Xe = Number.MAX_VALUE, an = void 0, It = 0; It < T; It++) {
              var ft = lS(In[It] - et);
              ft < Xe && (Xe = ft, an = It), gt[an]++, ct[Le] = an;
            }
          for (var Et = new Array(T), vt = 0; vt < T; vt++)
            Et[vt] = null;
          for (var At = 0; At < tt; At++)
            Ke = ct[At], Et[Ke] === null ? Et[Ke] = z[At] : Et[Ke] += z[At];
          for (var ar = 0; ar < T; ar++)
            Et[ar] *= 1 / gt[ar];
          rn = !1;
          for (var Yr = 0; Yr < T; Yr++)
            if (Et[Yr] !== In[Yr]) {
              rn = !0;
              break;
            }
          In = Et, Qt++, Qt > 200 && (rn = !1);
        }
        for (var Wr = {}, ti = 0; ti < T; ti++)
          Wr[ti] = [];
        for (var ni = 0; ni < tt; ni++)
          Ke = ct[ni], Wr[Ke].push(z[ni]);
        for (var Dr = [], pa = 0; pa < T; pa++)
          Dr.push(Wr[pa][0]), Dr.push(Wr[pa][Wr[pa].length - 1]);
        Dr = Dr.sort(function(_l, yl) {
          return _l - yl;
        }), B.push(Dr[0]);
        for (var ji = 1; ji < Dr.length; ji += 2) {
          var ga = Dr[ji];
          !isNaN(ga) && B.indexOf(ga) === -1 && B.push(ga);
        }
      }
      return B;
    }, im = { analyze: rm, limits: am }, sm = _, cS = function(m, g) {
      m = new sm(m), g = new sm(g);
      var T = m.luminance(), k = g.luminance();
      return T > k ? (T + 0.05) / (k + 0.05) : (k + 0.05) / (T + 0.05);
    }, om = _, wr = Math.sqrt, Yt = Math.pow, fS = Math.min, dS = Math.max, um = Math.atan2, lm = Math.abs, lo = Math.cos, cm = Math.sin, hS = Math.exp, fm = Math.PI, mS = function(m, g, T, k, U) {
      T === void 0 && (T = 1), k === void 0 && (k = 1), U === void 0 && (U = 1);
      var z = function(ga) {
        return 360 * ga / (2 * fm);
      }, B = function(ga) {
        return 2 * fm * ga / 360;
      };
      m = new om(m), g = new om(g);
      var q = Array.from(m.lab()), X = q[0], ie = q[1], ue = q[2], Te = Array.from(g.lab()), fe = Te[0], Oe = Te[1], Se = Te[2], Ke = (X + fe) / 2, tt = wr(Yt(ie, 2) + Yt(ue, 2)), ct = wr(Yt(Oe, 2) + Yt(Se, 2)), gt = (tt + ct) / 2, rn = 0.5 * (1 - wr(Yt(gt, 7) / (Yt(gt, 7) + Yt(25, 7)))), Qt = ie * (1 + rn), In = Oe * (1 + rn), st = wr(Yt(Qt, 2) + Yt(ue, 2)), de = wr(Yt(In, 2) + Yt(Se, 2)), Le = (st + de) / 2, et = z(um(ue, Qt)), Xe = z(um(Se, In)), an = et >= 0 ? et : et + 360, It = Xe >= 0 ? Xe : Xe + 360, ft = lm(an - It) > 180 ? (an + It + 360) / 2 : (an + It) / 2, Et = 1 - 0.17 * lo(B(ft - 30)) + 0.24 * lo(B(2 * ft)) + 0.32 * lo(B(3 * ft + 6)) - 0.2 * lo(B(4 * ft - 63)), vt = It - an;
      vt = lm(vt) <= 180 ? vt : It <= an ? vt + 360 : vt - 360, vt = 2 * wr(st * de) * cm(B(vt) / 2);
      var At = fe - X, ar = de - st, Yr = 1 + 0.015 * Yt(Ke - 50, 2) / wr(20 + Yt(Ke - 50, 2)), Wr = 1 + 0.045 * Le, ti = 1 + 0.015 * Le * Et, ni = 30 * hS(-Yt((ft - 275) / 25, 2)), Dr = 2 * wr(Yt(Le, 7) / (Yt(Le, 7) + Yt(25, 7))), pa = -Dr * cm(2 * B(ni)), ji = wr(Yt(At / (T * Yr), 2) + Yt(ar / (k * Wr), 2) + Yt(vt / (U * ti), 2) + pa * (ar / (k * Wr)) * (vt / (U * ti)));
      return dS(0, fS(100, ji));
    }, dm = _, pS = function(m, g, T) {
      T === void 0 && (T = "lab"), m = new dm(m), g = new dm(g);
      var k = m.get(T), U = g.get(T), z = 0;
      for (var B in k) {
        var q = (k[B] || 0) - (U[B] || 0);
        z += q * q;
      }
      return Math.sqrt(z);
    }, gS = _, bS = function() {
      for (var m = [], g = arguments.length; g--; )
        m[g] = arguments[g];
      try {
        return new (Function.prototype.bind.apply(gS, [null].concat(m)))(), !0;
      } catch {
        return !1;
      }
    }, hm = V, mm = bl, ES = {
      cool: function() {
        return mm([hm.hsl(180, 1, 0.9), hm.hsl(250, 0.7, 0.4)]);
      },
      hot: function() {
        return mm(["#000", "#f00", "#ff0", "#fff"]).mode("rgb");
      }
    }, co = {
      // sequential
      OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
      PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
      BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
      Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
      BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
      YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
      YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
      Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
      RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
      Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
      YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
      Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
      GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
      Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
      YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
      PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
      Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
      PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
      Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
      // diverging
      Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
      RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
      RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
      PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
      PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
      RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
      BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
      RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
      PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
      // qualitative
      Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
      Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
      Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
      Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
      Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
      Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
      Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
      Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
    }, Al = 0, pm = Object.keys(co); Al < pm.length; Al += 1) {
      var gm = pm[Al];
      co[gm.toLowerCase()] = co[gm];
    }
    var vS = co, Zt = V;
    Zt.average = D2, Zt.bezier = U2, Zt.blend = K2, Zt.cubehelix = tS, Zt.mix = Zt.interpolate = Yh, Zt.random = sS, Zt.scale = bl, Zt.analyze = im.analyze, Zt.contrast = cS, Zt.deltaE = mS, Zt.distance = pS, Zt.limits = im.limits, Zt.valid = bS, Zt.scales = ES, Zt.colors = xh, Zt.brewer = vS;
    var TS = Zt;
    return TS;
  });
})(B1);
var lC = B1.exports;
const ac = /* @__PURE__ */ Ft(lC), ic = "#3d82e2", Om = "#db1b42", F1 = {
  shadow1: "rgba(0,0,0,0.01)",
  shadow2: "rgba(0,0,0,0.02)",
  shadow3: "rgba(0,0,0,0.03)",
  shadow4: "rgba(0,0,0,0.04)",
  shadow6: "rgba(0,0,0,0.06)",
  shadow8: "rgba(0,0,0,0.08)",
  shadow12: "rgba(0,0,0,0.12)",
  shadow16: "rgba(0,0,0,0.16)",
  surfaceZ1Light: "0px 1px 3px 1px rgba(22, 26, 30, 0.01), 0px 4px 8px -6px rgba(22, 26, 30, 0.08), 0px 1px 5px -4px rgba(22, 26, 30, 0.08), 0px 0px 0px 1px rgba(22, 26, 30, 0.04), 0px 1px 0px 0px rgba(22, 26, 30, 0.02)"
}, U1 = (e) => ({
  primary: e,
  darkPrimary: ac(e).darken(0.25).hex(),
  fadedPrimary: ac(e).alpha(0.45).hex()
}), cC = {
  black: "rgba(0,0,0,0.9)",
  white: "#fff",
  lightGrey: "#f4f4f4",
  medGrey: "#dfdfdf",
  darkGrey: "#737376",
  blue: ic,
  warn: Om,
  darkWarn: ac(Om).darken(0.25).hex(),
  ...U1(ic),
  ...F1
}, fC = "'Open Sans', sans-serif", Im = {
  1: "13px",
  2: "15px",
  3: "18px"
}, xm = {
  1: 400,
  2: 600
}, Nm = {
  1: "20px",
  2: "22px",
  3: "24px"
}, dC = "voiceflow-chat", td = document.createElement("div");
td.id = dC;
document.body.appendChild(td);
td.attachShadow({ mode: "open" });
const H1 = 150, j1 = (e, t = H1) => e.map((n) => `${n} ${t}ms ease`).join(", "), hC = () => ({
  theme: {
    colors: cC,
    shadows: F1,
    space: {
      1: "4px",
      2: "6px",
      3: "12px",
      4: "16px",
      5: "20px",
      6: "24px"
    },
    sizes: {
      xxs: "16px",
      xs: "24px",
      sm: "36px",
      md: "42px",
      lg: "56px",
      xl: "60px",
      xxl: "72px"
    },
    fonts: {
      default: fC
    },
    fontSizes: Im,
    fontWeights: xm,
    lineHeights: Nm,
    radii: {
      1: "8px",
      2: "10px",
      round: "50%"
    }
  },
  media: {
    mobile: "(max-width: 768px)"
  },
  utils: {
    anim: (e) => ({
      animation: e.map((t) => `${t} ${H1}ms`).join(", ")
    }),
    trans: (e) => ({
      transition: j1(e)
    }),
    typo: ({ size: e = Im[2], weight: t = xm[1], height: n = Nm[1] }) => ({
      fontFamily: "$default",
      fontSize: e,
      fontWeight: t,
      lineHeight: n
    })
  }
}), mC = uC(hC(), !1), { styled: Ce, keyframes: hu, theme: Uz, createTheme: pC } = mC, gC = ({ color: e }) => pC({
  colors: e ? U1(e) : {}
}), bC = hu({
  "50%": { opacity: 1 }
}), z1 = hu({
  from: { opacity: 0 },
  to: { opacity: 1 }
}), EC = hu({
  from: { transform: "rotate(0deg)" },
  to: { transform: "rotate(360deg)" }
}), vC = (e) => hu({
  from: { transform: `translateY(${e}px)` },
  to: { transform: "translateY(0px)" }
}), nd = ({
  distance: e = 12,
  duration: t,
  delay: n
}) => ({
  opacity: 0,
  animation: [z1, vC(e)].map((r) => `${r} ${t}ms ease-out ${n}ms forwards`).join(", ")
}), V1 = {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, TC = Ot(yt.AVATAR), G1 = Ce(TC("div"), {
  flexShrink: 0,
  borderRadius: "$round",
  backgroundColor: "$lightGrey",
  backgroundPosition: "center",
  backgroundRepeat: "no-repeat",
  backgroundSize: "cover",
  variants: {
    size: {
      small: {
        height: 26,
        width: 26
      },
      large: {
        height: "$xxl",
        width: "$xxl",
        boxSizing: "border-box",
        boxShadow: "0 4px 16px 0 $shadow4, 0 0 0 1px $shadow2"
      }
    }
  },
  defaultVariants: {
    size: "small"
  }
}), AC = ({ avatar: e, ...t }) => /* @__PURE__ */ J.jsx(G1, { ...t, css: { backgroundImage: `url(${e})`, ...t.css } }), aa = Object.assign(AC, {
  Container: G1
}), rd = Ot(yt.ASSISTANT_INFO), ad = Ce(rd("h2", "title"), {
  ...V1,
  width: "100%",
  margin: 0,
  typo: { size: 20, weight: "$2", height: "$3" },
  color: "$black"
}), Y1 = Ce(rd("p", "description"), {
  display: "-webkit-box",
  margin: 0,
  typo: {},
  color: "$darkGrey",
  "-webkit-line-clamp": 2,
  "-webkit-box-orient": "vertical",
  overflow: "hidden",
  wordBreak: "break-word"
}), W1 = Ce(rd("div"), {
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  padding: "48px 32px",
  textAlign: "center",
  [`& ${aa.Container}`]: {
    marginBottom: "$4"
  },
  [`& ${ad}`]: {
    marginBottom: 8
  }
}), _C = ({ title: e, description: t, avatar: n }) => /* @__PURE__ */ J.jsxs(W1, { children: [
  /* @__PURE__ */ J.jsx(aa, { size: "large", avatar: n }),
  /* @__PURE__ */ J.jsx(ad, { children: e }),
  /* @__PURE__ */ J.jsx(Y1, { children: t })
] }), q1 = Object.assign(_C, {
  Container: W1,
  Title: ad,
  Description: Y1
}), yC = (e) => /* @__PURE__ */ Fe.createElement("svg", { viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ Fe.createElement("path", { id: "vf-close", d: "M13.748 3.32a.773.773 0 0 0-1.093-1.094l-4.389 4.39a.363.363 0 0 1-.514 0L3.368 2.23a.779.779 0 0 0-1.101 0l-.039.038a.779.779 0 0 0 0 1.101l4.385 4.385a.363.363 0 0 1 0 .514l-4.37 4.37a.773.773 0 1 0 1.092 1.093l4.37-4.37a.363.363 0 0 1 .514 0l4.413 4.412a.779.779 0 0 0 1.101 0l.039-.038a.779.779 0 0 0 0-1.101L9.359 8.222a.363.363 0 0 1 0-.514l4.389-4.389z", fill: "currentColor" })), SC = (e) => /* @__PURE__ */ Fe.createElement("svg", { width: 10, height: 10, viewBox: "0 0 10 10", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ Fe.createElement("path", { id: "vf-close-v2", d: "M9.74785 1.31915C10.0496 1.01737 10.0496 0.528102 9.74785 0.226329C9.44607 -0.0754433 8.9568 -0.0754431 8.65503 0.22633L5.26629 3.61507C5.12438 3.75698 4.8943 3.75698 4.75239 3.61507L1.36785 0.230531C1.06376 -0.0735626 0.570729 -0.0735623 0.266636 0.230531L0.22807 0.269097C-0.0760235 0.57319 -0.0760232 1.06622 0.22807 1.37032L3.61261 4.75485C3.75452 4.89676 3.75452 5.12684 3.61261 5.26875L0.242553 8.63881C-0.0592196 8.94058 -0.0592194 9.42985 0.242554 9.73162C0.544326 10.0334 1.0336 10.0334 1.33537 9.73162L4.70542 6.36157C4.84733 6.21966 5.07741 6.21966 5.21932 6.36157L8.63214 9.77439C8.93624 10.0785 9.42927 10.0785 9.73336 9.77439L9.77193 9.73582C10.076 9.43173 10.076 8.9387 9.77193 8.63461L6.35911 5.22179C6.2172 5.07987 6.2172 4.84979 6.35911 4.70788L9.74785 1.31915Z", fill: "currentColor" })), CC = (e) => /* @__PURE__ */ Fe.createElement("svg", { viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ Fe.createElement("g", { fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ Fe.createElement("path", { fill: "currentColor", d: "M14.25 7.281a.75.75 0 0 1 0 1.5H3.38l2.474 2.77a.75.75 0 1 1-1.152.96l-3.5-4a.75.75 0 0 1 0-.96l3.5-4a.75.75 0 0 1 1.152.96L3.38 7.282H14.25z" }))), OC = (e) => /* @__PURE__ */ Fe.createElement("svg", { viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ Fe.createElement("g", { id: "vf-minus", fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ Fe.createElement("path", { d: "M15 8a.84.84 0 0 1-.84.84H1.84a.84.84 0 0 1 0-1.68h12.32A.84.84 0 0 1 15 8z", fill: "currentColor" }))), IC = (e) => /* @__PURE__ */ Fe.createElement("svg", { viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ Fe.createElement("defs", null, /* @__PURE__ */ Fe.createElement("linearGradient", { x1: "50%", y1: "0%", x2: "50%", y2: "100%", id: "linearGradient-1" }, /* @__PURE__ */ Fe.createElement("stop", { stopColor: "currentColor", stopOpacity: 0.85, offset: "0%" }), /* @__PURE__ */ Fe.createElement("stop", { stopColor: "currentColor", offset: "100%" })), /* @__PURE__ */ Fe.createElement("path", { d: "M8.50003057,3.75 C8.50003057,3.335786 8.16424057,3 7.75003057,3 C7.33582057,3 7.00003057,3.335786 7.00003057,3.75 L7.00003057,10.64873 L5.23016057,9.17384 C4.91194957,8.90866 4.43902557,8.95166 4.17385257,9.26987 C3.90867987,9.58807 3.95167287,10.061 4.26988057,10.32617 L7.26988057,12.82617 C7.54801057,13.0579 7.95202057,13.0579 8.23016057,12.82617 L11.2301606,10.32617 C11.5483606,10.061 11.5913606,9.58807 11.3261806,9.26987 C11.0610106,8.95166 10.5880906,8.90866 10.2698806,9.17384 L8.50003057,10.64871 L8.50003057,3.75 Z", id: "path-2" })), /* @__PURE__ */ Fe.createElement("g", { id: "vf-arrow-up", stroke: "none", strokeWidth: 1, fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ Fe.createElement("g", { id: "Path", transform: "translate(7.750018, 7.999984) rotate(180.000000) translate(-7.750018, -7.999984) " }, /* @__PURE__ */ Fe.createElement("use", { fill: "currentColor", xlinkHref: "#path-2" }), /* @__PURE__ */ Fe.createElement("use", { fillOpacity: 0.85, fill: "url(#linearGradient-1)", xlinkHref: "#path-2" })))), sc = (e) => /* @__PURE__ */ Fe.createElement("svg", { width: 24, height: 25, viewBox: "0 0 24 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ Fe.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.29398 20.4966C4.56534 20.4966 4 19.8827 4 19.1539V12.3847C4 11.6559 4.56534 11.042 5.29398 11.042H8.12364L10.8534 4.92738C10.9558 4.69809 11.1677 4.54023 11.4114 4.50434L11.5175 4.49658C12.3273 4.49658 13.0978 4.85402 13.6571 5.48039C14.2015 6.09009 14.5034 6.90649 14.5034 7.7535L14.5027 8.92295L18.1434 8.92346C18.6445 8.92346 19.1173 9.13931 19.4618 9.51188L19.5612 9.62829C19.8955 10.0523 20.0479 10.6054 19.9868 11.1531L19.1398 18.742C19.0297 19.7286 18.2529 20.4966 17.2964 20.4966H8.69422H5.29398ZM11.9545 6.02658L9.41727 11.7111L9.42149 11.7693L9.42091 19.042H17.2964C17.4587 19.042 17.6222 18.8982 17.6784 18.6701L17.6942 18.5807L18.5412 10.9918C18.5604 10.8194 18.5134 10.6486 18.4189 10.5287C18.3398 10.4284 18.2401 10.378 18.1434 10.378H13.7761C13.3745 10.378 13.0488 10.0524 13.0488 9.65073V7.7535C13.0488 7.2587 12.8749 6.78825 12.5721 6.44915C12.4281 6.28794 12.2615 6.16343 12.0824 6.07923L11.9545 6.02658ZM7.96636 12.4966H5.45455V19.042H7.96636V12.4966Z", fill: "white" }), /* @__PURE__ */ Fe.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.29398 20.4966C4.56534 20.4966 4 19.8827 4 19.1539V12.3847C4 11.6559 4.56534 11.042 5.29398 11.042H8.12364L10.8534 4.92738C10.9558 4.69809 11.1677 4.54023 11.4114 4.50434L11.5175 4.49658C12.3273 4.49658 13.0978 4.85402 13.6571 5.48039C14.2015 6.09009 14.5034 6.90649 14.5034 7.7535L14.5027 8.92295L18.1434 8.92346C18.6445 8.92346 19.1173 9.13931 19.4618 9.51188L19.5612 9.62829C19.8955 10.0523 20.0479 10.6054 19.9868 11.1531L19.1398 18.742C19.0297 19.7286 18.2529 20.4966 17.2964 20.4966H8.69422H5.29398ZM11.9545 6.02658L9.41727 11.7111L9.42149 11.7693L9.42091 19.042H17.2964C17.4587 19.042 17.6222 18.8982 17.6784 18.6701L17.6942 18.5807L18.5412 10.9918C18.5604 10.8194 18.5134 10.6486 18.4189 10.5287C18.3398 10.4284 18.2401 10.378 18.1434 10.378H13.7761C13.3745 10.378 13.0488 10.0524 13.0488 9.65073V7.7535C13.0488 7.2587 12.8749 6.78825 12.5721 6.44915C12.4281 6.28794 12.2615 6.16343 12.0824 6.07923L11.9545 6.02658ZM7.96636 12.4966H5.45455V19.042H7.96636V12.4966Z", fill: "currentColor" })), K1 = (e) => /* @__PURE__ */ Fe.createElement("svg", { width: "16px", height: "8px", viewBox: "0 0 16.0 8.0", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ Fe.createElement("defs", null, /* @__PURE__ */ Fe.createElement("clipPath", { id: "i0" }, /* @__PURE__ */ Fe.createElement("path", { d: "M9.3912777,0.590799928 L11.8266759,3.22760605 C12.8648163,4.35160464 14.3915663,5 16,5 L0,5 C0.0295978076,5 0.0591679461,4.99978044 0.0887078805,4.99934241 C1.66434944,4.97597796 3.15405745,4.33102228 4.17311097,3.22783933 L6.60912844,0.590718281 C7.33672461,-0.196938863 8.66373617,-0.196900538 9.3912777,0.590799928 Z" })), /* @__PURE__ */ Fe.createElement("clipPath", { id: "i1" }, /* @__PURE__ */ Fe.createElement("path", { d: "M17,-1.99999948 L17,7 L-1,7 L-1,-1.99999948 L17,-1.99999948 Z M9.3912777,0.590799928 C8.66373617,-0.196900538 7.33672461,-0.196938863 6.60912844,0.590718281 L4.17311097,3.22783933 C3.15405745,4.33102228 1.66434944,4.97597796 0.0887078805,4.99934241 C0.0591679461,4.99978044 0.0295978076,5 0,5 L16,5 C14.3915663,5 12.8648163,4.35160464 11.8266759,3.22760605 Z" })), /* @__PURE__ */ Fe.createElement("clipPath", { id: "i2" }, /* @__PURE__ */ Fe.createElement("path", { d: "M16,0 L16,2 L0,2 L0,0 L16,0 Z" }))), /* @__PURE__ */ Fe.createElement("g", { transform: "translate(-239.0 1.0)" }, /* @__PURE__ */ Fe.createElement("g", { transform: "translate(239.0 0.0)" }, /* @__PURE__ */ Fe.createElement("g", { clipPath: "url(#i0)" }, /* @__PURE__ */ Fe.createElement("polygon", { points: "0,1.11022302e-16 16,1.11022302e-16 16,5 0,5 0,1.11022302e-16", stroke: "none", fill: "#FFFFFF" })), /* @__PURE__ */ Fe.createElement("g", { clipPath: "url(#i1)" }, /* @__PURE__ */ Fe.createElement("path", { d: "M16,5 L0,5 C0.0295978076,5 0.0591679461,4.99978044 0.0887078805,4.99934241 C1.66434944,4.97597796 3.15405745,4.33102228 4.17311097,3.22783933 L6.60912844,0.590718281 C7.33672461,-0.196938863 8.66373617,-0.196900538 9.3912777,0.590799928 L11.8266759,3.22760605 C12.8648163,4.35160464 14.3915663,5 16,5 Z", stroke: "#DFDFDF", strokeWidth: 2, fill: "none", strokeMiterlimit: 5 })), /* @__PURE__ */ Fe.createElement("g", { transform: "translate(0.0 5.0)" }, /* @__PURE__ */ Fe.createElement("g", { clipPath: "url(#i2)" }, /* @__PURE__ */ Fe.createElement("polygon", { points: "0,0 16,0 16,2 0,2 0,0", stroke: "none", fill: "#FFFFFF" })))))), xC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  close: yC,
  closeV2: SC,
  largeArrowLeft: CC,
  minus: OC,
  smallArrowUp: IC,
  thumbsUp: sc,
  topCaret: K1
}, Symbol.toStringTag, { value: "Module" })), NC = Ot(yt.ICON), X1 = Ce(NC("div"), { display: "flex" }), RC = ({ svg: e, ...t }) => {
  const n = typeof e == "string" ? xC[e] : e;
  return /* @__PURE__ */ J.jsx(X1, { ...t, children: /* @__PURE__ */ J.jsx(n, {}) });
}, Rn = Object.assign(RC, {
  Frame: X1
}), Z1 = (e, t) => Tn.forwardRef(
  ({ variant: n = t, ...r }, a) => {
    const i = e[n];
    return i ? /* @__PURE__ */ J.jsx(i, { ...r, ref: a }) : null;
  }
);
var xa = /* @__PURE__ */ ((e) => (e.PRIMARY = "primary", e.SECONDARY = "secondary", e))(xa || {});
const id = Ot(yt.BUTTON), Q1 = Ce("button", {
  border: 0,
  padding: 0,
  "&:focus": {
    outline: 0
  },
  "&:hover": {
    cursor: "pointer"
  }
}), sd = Ce(id(Q1), {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  padding: "0 14px",
  borderRadius: "$1",
  typo: { weight: "$2" },
  whiteSpace: "nowrap",
  overflowWrap: "anywhere"
}), J1 = Ce(id(sd, xa.PRIMARY), {
  minHeight: "$md",
  color: "$white",
  trans: ["background-color"],
  padding: "10px 14px",
  boxSizing: "border-box",
  whiteSpace: "break-spaces",
  variants: {
    type: {
      info: {
        backgroundColor: "$primary",
        "&:hover": {
          backgroundColor: "$darkPrimary"
        }
      },
      warn: {
        backgroundColor: "$warn",
        "&:hover": {
          backgroundColor: "$darkWarn"
        }
      },
      subtle: {
        color: "$black",
        backgroundColor: "inherit",
        trans: ["color"],
        "&:hover": {
          color: "#000"
        }
      }
    }
  },
  defaultVariants: {
    type: "info"
  }
}), eb = Ce(id(sd, xa.SECONDARY), {
  height: "$sm",
  border: "1px solid $fadedPrimary",
  color: "$primary",
  backgroundColor: "$white",
  boxShadow: "0 1px 2px $shadow2",
  trans: ["border-color"],
  "&:hover": {
    borderColor: "$primary"
  }
}), kC = {
  [xa.PRIMARY]: J1,
  [xa.SECONDARY]: eb
}, wC = Z1(kC, xa.PRIMARY), Zn = Object.assign(wC, {
  Variant: xa,
  Reset: Q1,
  Container: sd,
  Primary: J1,
  Secondary: eb
}), DC = Ot(yt.BUBBLE), tb = Ce(DC(Zn.Reset), {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "$round",
  backgroundColor: "$primary",
  trans: ["background-color", "box-shadow"],
  "&:hover": {
    backgroundColor: "$darkPrimary"
  },
  variants: {
    size: {
      small: {
        height: "$xs",
        width: "$xs",
        [`& ${Rn.Frame}`]: {
          width: "$xxs",
          height: "$xxs"
        }
      },
      large: {
        height: "$xl",
        width: "$xl",
        border: "1px solid $shadow4",
        boxShadow: "0 1px 6px $shadow6, 0 2px 24px $shadow8",
        [`& ${Rn.Frame}`]: {
          width: "$sm",
          height: "$sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "large"
  }
}), PC = ({ svg: e, color: t, ...n }) => /* @__PURE__ */ J.jsx(tb, { ...n, children: /* @__PURE__ */ J.jsx(Rn, { svg: e, css: { color: t, ...n.css } }) }), oc = Object.assign(PC, {
  Container: tb
}), LC = Ot(yt.IMAGE), nb = Ce(LC("img"), {
  variants: {
    isRounded: {
      true: {
        borderRadius: "$1"
      }
    },
    mode: {
      overlay: {
        width: 248
      },
      embedded: {
        width: "100%",
        maxWidth: 512
      }
    }
  },
  defaultVariants: {
    isRounded: !0,
    mode: "overlay"
  }
}), MC = ({ image: e, ...t }) => /* @__PURE__ */ J.jsx(nb, { ...t, src: e || void 0 }), rb = Object.assign(MC, { Base: nb }), od = Qf({
  scrollToBottom: () => {
  }
}), { Consumer: Hz } = od, $C = ({ target: e, children: t }) => {
  const n = ra(() => {
    requestAnimationFrame(() => {
      const a = e.current;
      if (!a)
        return;
      const { scrollTop: i, scrollHeight: s, clientHeight: o } = a, u = s - o;
      u !== i && a.scrollTo({ top: u });
    });
  }, []), r = ua(() => ({ scrollToBottom: n }), [n]);
  return /* @__PURE__ */ J.jsx(od.Provider, { value: r, children: t });
};
var uc;
(function(e) {
  e.INTENT = "INTENT";
})(uc || (uc = {}));
var lc;
(function(e) {
  e.STACKED = "stacked", e.CAROUSEL = "carousel";
})(lc || (lc = {}));
const Rm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ButtonType() {
    return uc;
  },
  get ButtonsLayout() {
    return lc;
  }
}, Symbol.toStringTag, { value: "Module" })), ab = "VF.";
var hs;
(function(e) {
  e.Workspace = "WS", e.DialogManager = "DM";
})(hs || (hs = {}));
const ib = (e) => (t) => typeof t == "string" && t.startsWith(`${ab}${e}.`), BC = ib(hs.Workspace), FC = ib(hs.DialogManager), UC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get APIKeySubType() {
    return hs;
  },
  API_KEY_PREFIX: ab,
  isDialogManagerAPIKey: FC,
  isWorkspaceAPIKey: BC
}, Symbol.toStringTag, { value: "Module" }));
var cc;
(function(e) {
  e.LUIS = "LUIS", e.VFNLU = "VFNLU";
})(cc || (cc = {}));
var ko;
(function(e) {
  e.CURVED = "CURVED", e.STRAIGHT = "STRAIGHT";
})(ko || (ko = {}));
var fc;
(function(e) {
  e.BLOCK = "block", e.ACTIONS = "actions";
})(fc || (fc = {}));
var dc;
(function(e) {
  e.INTENT = "INTENT";
})(dc || (dc = {}));
var hc;
(function(e) {
  e.FAIL = "fail", e.NEXT = "next", e.PAUSE = "pause", e.NO_REPLY = "no-reply", e.NO_MATCH = "else", e.PREVIOUS = "previous";
})(hc || (hc = {}));
var mc;
(function(e) {
  e.TOPIC = "TOPIC", e.GROUP = "GROUP", e.COMPONENT = "COMPONENT", e.TEMPLATE = "TEMPLATE";
})(mc || (mc = {}));
var pc;
(function(e) {
  e.NODE = "NODE", e.DIAGRAM = "DIAGRAM";
})(pc || (pc = {}));
const HC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get DiagramType() {
    return mc;
  },
  get MenuItemType() {
    return pc;
  }
}, Symbol.toStringTag, { value: "Module" })), jC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var gc;
(function(e) {
  e.PDF = "pdf", e.TEXT = "text", e.URL = "url", e.DOCX = "docx";
})(gc || (gc = {}));
var bc;
(function(e) {
  e.ERROR = "ERROR", e.SUCCESS = "SUCCESS", e.PENDING = "PENDING", e.INITIALIZED = "INITIALIZED";
})(bc || (bc = {}));
var Ec;
(function(e) {
  e.RECURSIVE_TEXT_SPLITTER = "recursive_text_splitter";
})(Ec || (Ec = {}));
var vc;
(function(e) {
  e.PUBLIC = "public", e.PRIVATE = "private";
})(vc || (vc = {}));
const zC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ChunkStrategyType() {
    return Ec;
  },
  get KnowledgeBaseDocumentStatus() {
    return bc;
  },
  get KnowledgeBaseDocumentType() {
    return gc;
  },
  get LinkType() {
    return ko;
  },
  get Privacy() {
    return vc;
  }
}, Symbol.toStringTag, { value: "Module" })), VC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), GC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), YC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Tc;
(function(e) {
  e.DESIGN = "DESIGN", e.REVIEW = "REVIEW", e.COMPLETE = "COMPLETE";
})(Tc || (Tc = {}));
var Ac;
(function(e) {
  e.CONVERSATION = "conversation", e.PROTOTYPE = "prototype", e.NLU_DATASOURCE_IMPORT = "nluDatasourceImport";
})(Ac || (Ac = {}));
var _c;
(function(e) {
  e.FOLDER = "FOLDER", e.DIAGRAM = "DIAGRAM";
})(_c || (_c = {}));
const WC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get DomainStatus() {
    return Tc;
  },
  get FolderItemType() {
    return _c;
  },
  get NLUUnclassifiedDataType() {
    return Ac;
  }
}, Symbol.toStringTag, { value: "Module" })), km = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ApiKey: UC,
  get BaseNodeType() {
    return fc;
  },
  Diagram: HC,
  get LinkType() {
    return ko;
  },
  get NoteType() {
    return dc;
  },
  get PortType() {
    return hc;
  },
  Program: jC,
  Project: zC,
  get ProjectNLP() {
    return cc;
  },
  ProjectSecret: VC,
  Transcript: GC,
  VariableState: YC,
  Version: WC
}, Symbol.toStringTag, { value: "Module" })), qC = "stopTypes", KC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _V1_STOP_TYPES: qC
}, Symbol.toStringTag, { value: "Module" })), XC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), ZC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var yc;
(function(e) {
  e.FORM_DATA = "formData", e.RAW_INPUT = "rawInput", e.URL_ENCODED = "urlEncoded";
})(yc || (yc = {}));
var Sc;
(function(e) {
  e.GET = "GET", e.PUT = "PUT", e.POST = "POST", e.PATCH = "PATCH", e.DELETE = "DELETE";
})(Sc || (Sc = {}));
const QC = (e) => e.toLowerCase();
var Cc;
(function(e) {
  e.GET = "Make a GET Request", e.PUT = "Make a PUT Request", e.POST = "Make a POST Request", e.PATCH = "Make a PATCH Request", e.DELETE = "Make a DELETE Request";
})(Cc || (Cc = {}));
const JC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get APIActionType() {
    return Cc;
  },
  get APIBodyType() {
    return yc;
  },
  get APIMethod() {
    return Sc;
  },
  lowercaseAPIMethod: QC
}, Symbol.toStringTag, { value: "Module" }));
var Oc;
(function(e) {
  e.URL = "URL", e.PATH = "PATH", e.INTENT = "INTENT";
})(Oc || (Oc = {}));
const eO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ButtonAction() {
    return Oc;
  }
}, Symbol.toStringTag, { value: "Module" })), tO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Ic;
(function(e) {
  e.INTENT = "intent", e.QUERY = "query";
})(Ic || (Ic = {}));
const nO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get CaptureType() {
    return Ic;
  }
}, Symbol.toStringTag, { value: "Module" }));
var xc;
(function(e) {
  e.SIMPLE = "Simple", e.STANDARD = "Standard";
})(xc || (xc = {}));
const rO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get CardType() {
    return xc;
  }
}, Symbol.toStringTag, { value: "Module" })), aO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Nc;
(function(e) {
  e.CAROUSEL = "Carousel", e.LIST = "List";
})(Nc || (Nc = {}));
const iO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get CarouselLayout() {
    return Nc;
  }
}, Symbol.toStringTag, { value: "Module" })), sO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), oO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), uO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var re;
(function(e) {
  e.TEXT = "text", e.SPEAK = "speak", e.START = "start", e.CARD = "card", e.CARD_V2 = "cardV2", e.CAROUSEL = "carousel", e.BUTTONS = "buttons", e.INTERACTION = "interaction", e.AI_RESPONSE = "generative", e.AI_SET = "ai_set", e.SET = "set", e.SET_V2 = "setV2", e.IF = "if", e.IF_V2 = "ifV2", e.RANDOM = "random", e.RANDOM_V2 = "randomV2", e.CAPTURE = "capture", e.CAPTURE_V2 = "captureV2", e.GOTO = "goTo", e.GOTO_NODE = "goToNode", e.GOTO_DOMAIN = "goToDomain", e.API = "api", e.ZAPIER = "zapier", e.INTEGRATIONS = "integrations", e.GOOGLE_SHEETS = "google_sheets", e.INTENT = "intent", e.FLOW = "flow", e.COMPONENT = "component", e.CODE = "code", e.EXIT = "exit", e.PROMPT = "prompt", e.COMMAND = "command", e.TRACE = "trace", e.CHANNEL_ACTION = "channel_action", e.CUSTOM_BLOCK_POINTER = "custom_block_pointer", e.URL = "url", e.STREAM = "stream", e.VISUAL = "visual", e.GENERAL = "general", e.DIRECTIVE = "directive", e.DEPRECATED = "deprecated";
})(re || (re = {}));
const sb = [re.GOTO], lO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), cO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), fO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), dO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), hO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Rc;
(function(e) {
  e.CREATE_DATA = "Create Data", e.UPDATE_DATA = "Update Data", e.DELETE_DATA = "Delete Data", e.RETRIEVE_DATA = "Retrieve Data";
})(Rc || (Rc = {}));
const mO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get GoogleSheetsActionType() {
    return Rc;
  }
}, Symbol.toStringTag, { value: "Module" })), pO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), gO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), bO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), EO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var kc;
(function(e) {
  e.PATH = "path", e.NONE = "none";
})(kc || (kc = {}));
const vO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get IfNoMatchType() {
    return kc;
  }
}, Symbol.toStringTag, { value: "Module" })), TO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var wc;
(function(e) {
  e.PATH = "PATH", e.GO_TO = "GO_TO";
})(wc || (wc = {}));
const AO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ChoiceAction() {
    return wc;
  }
}, Symbol.toStringTag, { value: "Module" }));
var Dc;
(function(e) {
  e.LOCAL = "LOCAL", e.GLOBAL = "GLOBAL";
})(Dc || (Dc = {}));
const _O = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get IntentAvailability() {
    return Dc;
  }
}, Symbol.toStringTag, { value: "Module" })), yO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), SO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Pc;
(function(e) {
  e[e.DEFAULT = 1] = "DEFAULT", e[e.DO_DUPLICATES = 2] = "DO_DUPLICATES";
})(Pc || (Pc = {}));
const CO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get RandomType() {
    return Pc;
  }
}, Symbol.toStringTag, { value: "Module" }));
var Lc;
(function(e) {
  e[e.DEFAULT = 1] = "DEFAULT", e[e.DO_DUPLICATES = 2] = "DO_DUPLICATES";
})(Lc || (Lc = {}));
const OO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get RandomType() {
    return Lc;
  }
}, Symbol.toStringTag, { value: "Module" })), IO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), xO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Mc;
(function(e) {
  e.AUDIO = "audio", e.MESSAGE = "message";
})(Mc || (Mc = {}));
const NO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TraceSpeakType() {
    return Mc;
  }
}, Symbol.toStringTag, { value: "Module" })), RO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var $c;
(function(e) {
  e.LOOP = "LOOP", e.PLAY = "PLAY", e.PAUSE = "PAUSE", e.END = "END";
})($c || ($c = {}));
const kO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TraceStreamAction() {
    return $c;
  }
}, Symbol.toStringTag, { value: "Module" })), wO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), DO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Bc;
(function(e) {
  e.PREVIEW = "preview", e.ALL_VARIANTS = "all-variants";
})(Bc || (Bc = {}));
var Fc;
(function(e) {
  e.JUMP = "jump", e.PUSH = "push";
})(Fc || (Fc = {}));
var ms;
(function(e) {
  e.INTENT = "intent", e.ALEXA = "alexa";
})(ms || (ms = {}));
const PO = (e) => e.type === ms.INTENT, LO = Object.values(ms), MO = (e) => !LO.includes(e.type);
var Uc;
(function(e) {
  e.EQUALS = "equals", e.GREATER = "greater", e.LESS = "less", e.AND = "and", e.OR = "or", e.VALUE = "value", e.VARIABLE = "variable", e.ADVANCE = "advance", e.PLUS = "plus", e.MINUS = "minus", e.TIMES = "times", e.DIVIDE = "divide", e.NOT = "not";
})(Uc || (Uc = {}));
var Hc;
(function(e) {
  e.EQUALS = "equals", e.GREATER = "greater", e.LESS = "less", e.AND = "and", e.OR = "or", e.VALUE = "value", e.VARIABLE = "variable", e.ADVANCE = "advance", e.NOT_EQUAL = "not_equal", e.GREATER_OR_EQUAL = "greater_or_equal", e.LESS_OR_EQUAL = "less_or_equal", e.CONTAINS = "contains", e.NOT_CONTAIN = "not_contain", e.STARTS_WITH = "starts_with", e.ENDS_WITH = "ends_with", e.HAS_VALUE = "has_value", e.IS_EMPTY = "is_empty";
})(Hc || (Hc = {}));
var jc;
(function(e) {
  e.VARIABLE = "variable", e.VALUE = "value", e.LOGIC_GROUP = "logic_group", e.EXPRESSION = "expression";
})(jc || (jc = {}));
var zc;
(function(e) {
  e.ZAPIER = "Zapier", e.CUSTOM_API = "Custom API", e.GOOGLE_SHEETS = "Google Sheets";
})(zc || (zc = {}));
var Vc;
(function(e) {
  e.ZAPIER = "Zapier", e.GOOGLE_SHEETS = "Google Sheets";
})(Vc || (Vc = {}));
var Gc;
(function(e) {
  e.NODE = "NODE", e.GLOBAL = "GLOBAL";
})(Gc || (Gc = {}));
var Yc;
(function(e) {
  e.PATH = "path", e.REPROMPT = "reprompt", e.BOTH = "both";
})(Yc || (Yc = {}));
var Wc;
(function(e) {
  e.PATH = "path", e.REPROMPT = "reprompt";
})(Wc || (Wc = {}));
var ps;
(function(e) {
  e.LOG = "log", e.END = "end", e.TEXT = "text", e.PATH = "path", e.FLOW = "flow", e.GOTO = "goto", e.SPEAK = "speak", e.BLOCK = "block", e.DEBUG = "debug", e.CHOICE = "choice", e.STREAM = "stream", e.VISUAL = "visual", e.CARD_V2 = "cardV2", e.CAROUSEL = "carousel", e.NO_REPLY = "no-reply", e.ENTITY_FILLING = "entity-filling", e.CHANNEL_ACTION = "channel-action", e.KNOWLEDGE_BASE = "knowledgeBase";
})(ps || (ps = {}));
const $O = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get CanvasNodeVisibility() {
    return Bc;
  },
  get CommandType() {
    return Fc;
  },
  get ConditionsLogicInterface() {
    return jc;
  },
  get EventType() {
    return ms;
  },
  get ExpressionType() {
    return Uc;
  },
  get ExpressionTypeV2() {
    return Hc;
  },
  get IntegrationPlatform() {
    return Vc;
  },
  get IntegrationType() {
    return zc;
  },
  get IntentScope() {
    return Gc;
  },
  get NoMatchType() {
    return Yc;
  },
  get NoReplyType() {
    return Wc;
  },
  get TraceType() {
    return ps;
  },
  isGeneralEvent: MO,
  isIntentEvent: PO
}, Symbol.toStringTag, { value: "Module" }));
var qc;
(function(e) {
  e.MOBILE = "mobile", e.TABLET = "tablet", e.DESKTOP = "desktop", e.SMART_WATCH = "smart_watch", e.TELEVISION = "television", e.IN_CAR_DISPLAY = "in_car_display", e.ECHO_SPOT = "echo_spot", e.ECHO_SHOW_8 = "echo_show_8", e.ECHO_SHOW_10 = "echo_show_10", e.FIRE_HD_8 = "fire_hd_8", e.FIRE_HD_10 = "fire_hd_10", e.FIRE_TV_CUBE = "fire_tv_cube", e.GOOGLE_NEST_HUB = "google_nest_hub";
})(qc || (qc = {}));
var Kc;
(function(e) {
  e.FULL = "full", e.HIDDEN = "hidden", e.CROPPED = "cropped";
})(Kc || (Kc = {}));
var Xc;
(function(e) {
  e.JSON = "JSON", e.SPLASH = "SPLASH";
})(Xc || (Xc = {}));
var Zc;
(function(e) {
  e.APL = "apl", e.IMAGE = "image";
})(Zc || (Zc = {}));
var Qc;
(function(e) {
  e.AUTO = "AUTO", e.DEVICE = "DEVICE", e.CUSTOM_SIZE = "CUSTOM_SIZE";
})(Qc || (Qc = {}));
const BO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get APLType() {
    return Xc;
  },
  get CanvasVisibility() {
    return Kc;
  },
  get DeviceType() {
    return qc;
  },
  get FrameType() {
    return Qc;
  },
  get VisualType() {
    return Zc;
  }
}, Symbol.toStringTag, { value: "Module" }));
var Jc;
(function(e) {
  e.START_A_ZAP = "Start a Zap";
})(Jc || (Jc = {}));
const FO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ZapierActionType() {
    return Jc;
  }
}, Symbol.toStringTag, { value: "Module" })), wm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AIResponse: XC,
  AISet: ZC,
  Api: JC,
  Buttons: eO,
  Capture: tO,
  CaptureV2: nO,
  Card: rO,
  CardV2: aO,
  Carousel: iO,
  ChannelAction: sO,
  Code: oO,
  Command: SO,
  Component: uO,
  CustomBlockPointer: lO,
  Directive: cO,
  Exit: fO,
  Flow: dO,
  General: hO,
  GoTo: pO,
  GoToDomain: gO,
  GoToNode: bO,
  GoogleSheets: mO,
  If: EO,
  IfV2: vO,
  Integration: TO,
  Intent: _O,
  Interaction: AO,
  get NodeType() {
    return re;
  },
  Prompt: yO,
  RUNTIME_ONLY_NODES: sb,
  Random: CO,
  RandomV2: OO,
  Set: IO,
  SetV2: xO,
  Speak: NO,
  Start: RO,
  Stream: kO,
  Text: wO,
  Url: DO,
  Utils: $O,
  Visual: BO,
  Zapier: FO,
  _v1: KC
}, Symbol.toStringTag, { value: "Module" })), ob = (e = {}) => Object.assign({}, e), Dm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultPlatformData: ob
}, Symbol.toStringTag, { value: "Module" }));
var wo;
(function(e) {
  e.OPEN_URL = "open_url";
})(wo || (wo = {}));
const ub = (e) => e.type === wo.OPEN_URL, UO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ActionType() {
    return wo;
  },
  isOpenURLAction: ub
}, Symbol.toStringTag, { value: "Module" }));
var Qn;
(function(e) {
  e.TEXT = "text", e.ACTION = "action", e.INTENT = "intent", e.LAUNCH = "launch", e.NO_REPLY = "no-reply";
})(Qn || (Qn = {}));
const HO = (e) => e.type === Qn.TEXT, jO = (e) => e.type === Qn.ACTION, zO = (e) => e.type === Qn.LAUNCH, VO = (e) => e.type === Qn.NO_REPLY, GO = (e) => e.type === Qn.INTENT, YO = Object.values(Qn), WO = (e) => !YO.includes(e.type), Pm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Action: UO,
  get RequestType() {
    return Qn;
  },
  isActionRequest: jO,
  isGeneralRequest: WO,
  isIntentRequest: GO,
  isLaunchRequest: zO,
  isNoReplyRequest: VO,
  isTextRequest: HO
}, Symbol.toStringTag, { value: "Module" })), qO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Mt;
(function(e) {
  e.TEXT = "text", e.SPEAK = "speak", e.AUDIO = "audio", e.VISUALS = "visuals", e.CARD = "card", e.CAROUSEL = "carousel", e.BUTTONS = "buttons", e.CHOICE = "choice", e.CAPTURE = "capture", e.PROMPT = "prompt", e.INTENT = "intent", e.CONDITION = "condition", e.SET = "set", e.RANDOM = "random", e.FLOW = "flow", e.EXIT = "exit", e.API = "api", e.GOOGLE_SHEETS = "google_sheets", e.CUSTOM_CODE = "custom_code", e.CUSTOM_ACTION = "custom_action", e.START = "start";
})(Mt || (Mt = {}));
var ef;
(function(e) {
  e.CONVERSATION_START = "conversation_start", e.NLU_INTENT_RESOLVED = "nlu.intent_resolved";
})(ef || (ef = {}));
const Lm = {
  [re.TEXT]: Mt.TEXT,
  [re.SPEAK]: Mt.SPEAK,
  [re.START]: Mt.START,
  [re.CARD]: Mt.CARD,
  [re.CAROUSEL]: Mt.CAROUSEL,
  [re.BUTTONS]: Mt.BUTTONS,
  [re.SET]: Mt.SET,
  [re.SET_V2]: Mt.SET,
  [re.IF]: Mt.CONDITION,
  [re.IF_V2]: Mt.CONDITION,
  [re.RANDOM]: Mt.RANDOM,
  [re.CAPTURE]: Mt.CAPTURE,
  [re.CAPTURE_V2]: Mt.CAPTURE,
  [re.API]: Mt.API,
  /** @deprecated */
  [re.GOOGLE_SHEETS]: Mt.GOOGLE_SHEETS,
  [re.INTENT]: Mt.INTENT,
  [re.CODE]: Mt.CUSTOM_CODE,
  [re.EXIT]: Mt.EXIT,
  [re.PROMPT]: Mt.PROMPT,
  [re.VISUAL]: Mt.VISUALS
};
function KO(e) {
  return e in Lm ? Lm[e] : void 0;
}
const XO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get GlobalLogKind() {
    return ef;
  },
  get StepLogKind() {
    return Mt;
  },
  nodeTypeToStepLogKind: KO
}, Symbol.toStringTag, { value: "Module" }));
var Ar;
(function(e) {
  e.OFF = "off", e.ERROR = "error", e.WARN = "warn", e.INFO = "info", e.VERBOSE = "verbose";
})(Ar || (Ar = {}));
const ZO = {
  [Ar.OFF]: -1,
  [Ar.ERROR]: 0,
  [Ar.WARN]: 1,
  [Ar.INFO]: 2,
  [Ar.VERBOSE]: 3
}, QO = (e) => ZO[e], JO = new Set(Object.values(Ar)), eI = (e) => JO.has(e), tI = Ar.INFO, nI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_LOG_LEVEL: tI,
  Kinds: XO,
  get LogLevel() {
    return Ar;
  },
  Logs: qO,
  getValueForLogLevel: QO,
  isLogLevel: eI
}, Symbol.toStringTag, { value: "Module" }));
var ya;
(function(e) {
  e.BACKGROUND_COLOR = "backgroundColor", e.COLOR = "color", e.ITALIC = "italic", e.UNDERLINE = "underline", e.FONT_WEIGHT = "fontWeight", e.FONT_FAMILY = "fontFamily", e.STRIKE_THROUGH = "strikeThrough";
})(ya || (ya = {}));
var Na;
(function(e) {
  e.LINK = "link", e.VARIABLE = "variable";
})(Na || (Na = {}));
var tf;
(function(e) {
  e.TEXT_ALIGN = "textAlign";
})(tf || (tf = {}));
const rI = (e) => e.type === Na.VARIABLE, aI = (e) => e.type === Na.LINK, Mm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ElementProperty() {
    return tf;
  },
  get ElementType() {
    return Na;
  },
  get TextProperty() {
    return ya;
  },
  isLinkElement: aI,
  isVariableElement: rI
}, Symbol.toStringTag, { value: "Module" })), $m = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TraceType() {
    return ps;
  }
}, Symbol.toStringTag, { value: "Module" }));
var gs;
(function(e) {
  e.DaVinci_003 = "text-davinci-003", e.GPT_3_5_turbo = "gpt-3.5-turbo", e.GPT_4 = "gpt-4", e.CLAUDE_V1 = "claude-v1", e.CLAUDE_V2 = "claude-v2", e.CLAUDE_INSTANT_V1 = "claude-instant-v1";
})(gs || (gs = {}));
const iI = [gs.GPT_3_5_turbo, gs.GPT_4];
var nf;
(function(e) {
  e.PROMPT = "prompt", e.MEMORY = "memory", e.MEMORY_PROMPT = "memory_prompt";
})(nf || (nf = {}));
var rf;
(function(e) {
  e.KNOWLEDGE_BASE = "knowledge_base", e.DEFAULT = "default";
})(rf || (rf = {}));
const sI = "[not found]";
var af;
(function(e) {
  e.SYSTEM = "system", e.ASSISTANT = "assistant", e.USER = "user";
})(af || (af = {}));
const oI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ChatModels: iI,
  get DATA_SOURCE() {
    return rf;
  },
  get GPT_MODEL() {
    return gs;
  },
  KNOWLEDGE_BASE_NOT_FOUND: sI,
  get PROMPT_MODE() {
    return nf;
  },
  get Role() {
    return af;
  }
}, Symbol.toStringTag, { value: "Module" }));
var Bm;
(function(e) {
  e.PRODUCTION = "production", e.DEVELOPMENT = "development", e.LOCAL = "local", e.E2E = "e2e", e.TEST = "test", e.STAGING = "staging";
})(Bm || (Bm = {}));
var uI = { exports: {} };
function lI(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Cl = { exports: {} };
const cI = {}, fI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: cI
}, Symbol.toStringTag, { value: "Module" })), dI = /* @__PURE__ */ Jf(fI);
var Fm;
function lb() {
  return Fm || (Fm = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(je, function() {
      var n = n || function(r, a) {
        var i;
        if (typeof window < "u" && window.crypto && (i = window.crypto), typeof self < "u" && self.crypto && (i = self.crypto), typeof globalThis < "u" && globalThis.crypto && (i = globalThis.crypto), !i && typeof window < "u" && window.msCrypto && (i = window.msCrypto), !i && typeof je < "u" && je.crypto && (i = je.crypto), !i && typeof lI == "function")
          try {
            i = dI;
          } catch {
          }
        var s = function() {
          if (i) {
            if (typeof i.getRandomValues == "function")
              try {
                return i.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof i.randomBytes == "function")
              try {
                return i.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, o = Object.create || /* @__PURE__ */ function() {
          function A() {
          }
          return function(I) {
            var j;
            return A.prototype = I, j = new A(), A.prototype = null, j;
          };
        }(), u = {}, l = u.lib = {}, f = l.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(A) {
              var I = o(this);
              return A && I.mixIn(A), (!I.hasOwnProperty("init") || this.init === I.init) && (I.init = function() {
                I.$super.init.apply(this, arguments);
              }), I.init.prototype = I, I.$super = this, I;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var A = this.extend();
              return A.init.apply(A, arguments), A;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(A) {
              for (var I in A)
                A.hasOwnProperty(I) && (this[I] = A[I]);
              A.hasOwnProperty("toString") && (this.toString = A.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }(), h = l.WordArray = f.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(A, I) {
            A = this.words = A || [], I != a ? this.sigBytes = I : this.sigBytes = A.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(A) {
            return (A || b).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(A) {
            var I = this.words, j = A.words, $ = this.sigBytes, _ = A.sigBytes;
            if (this.clamp(), $ % 4)
              for (var M = 0; M < _; M++) {
                var V = j[M >>> 2] >>> 24 - M % 4 * 8 & 255;
                I[$ + M >>> 2] |= V << 24 - ($ + M) % 4 * 8;
              }
            else
              for (var G = 0; G < _; G += 4)
                I[$ + G >>> 2] = j[G >>> 2];
            return this.sigBytes += _, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var A = this.words, I = this.sigBytes;
            A[I >>> 2] &= 4294967295 << 32 - I % 4 * 8, A.length = r.ceil(I / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var A = f.clone.call(this);
            return A.words = this.words.slice(0), A;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(A) {
            for (var I = [], j = 0; j < A; j += 4)
              I.push(s());
            return new h.init(I, A);
          }
        }), p = u.enc = {}, b = p.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(A) {
            for (var I = A.words, j = A.sigBytes, $ = [], _ = 0; _ < j; _++) {
              var M = I[_ >>> 2] >>> 24 - _ % 4 * 8 & 255;
              $.push((M >>> 4).toString(16)), $.push((M & 15).toString(16));
            }
            return $.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(A) {
            for (var I = A.length, j = [], $ = 0; $ < I; $ += 2)
              j[$ >>> 3] |= parseInt(A.substr($, 2), 16) << 24 - $ % 8 * 4;
            return new h.init(j, I / 2);
          }
        }, v = p.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(A) {
            for (var I = A.words, j = A.sigBytes, $ = [], _ = 0; _ < j; _++) {
              var M = I[_ >>> 2] >>> 24 - _ % 4 * 8 & 255;
              $.push(String.fromCharCode(M));
            }
            return $.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(A) {
            for (var I = A.length, j = [], $ = 0; $ < I; $++)
              j[$ >>> 2] |= (A.charCodeAt($) & 255) << 24 - $ % 4 * 8;
            return new h.init(j, I);
          }
        }, E = p.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(A) {
            try {
              return decodeURIComponent(escape(v.stringify(A)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(A) {
            return v.parse(unescape(encodeURIComponent(A)));
          }
        }, y = l.BufferedBlockAlgorithm = f.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new h.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(A) {
            typeof A == "string" && (A = E.parse(A)), this._data.concat(A), this._nDataBytes += A.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(A) {
            var I, j = this._data, $ = j.words, _ = j.sigBytes, M = this.blockSize, V = M * 4, G = _ / V;
            A ? G = r.ceil(G) : G = r.max((G | 0) - this._minBufferSize, 0);
            var O = G * M, Q = r.min(O * 4, _);
            if (O) {
              for (var ee = 0; ee < O; ee += M)
                this._doProcessBlock($, ee);
              I = $.splice(0, O), j.sigBytes -= Q;
            }
            return new h.init(I, Q);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var A = f.clone.call(this);
            return A._data = this._data.clone(), A;
          },
          _minBufferSize: 0
        });
        l.Hasher = y.extend({
          /**
           * Configuration options.
           */
          cfg: f.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(A) {
            this.cfg = this.cfg.extend(A), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            y.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(A) {
            return this._append(A), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(A) {
            A && this._append(A);
            var I = this._doFinalize();
            return I;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(A) {
            return function(I, j) {
              return new A.init(j).finalize(I);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(A) {
            return function(I, j) {
              return new N.HMAC.init(A, j).finalize(I);
            };
          }
        });
        var N = u.algo = {};
        return u;
      }(Math);
      return n;
    });
  }(Cl)), Cl.exports;
}
(function(e, t) {
  (function(n, r) {
    e.exports = r(lb());
  })(je, function(n) {
    return function() {
      var r = n, a = r.lib, i = a.WordArray, s = r.enc;
      s.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function(u) {
          var l = u.words, f = u.sigBytes, h = this._map;
          u.clamp();
          for (var p = [], b = 0; b < f; b += 3)
            for (var v = l[b >>> 2] >>> 24 - b % 4 * 8 & 255, E = l[b + 1 >>> 2] >>> 24 - (b + 1) % 4 * 8 & 255, y = l[b + 2 >>> 2] >>> 24 - (b + 2) % 4 * 8 & 255, N = v << 16 | E << 8 | y, A = 0; A < 4 && b + A * 0.75 < f; A++)
              p.push(h.charAt(N >>> 6 * (3 - A) & 63));
          var I = h.charAt(64);
          if (I)
            for (; p.length % 4; )
              p.push(I);
          return p.join("");
        },
        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function(u) {
          var l = u.length, f = this._map, h = this._reverseMap;
          if (!h) {
            h = this._reverseMap = [];
            for (var p = 0; p < f.length; p++)
              h[f.charCodeAt(p)] = p;
          }
          var b = f.charAt(64);
          if (b) {
            var v = u.indexOf(b);
            v !== -1 && (l = v);
          }
          return o(u, l, h);
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
      };
      function o(u, l, f) {
        for (var h = [], p = 0, b = 0; b < l; b++)
          if (b % 4) {
            var v = f[u.charCodeAt(b - 1)] << b % 4 * 2, E = f[u.charCodeAt(b)] >>> 6 - b % 4 * 2, y = v | E;
            h[p >>> 2] |= y << 24 - p % 4 * 8, p++;
          }
        return i.create(h, p);
      }
    }(), n.enc.Base64;
  });
})(uI);
var hI = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r(lb());
  })(je, function(n) {
    return n.enc.Utf8;
  });
})(hI);
var Ol = Math.floor(Math.random() * 16777215), Um = xt.index = parseInt(Math.random() * 16777215, 10), Hm = (typeof process > "u" || typeof process.pid != "number" ? Math.floor(Math.random() * 1e5) : process.pid) % 65535, To = function(e) {
  return !!(e != null && e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e));
}, cb = [];
for (var Fn = 0; Fn < 256; Fn++)
  cb[Fn] = (Fn <= 15 ? "0" : "") + Fn.toString(16);
var jm = new RegExp("^[0-9a-fA-F]{24}$"), bs = [];
Fn = 0;
for (; Fn < 10; )
  bs[48 + Fn] = Fn++;
for (; Fn < 16; )
  bs[55 + Fn] = bs[87 + Fn] = Fn++;
function xt(e) {
  if (!(this instanceof xt))
    return new xt(e);
  if (e && (e instanceof xt || e._bsontype === "ObjectID"))
    return e;
  if (this._bsontype = "ObjectID", e == null || typeof e == "number") {
    this.id = this.generate(e);
    return;
  }
  var t = xt.isValid(e);
  if (!t && e != null)
    throw new Error(
      "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
    );
  if (t && typeof e == "string" && e.length === 24)
    return xt.createFromHexString(e);
  if (e != null && e.length === 12)
    this.id = e;
  else {
    if (e != null && typeof e.toHexString == "function")
      return e;
    throw new Error(
      "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
    );
  }
}
xt.default = xt;
xt.createFromTime = function(e) {
  return e = parseInt(e, 10) % 4294967295, new xt(pI(8, e) + "0000000000000000");
};
xt.createFromHexString = function(e) {
  if (typeof e > "u" || e != null && e.length !== 24)
    throw new Error(
      "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
    );
  for (var t = "", n = 0; n < 24; )
    t += String.fromCharCode(bs[e.charCodeAt(n++)] << 4 | bs[e.charCodeAt(n++)]);
  return new xt(t);
};
xt.isValid = function(e) {
  return e == null ? !1 : typeof e == "number" ? !0 : typeof e == "string" ? e.length === 12 || e.length === 24 && jm.test(e) : e instanceof xt || To(e) ? !0 : typeof e.toHexString == "function" && (e.id instanceof _Buffer || typeof e.id == "string") ? e.id.length === 12 || e.id.length === 24 && jm.test(e.id) : !1;
};
xt.prototype = {
  constructor: xt,
  /**
   * Return the ObjectID id as a 24 byte hex string representation
   *
   * @return {String} return the 24 byte hex string representation.
   * @api public
   */
  toHexString: function() {
    if (!this.id || !this.id.length)
      throw new Error(
        "invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]"
      );
    if (this.id.length === 24)
      return this.id;
    if (To(this.id))
      return this.id.toString("hex");
    for (var e = "", t = 0; t < this.id.length; t++)
      e += cb[this.id.charCodeAt(t)];
    return e;
  },
  /**
   * Compares the equality of this ObjectID with `otherID`.
   *
   * @param {Object} otherId ObjectID instance to compare against.
   * @return {Boolean} the result of comparing two ObjectID's
   * @api public
   */
  equals: function(e) {
    return e instanceof xt ? this.toString() === e.toString() : typeof e == "string" && xt.isValid(e) && e.length === 12 && To(this.id) ? e === this.id.toString("binary") : typeof e == "string" && xt.isValid(e) && e.length === 24 ? e.toLowerCase() === this.toHexString() : typeof e == "string" && xt.isValid(e) && e.length === 12 ? e === this.id : e != null && (e instanceof xt || e.toHexString) ? e.toHexString() === this.toHexString() : !1;
  },
  /**
   * Returns the generation date (accurate up to the second) that this ID was generated.
   *
   * @return {Date} the generation date
   * @api public
   */
  getTimestamp: function() {
    var e = /* @__PURE__ */ new Date(), t;
    return To(this.id) ? t = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24 : t = this.id.charCodeAt(3) | this.id.charCodeAt(2) << 8 | this.id.charCodeAt(1) << 16 | this.id.charCodeAt(0) << 24, e.setTime(Math.floor(t) * 1e3), e;
  },
  /**
  * Generate a 12 byte id buffer used in ObjectID's
  *
  * @method
  * @param {number} [time] optional parameter allowing to pass in a second based timestamp.
  * @return {string} return the 12 byte id buffer string.
  */
  generate: function(e) {
    typeof e != "number" && (e = ~~(Date.now() / 1e3)), e = parseInt(e, 10) % 4294967295;
    var t = mI();
    return String.fromCharCode(
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      Ol >> 16 & 255,
      Ol >> 8 & 255,
      Ol & 255,
      Hm >> 8 & 255,
      Hm & 255,
      t >> 16 & 255,
      t >> 8 & 255,
      t & 255
    );
  }
};
function mI() {
  return Um = (Um + 1) % 16777215;
}
function pI(e, t) {
  return t = t.toString(16), t.length === e ? t : "00000000".substring(t.length, e) + t;
}
var gI = Symbol && Symbol.for && Symbol.for("nodejs.util.inspect.custom") || "inspect";
xt.prototype[gI] = function() {
  return "ObjectID(" + this + ")";
};
xt.prototype.toJSON = xt.prototype.toHexString;
xt.prototype.toString = xt.prototype.toHexString;
var fb = function(t, n) {
  var r = "000000000" + t;
  return r.substr(r.length - n);
}, bI = fb, EI = typeof window == "object" ? window : self, vI = Object.keys(EI).length, TI = navigator.mimeTypes ? navigator.mimeTypes.length : 0, AI = bI((TI + navigator.userAgent.length).toString(36) + vI.toString(36), 4), _I = function() {
  return AI;
}, sf, zm = typeof window < "u" && (window.crypto || window.msCrypto) || typeof self < "u" && self.crypto;
if (zm) {
  var yI = Math.pow(2, 32) - 1;
  sf = function() {
    return Math.abs(zm.getRandomValues(new Uint32Array(1))[0] / yI);
  };
} else
  sf = Math.random;
var SI = sf, Do = _I, db = fb, CI = SI, Yi = 0, ud = 4, Po = 36, hb = Math.pow(Po, ud);
function of() {
  return db((CI() * hb << 0).toString(Po), ud);
}
function mb() {
  return Yi = Yi < hb ? Yi : 0, Yi++, Yi - 1;
}
function Ms() {
  var e = "c", t = (/* @__PURE__ */ new Date()).getTime().toString(Po), n = db(mb().toString(Po), ud), r = Do(), a = of() + of();
  return e + t + n + r + a;
}
Ms.slug = function() {
  var t = (/* @__PURE__ */ new Date()).getTime().toString(36), n = mb().toString(36).slice(-4), r = Do().slice(0, 1) + Do().slice(-1), a = of().slice(-2);
  return t.slice(-2) + n + r + a;
};
Ms.isCuid = function(t) {
  return typeof t != "string" ? !1 : !!t.startsWith("c");
};
Ms.isSlug = function(t) {
  if (typeof t != "string")
    return !1;
  var n = t.length;
  return n >= 7 && n <= 10;
};
Ms.fingerprint = Do;
var OI = Ms;
const Es = /* @__PURE__ */ Ft(OI);
var II = typeof je == "object" && je && je.Object === Object && je, pb = II, xI = pb, NI = typeof self == "object" && self && self.Object === Object && self, RI = xI || NI || Function("return this")(), Hr = RI, kI = Hr, wI = kI.Symbol, mu = wI, Vm = mu, gb = Object.prototype, DI = gb.hasOwnProperty, PI = gb.toString, Wi = Vm ? Vm.toStringTag : void 0;
function LI(e) {
  var t = DI.call(e, Wi), n = e[Wi];
  try {
    e[Wi] = void 0;
    var r = !0;
  } catch {
  }
  var a = PI.call(e);
  return r && (t ? e[Wi] = n : delete e[Wi]), a;
}
var MI = LI, $I = Object.prototype, BI = $I.toString;
function FI(e) {
  return BI.call(e);
}
var UI = FI, Gm = mu, HI = MI, jI = UI, zI = "[object Null]", VI = "[object Undefined]", Ym = Gm ? Gm.toStringTag : void 0;
function GI(e) {
  return e == null ? e === void 0 ? VI : zI : Ym && Ym in Object(e) ? HI(e) : jI(e);
}
var ld = GI;
function YI(e) {
  return e != null && typeof e == "object";
}
var bb = YI, WI = Function.prototype, qI = WI.toString;
qI.call(Object);
const KI = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
function XI(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var Eb = XI, ZI = ld, QI = bb, JI = "[object Arguments]";
function e3(e) {
  return QI(e) && ZI(e) == JI;
}
var t3 = e3, Wm = t3, n3 = bb, vb = Object.prototype, r3 = vb.hasOwnProperty, a3 = vb.propertyIsEnumerable;
Wm(/* @__PURE__ */ function() {
  return arguments;
}());
var Lo = { exports: {} };
function i3() {
  return !1;
}
var s3 = i3;
Lo.exports;
(function(e, t) {
  var n = Hr, r = s3, a = t && !t.nodeType && t, i = a && !0 && e && !e.nodeType && e, s = i && i.exports === a, o = s ? n.Buffer : void 0, u = o ? o.isBuffer : void 0, l = u || r;
  e.exports = l;
})(Lo, Lo.exports);
Lo.exports;
var Mo = { exports: {} };
Mo.exports;
(function(e, t) {
  var n = pb, r = t && !t.nodeType && t, a = r && !0 && e && !e.nodeType && e, i = a && a.exports === r, s = i && n.process, o = function() {
    try {
      var u = a && a.require && a.require("util").types;
      return u || s && s.binding && s.binding("util");
    } catch {
    }
  }();
  e.exports = o;
})(Mo, Mo.exports);
var o3 = Mo.exports, qm = o3;
qm && qm.isTypedArray;
var u3 = ld, l3 = Eb, c3 = "[object AsyncFunction]", f3 = "[object Function]", d3 = "[object GeneratorFunction]", h3 = "[object Proxy]";
function m3(e) {
  if (!l3(e))
    return !1;
  var t = u3(e);
  return t == f3 || t == d3 || t == c3 || t == h3;
}
var p3 = m3;
function g3() {
  this.__data__ = [], this.size = 0;
}
var b3 = g3;
function E3(e, t) {
  return e === t || e !== e && t !== t;
}
var v3 = E3, T3 = v3;
function A3(e, t) {
  for (var n = e.length; n--; )
    if (T3(e[n][0], t))
      return n;
  return -1;
}
var pu = A3, _3 = pu, y3 = Array.prototype, S3 = y3.splice;
function C3(e) {
  var t = this.__data__, n = _3(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : S3.call(t, n, 1), --this.size, !0;
}
var O3 = C3, I3 = pu;
function x3(e) {
  var t = this.__data__, n = I3(t, e);
  return n < 0 ? void 0 : t[n][1];
}
var N3 = x3, R3 = pu;
function k3(e) {
  return R3(this.__data__, e) > -1;
}
var w3 = k3, D3 = pu;
function P3(e, t) {
  var n = this.__data__, r = D3(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
var L3 = P3, M3 = b3, $3 = O3, B3 = N3, F3 = w3, U3 = L3;
function _i(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
_i.prototype.clear = M3;
_i.prototype.delete = $3;
_i.prototype.get = B3;
_i.prototype.has = F3;
_i.prototype.set = U3;
var gu = _i, H3 = gu;
function j3() {
  this.__data__ = new H3(), this.size = 0;
}
var z3 = j3;
function V3(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
var G3 = V3;
function Y3(e) {
  return this.__data__.get(e);
}
var W3 = Y3;
function q3(e) {
  return this.__data__.has(e);
}
var K3 = q3, X3 = Hr, Z3 = X3["__core-js_shared__"], Q3 = Z3, Il = Q3, Km = function() {
  var e = /[^.]+$/.exec(Il && Il.keys && Il.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function J3(e) {
  return !!Km && Km in e;
}
var ex = J3, tx = Function.prototype, nx = tx.toString;
function rx(e) {
  if (e != null) {
    try {
      return nx.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var Tb = rx, ax = p3, ix = ex, sx = Eb, ox = Tb, ux = /[\\^$.*+?()[\]{}|]/g, lx = /^\[object .+?Constructor\]$/, cx = Function.prototype, fx = Object.prototype, dx = cx.toString, hx = fx.hasOwnProperty, mx = RegExp(
  "^" + dx.call(hx).replace(ux, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function px(e) {
  if (!sx(e) || ix(e))
    return !1;
  var t = ax(e) ? mx : lx;
  return t.test(ox(e));
}
var gx = px;
function bx(e, t) {
  return e == null ? void 0 : e[t];
}
var Ex = bx, vx = gx, Tx = Ex;
function Ax(e, t) {
  var n = Tx(e, t);
  return vx(n) ? n : void 0;
}
var yi = Ax, _x = yi, yx = Hr, Sx = _x(yx, "Map"), cd = Sx, Cx = yi, Ox = Cx(Object, "create"), bu = Ox, Xm = bu;
function Ix() {
  this.__data__ = Xm ? Xm(null) : {}, this.size = 0;
}
var xx = Ix;
function Nx(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Rx = Nx, kx = bu, wx = "__lodash_hash_undefined__", Dx = Object.prototype, Px = Dx.hasOwnProperty;
function Lx(e) {
  var t = this.__data__;
  if (kx) {
    var n = t[e];
    return n === wx ? void 0 : n;
  }
  return Px.call(t, e) ? t[e] : void 0;
}
var Mx = Lx, $x = bu, Bx = Object.prototype, Fx = Bx.hasOwnProperty;
function Ux(e) {
  var t = this.__data__;
  return $x ? t[e] !== void 0 : Fx.call(t, e);
}
var Hx = Ux, jx = bu, zx = "__lodash_hash_undefined__";
function Vx(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = jx && t === void 0 ? zx : t, this;
}
var Gx = Vx, Yx = xx, Wx = Rx, qx = Mx, Kx = Hx, Xx = Gx;
function Si(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Si.prototype.clear = Yx;
Si.prototype.delete = Wx;
Si.prototype.get = qx;
Si.prototype.has = Kx;
Si.prototype.set = Xx;
var Zx = Si, Zm = Zx, Qx = gu, Jx = cd;
function eN() {
  this.size = 0, this.__data__ = {
    hash: new Zm(),
    map: new (Jx || Qx)(),
    string: new Zm()
  };
}
var tN = eN;
function nN(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
var rN = nN, aN = rN;
function iN(e, t) {
  var n = e.__data__;
  return aN(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
var Eu = iN, sN = Eu;
function oN(e) {
  var t = sN(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
var uN = oN, lN = Eu;
function cN(e) {
  return lN(this, e).get(e);
}
var fN = cN, dN = Eu;
function hN(e) {
  return dN(this, e).has(e);
}
var mN = hN, pN = Eu;
function gN(e, t) {
  var n = pN(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
var bN = gN, EN = tN, vN = uN, TN = fN, AN = mN, _N = bN;
function Ci(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Ci.prototype.clear = EN;
Ci.prototype.delete = vN;
Ci.prototype.get = TN;
Ci.prototype.has = AN;
Ci.prototype.set = _N;
var fd = Ci, yN = gu, SN = cd, CN = fd, ON = 200;
function IN(e, t) {
  var n = this.__data__;
  if (n instanceof yN) {
    var r = n.__data__;
    if (!SN || r.length < ON - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new CN(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
var xN = IN, NN = gu, RN = z3, kN = G3, wN = W3, DN = K3, PN = xN;
function $s(e) {
  var t = this.__data__ = new NN(e);
  this.size = t.size;
}
$s.prototype.clear = RN;
$s.prototype.delete = kN;
$s.prototype.get = wN;
$s.prototype.has = DN;
$s.prototype.set = PN;
var LN = "__lodash_hash_undefined__";
function MN(e) {
  return this.__data__.set(e, LN), this;
}
var $N = MN;
function BN(e) {
  return this.__data__.has(e);
}
var FN = BN, UN = fd, HN = $N, jN = FN;
function uf(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new UN(); ++t < n; )
    this.add(e[t]);
}
uf.prototype.add = uf.prototype.push = HN;
uf.prototype.has = jN;
var zN = Hr;
zN.Uint8Array;
function VN(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var GN = VN, Qm = mu, Jm = Qm ? Qm.prototype : void 0;
Jm && Jm.valueOf;
var YN = yi, WN = Hr, qN = YN(WN, "DataView"), KN = qN, XN = yi, ZN = Hr, QN = XN(ZN, "Promise"), JN = QN, eR = yi, tR = Hr, nR = eR(tR, "Set"), Ab = nR, rR = yi, aR = Hr, iR = rR(aR, "WeakMap"), sR = iR, lf = KN, cf = cd, ff = JN, df = Ab, hf = sR, _b = ld, Oi = Tb, e0 = "[object Map]", oR = "[object Object]", t0 = "[object Promise]", n0 = "[object Set]", r0 = "[object WeakMap]", a0 = "[object DataView]", uR = Oi(lf), lR = Oi(cf), cR = Oi(ff), fR = Oi(df), dR = Oi(hf), ai = _b;
(lf && ai(new lf(new ArrayBuffer(1))) != a0 || cf && ai(new cf()) != e0 || ff && ai(ff.resolve()) != t0 || df && ai(new df()) != n0 || hf && ai(new hf()) != r0) && (ai = function(e) {
  var t = _b(e), n = t == oR ? e.constructor : void 0, r = n ? Oi(n) : "";
  if (r)
    switch (r) {
      case uR:
        return a0;
      case lR:
        return e0;
      case cR:
        return t0;
      case fR:
        return n0;
      case dR:
        return r0;
    }
  return t;
});
var yb = fd, hR = "Expected a function";
function dd(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(hR);
  var n = function() {
    var r = arguments, a = t ? t.apply(this, r) : r[0], i = n.cache;
    if (i.has(a))
      return i.get(a);
    var s = e.apply(this, r);
    return n.cache = i.set(a, s) || i, s;
  };
  return n.cache = new (dd.Cache || yb)(), n;
}
dd.Cache = yb;
var mR = dd, pR = mR, gR = 500;
function bR(e) {
  var t = pR(e, function(r) {
    return n.size === gR && n.clear(), r;
  }), n = t.cache;
  return t;
}
var ER = bR, vR = ER, TR = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, AR = /\\(\\)?/g;
vR(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(TR, function(n, r, a, i) {
    t.push(a ? i.replace(AR, "$1") : r || n);
  }), t;
});
var i0 = mu, s0 = i0 ? i0.prototype : void 0;
s0 && s0.toString;
Array.from({ length: 26 }).map((e, t) => String.fromCharCode(97 + t));
function _R() {
}
var yR = _R, xl = Ab, SR = yR, CR = GN, OR = 1 / 0;
xl && 1 / CR(new xl([, -0]))[1] == OR;
var vu = {}, IR = {};
Object.defineProperty(vu, "__esModule", { value: !0 });
function xR(e, t) {
  return e.type === t.type;
}
vu.isType = xR;
function Sb(e, t) {
  t === void 0 && (t = function(s) {
    return s instanceof Error;
  });
  var n = {}, r = e ? e + "/" : "";
  function a(s, o, u) {
    u === void 0 && (u = t);
    var l = r + s;
    if (IR.NODE_ENV !== "production") {
      if (n[l])
        throw new Error("Duplicate action type: " + l);
      n[l] = !0;
    }
    return Object.assign(function(f, h) {
      var p = {
        type: l,
        payload: f
      };
      return (o || h) && (p.meta = Object.assign({}, o, h)), u && (typeof u == "boolean" || u(f)) && (p.error = !0), p;
    }, {
      type: l,
      toString: function() {
        return l;
      },
      match: function(f) {
        return f.type === l;
      }
    });
  }
  function i(s, o) {
    return {
      type: r + s,
      started: a(s + "_STARTED", o, !1),
      done: a(s + "_DONE", o, !1),
      failed: a(s + "_FAILED", o, !0)
    };
  }
  return Object.assign(a, { async: i });
}
vu.actionCreatorFactory = Sb;
var Cb = vu.default = Sb;
Cb();
var Ob = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    var n = 1e3, r = 6e4, a = 36e5, i = "millisecond", s = "second", o = "minute", u = "hour", l = "day", f = "week", h = "month", p = "quarter", b = "year", v = "date", E = "Invalid Date", y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, N = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, A = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, I = function(H, D, R) {
      var Y = String(H);
      return !Y || Y.length >= D ? H : "" + Array(D + 1 - Y.length).join(R) + H;
    }, j = { s: I, z: function(H) {
      var D = -H.utcOffset(), R = Math.abs(D), Y = Math.floor(R / 60), P = R % 60;
      return (D <= 0 ? "+" : "-") + I(Y, 2, "0") + ":" + I(P, 2, "0");
    }, m: function H(D, R) {
      if (D.date() < R.date())
        return -H(R, D);
      var Y = 12 * (R.year() - D.year()) + (R.month() - D.month()), P = D.clone().add(Y, h), Z = R - P < 0, W = D.clone().add(Y + (Z ? -1 : 1), h);
      return +(-(Y + (R - P) / (Z ? P - W : W - P)) || 0);
    }, a: function(H) {
      return H < 0 ? Math.ceil(H) || 0 : Math.floor(H);
    }, p: function(H) {
      return { M: h, y: b, w: f, d: l, D: v, h: u, m: o, s, ms: i, Q: p }[H] || String(H || "").toLowerCase().replace(/s$/, "");
    }, u: function(H) {
      return H === void 0;
    } }, $ = "en", _ = {};
    _[$] = A;
    var M = function(H) {
      return H instanceof Q;
    }, V = function(H, D, R) {
      var Y;
      if (!H)
        return $;
      if (typeof H == "string")
        _[H] && (Y = H), D && (_[H] = D, Y = H);
      else {
        var P = H.name;
        _[P] = H, Y = P;
      }
      return !R && Y && ($ = Y), Y || !R && $;
    }, G = function(H, D) {
      if (M(H))
        return H.clone();
      var R = typeof D == "object" ? D : {};
      return R.date = H, R.args = arguments, new Q(R);
    }, O = j;
    O.l = V, O.i = M, O.w = function(H, D) {
      return G(H, { locale: D.$L, utc: D.$u, x: D.$x, $offset: D.$offset });
    };
    var Q = function() {
      function H(R) {
        this.$L = V(R.locale, null, !0), this.parse(R);
      }
      var D = H.prototype;
      return D.parse = function(R) {
        this.$d = function(Y) {
          var P = Y.date, Z = Y.utc;
          if (P === null)
            return /* @__PURE__ */ new Date(NaN);
          if (O.u(P))
            return /* @__PURE__ */ new Date();
          if (P instanceof Date)
            return new Date(P);
          if (typeof P == "string" && !/Z$/i.test(P)) {
            var W = P.match(y);
            if (W) {
              var C = W[2] - 1 || 0, pe = (W[7] || "0").substring(0, 3);
              return Z ? new Date(Date.UTC(W[1], C, W[3] || 1, W[4] || 0, W[5] || 0, W[6] || 0, pe)) : new Date(W[1], C, W[3] || 1, W[4] || 0, W[5] || 0, W[6] || 0, pe);
            }
          }
          return new Date(P);
        }(R), this.$x = R.x || {}, this.init();
      }, D.init = function() {
        var R = this.$d;
        this.$y = R.getFullYear(), this.$M = R.getMonth(), this.$D = R.getDate(), this.$W = R.getDay(), this.$H = R.getHours(), this.$m = R.getMinutes(), this.$s = R.getSeconds(), this.$ms = R.getMilliseconds();
      }, D.$utils = function() {
        return O;
      }, D.isValid = function() {
        return this.$d.toString() !== E;
      }, D.isSame = function(R, Y) {
        var P = G(R);
        return this.startOf(Y) <= P && P <= this.endOf(Y);
      }, D.isAfter = function(R, Y) {
        return G(R) < this.startOf(Y);
      }, D.isBefore = function(R, Y) {
        return this.endOf(Y) < G(R);
      }, D.$g = function(R, Y, P) {
        return O.u(R) ? this[Y] : this.set(P, R);
      }, D.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, D.valueOf = function() {
        return this.$d.getTime();
      }, D.startOf = function(R, Y) {
        var P = this, Z = !!O.u(Y) || Y, W = O.p(R), C = function(Ue, Ae) {
          var Me = O.w(P.$u ? Date.UTC(P.$y, Ae, Ue) : new Date(P.$y, Ae, Ue), P);
          return Z ? Me : Me.endOf(l);
        }, pe = function(Ue, Ae) {
          return O.w(P.toDate()[Ue].apply(P.toDate("s"), (Z ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Ae)), P);
        }, me = this.$W, w = this.$M, Ne = this.$D, Re = "set" + (this.$u ? "UTC" : "");
        switch (W) {
          case b:
            return Z ? C(1, 0) : C(31, 11);
          case h:
            return Z ? C(1, w) : C(0, w + 1);
          case f:
            var De = this.$locale().weekStart || 0, Qe = (me < De ? me + 7 : me) - De;
            return C(Z ? Ne - Qe : Ne + (6 - Qe), w);
          case l:
          case v:
            return pe(Re + "Hours", 0);
          case u:
            return pe(Re + "Minutes", 1);
          case o:
            return pe(Re + "Seconds", 2);
          case s:
            return pe(Re + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, D.endOf = function(R) {
        return this.startOf(R, !1);
      }, D.$set = function(R, Y) {
        var P, Z = O.p(R), W = "set" + (this.$u ? "UTC" : ""), C = (P = {}, P[l] = W + "Date", P[v] = W + "Date", P[h] = W + "Month", P[b] = W + "FullYear", P[u] = W + "Hours", P[o] = W + "Minutes", P[s] = W + "Seconds", P[i] = W + "Milliseconds", P)[Z], pe = Z === l ? this.$D + (Y - this.$W) : Y;
        if (Z === h || Z === b) {
          var me = this.clone().set(v, 1);
          me.$d[C](pe), me.init(), this.$d = me.set(v, Math.min(this.$D, me.daysInMonth())).$d;
        } else
          C && this.$d[C](pe);
        return this.init(), this;
      }, D.set = function(R, Y) {
        return this.clone().$set(R, Y);
      }, D.get = function(R) {
        return this[O.p(R)]();
      }, D.add = function(R, Y) {
        var P, Z = this;
        R = Number(R);
        var W = O.p(Y), C = function(w) {
          var Ne = G(Z);
          return O.w(Ne.date(Ne.date() + Math.round(w * R)), Z);
        };
        if (W === h)
          return this.set(h, this.$M + R);
        if (W === b)
          return this.set(b, this.$y + R);
        if (W === l)
          return C(1);
        if (W === f)
          return C(7);
        var pe = (P = {}, P[o] = r, P[u] = a, P[s] = n, P)[W] || 1, me = this.$d.getTime() + R * pe;
        return O.w(me, this);
      }, D.subtract = function(R, Y) {
        return this.add(-1 * R, Y);
      }, D.format = function(R) {
        var Y = this, P = this.$locale();
        if (!this.isValid())
          return P.invalidDate || E;
        var Z = R || "YYYY-MM-DDTHH:mm:ssZ", W = O.z(this), C = this.$H, pe = this.$m, me = this.$M, w = P.weekdays, Ne = P.months, Re = function(Ae, Me, it, pt) {
          return Ae && (Ae[Me] || Ae(Y, Z)) || it[Me].substr(0, pt);
        }, De = function(Ae) {
          return O.s(C % 12 || 12, Ae, "0");
        }, Qe = P.meridiem || function(Ae, Me, it) {
          var pt = Ae < 12 ? "AM" : "PM";
          return it ? pt.toLowerCase() : pt;
        }, Ue = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: me + 1, MM: O.s(me + 1, 2, "0"), MMM: Re(P.monthsShort, me, Ne, 3), MMMM: Re(Ne, me), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: Re(P.weekdaysMin, this.$W, w, 2), ddd: Re(P.weekdaysShort, this.$W, w, 3), dddd: w[this.$W], H: String(C), HH: O.s(C, 2, "0"), h: De(1), hh: De(2), a: Qe(C, pe, !0), A: Qe(C, pe, !1), m: String(pe), mm: O.s(pe, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: W };
        return Z.replace(N, function(Ae, Me) {
          return Me || Ue[Ae] || W.replace(":", "");
        });
      }, D.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, D.diff = function(R, Y, P) {
        var Z, W = O.p(Y), C = G(R), pe = (C.utcOffset() - this.utcOffset()) * r, me = this - C, w = O.m(this, C);
        return w = (Z = {}, Z[b] = w / 12, Z[h] = w, Z[p] = w / 3, Z[f] = (me - pe) / 6048e5, Z[l] = (me - pe) / 864e5, Z[u] = me / a, Z[o] = me / r, Z[s] = me / n, Z)[W] || me, P ? w : O.a(w);
      }, D.daysInMonth = function() {
        return this.endOf(h).$D;
      }, D.$locale = function() {
        return _[this.$L];
      }, D.locale = function(R, Y) {
        if (!R)
          return this.$L;
        var P = this.clone(), Z = V(R, Y, !0);
        return Z && (P.$L = Z), P;
      }, D.clone = function() {
        return O.w(this.$d, this);
      }, D.toDate = function() {
        return new Date(this.valueOf());
      }, D.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, D.toISOString = function() {
        return this.$d.toISOString();
      }, D.toString = function() {
        return this.$d.toUTCString();
      }, H;
    }(), ee = Q.prototype;
    return G.prototype = ee, [["$ms", i], ["$s", s], ["$m", o], ["$H", u], ["$W", l], ["$M", h], ["$y", b], ["$D", v]].forEach(function(H) {
      ee[H[1]] = function(D) {
        return this.$g(D, H[0], H[1]);
      };
    }), G.extend = function(H, D) {
      return H.$i || (H(D, Q, G), H.$i = !0), G;
    }, G.locale = V, G.isDayjs = M, G.unix = function(H) {
      return G(1e3 * H);
    }, G.en = _[$], G.Ls = _, G.p = {}, G;
  });
})(Ob);
var NR = Ob.exports;
const la = /* @__PURE__ */ Ft(NR);
var Ib = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    return function(n, r, a) {
      var i = r.prototype, s = i.format;
      a.en.ordinal = function(o) {
        var u = ["th", "st", "nd", "rd"], l = o % 100;
        return "[" + o + (u[(l - 20) % 10] || u[l] || u[0]) + "]";
      }, i.format = function(o) {
        var u = this, l = this.$locale();
        if (!this.isValid())
          return s.bind(this)(o);
        var f = this.$utils(), h = (o || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(p) {
          switch (p) {
            case "Q":
              return Math.ceil((u.$M + 1) / 3);
            case "Do":
              return l.ordinal(u.$D);
            case "gggg":
              return u.weekYear();
            case "GGGG":
              return u.isoWeekYear();
            case "wo":
              return l.ordinal(u.week(), "W");
            case "w":
            case "ww":
              return f.s(u.week(), p === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return f.s(u.isoWeek(), p === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return f.s(String(u.$H === 0 ? 24 : u.$H), p === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(u.$d.getTime() / 1e3);
            case "x":
              return u.$d.getTime();
            case "z":
              return "[" + u.offsetName() + "]";
            case "zzz":
              return "[" + u.offsetName("long") + "]";
            default:
              return p;
          }
        });
        return s.bind(this)(h);
      };
    };
  });
})(Ib);
var RR = Ib.exports;
const kR = /* @__PURE__ */ Ft(RR);
var xb = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, r = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, a = /\d\d/, i = /\d\d?/, s = /\d*[^\s\d-_:/()]+/, o = {}, u = function(E) {
      return (E = +E) + (E > 68 ? 1900 : 2e3);
    }, l = function(E) {
      return function(y) {
        this[E] = +y;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(E) {
      (this.zone || (this.zone = {})).offset = function(y) {
        if (!y || y === "Z")
          return 0;
        var N = y.match(/([+-]|\d\d)/g), A = 60 * N[1] + (+N[2] || 0);
        return A === 0 ? 0 : N[0] === "+" ? -A : A;
      }(E);
    }], h = function(E) {
      var y = o[E];
      return y && (y.indexOf ? y : y.s.concat(y.f));
    }, p = function(E, y) {
      var N, A = o.meridiem;
      if (A) {
        for (var I = 1; I <= 24; I += 1)
          if (E.indexOf(A(I, 0, y)) > -1) {
            N = I > 12;
            break;
          }
      } else
        N = E === (y ? "pm" : "PM");
      return N;
    }, b = { A: [s, function(E) {
      this.afternoon = p(E, !1);
    }], a: [s, function(E) {
      this.afternoon = p(E, !0);
    }], S: [/\d/, function(E) {
      this.milliseconds = 100 * +E;
    }], SS: [a, function(E) {
      this.milliseconds = 10 * +E;
    }], SSS: [/\d{3}/, function(E) {
      this.milliseconds = +E;
    }], s: [i, l("seconds")], ss: [i, l("seconds")], m: [i, l("minutes")], mm: [i, l("minutes")], H: [i, l("hours")], h: [i, l("hours")], HH: [i, l("hours")], hh: [i, l("hours")], D: [i, l("day")], DD: [a, l("day")], Do: [s, function(E) {
      var y = o.ordinal, N = E.match(/\d+/);
      if (this.day = N[0], y)
        for (var A = 1; A <= 31; A += 1)
          y(A).replace(/\[|\]/g, "") === E && (this.day = A);
    }], M: [i, l("month")], MM: [a, l("month")], MMM: [s, function(E) {
      var y = h("months"), N = (h("monthsShort") || y.map(function(A) {
        return A.substr(0, 3);
      })).indexOf(E) + 1;
      if (N < 1)
        throw new Error();
      this.month = N % 12 || N;
    }], MMMM: [s, function(E) {
      var y = h("months").indexOf(E) + 1;
      if (y < 1)
        throw new Error();
      this.month = y % 12 || y;
    }], Y: [/[+-]?\d+/, l("year")], YY: [a, function(E) {
      this.year = u(E);
    }], YYYY: [/\d{4}/, l("year")], Z: f, ZZ: f };
    function v(E) {
      var y, N;
      y = E, N = o && o.formats;
      for (var A = (E = y.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(G, O, Q) {
        var ee = Q && Q.toUpperCase();
        return O || N[Q] || n[Q] || N[ee].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(H, D, R) {
          return D || R.slice(1);
        });
      })).match(r), I = A.length, j = 0; j < I; j += 1) {
        var $ = A[j], _ = b[$], M = _ && _[0], V = _ && _[1];
        A[j] = V ? { regex: M, parser: V } : $.replace(/^\[|\]$/g, "");
      }
      return function(G) {
        for (var O = {}, Q = 0, ee = 0; Q < I; Q += 1) {
          var H = A[Q];
          if (typeof H == "string")
            ee += H.length;
          else {
            var D = H.regex, R = H.parser, Y = G.substr(ee), P = D.exec(Y)[0];
            R.call(O, P), G = G.replace(P, "");
          }
        }
        return function(Z) {
          var W = Z.afternoon;
          if (W !== void 0) {
            var C = Z.hours;
            W ? C < 12 && (Z.hours += 12) : C === 12 && (Z.hours = 0), delete Z.afternoon;
          }
        }(O), O;
      };
    }
    return function(E, y, N) {
      N.p.customParseFormat = !0, E && E.parseTwoDigitYear && (u = E.parseTwoDigitYear);
      var A = y.prototype, I = A.parse;
      A.parse = function(j) {
        var $ = j.date, _ = j.utc, M = j.args;
        this.$u = _;
        var V = M[1];
        if (typeof V == "string") {
          var G = M[2] === !0, O = M[3] === !0, Q = G || O, ee = M[2];
          O && (ee = M[2]), o = this.$locale(), !G && ee && (o = N.Ls[ee]), this.$d = function(Y, P, Z) {
            try {
              if (["x", "X"].indexOf(P) > -1)
                return new Date((P === "X" ? 1e3 : 1) * Y);
              var W = v(P)(Y), C = W.year, pe = W.month, me = W.day, w = W.hours, Ne = W.minutes, Re = W.seconds, De = W.milliseconds, Qe = W.zone, Ue = /* @__PURE__ */ new Date(), Ae = me || (C || pe ? 1 : Ue.getDate()), Me = C || Ue.getFullYear(), it = 0;
              C && !pe || (it = pe > 0 ? pe - 1 : Ue.getMonth());
              var pt = w || 0, Kt = Ne || 0, Xt = Re || 0, un = De || 0;
              return Qe ? new Date(Date.UTC(Me, it, Ae, pt, Kt, Xt, un + 60 * Qe.offset * 1e3)) : Z ? new Date(Date.UTC(Me, it, Ae, pt, Kt, Xt, un)) : new Date(Me, it, Ae, pt, Kt, Xt, un);
            } catch {
              return /* @__PURE__ */ new Date("");
            }
          }($, V, _), this.init(), ee && ee !== !0 && (this.$L = this.locale(ee).$L), Q && $ != this.format(V) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
        } else if (V instanceof Array)
          for (var H = V.length, D = 1; D <= H; D += 1) {
            M[1] = V[D - 1];
            var R = N.apply(this, M);
            if (R.isValid()) {
              this.$d = R.$d, this.$L = R.$L, this.init();
              break;
            }
            D === H && (this.$d = /* @__PURE__ */ new Date(""));
          }
        else
          I.call(this, j);
      };
    };
  });
})(xb);
var wR = xb.exports;
const DR = /* @__PURE__ */ Ft(wR);
var Nb = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    var n, r, a = 1e3, i = 6e4, s = 36e5, o = 864e5, u = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, l = 31536e6, f = 2592e6, h = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, p = { years: l, months: f, days: o, hours: s, minutes: i, seconds: a, milliseconds: 1, weeks: 6048e5 }, b = function($) {
      return $ instanceof j;
    }, v = function($, _, M) {
      return new j($, M, _.$l);
    }, E = function($) {
      return r.p($) + "s";
    }, y = function($) {
      return $ < 0;
    }, N = function($) {
      return y($) ? Math.ceil($) : Math.floor($);
    }, A = function($) {
      return Math.abs($);
    }, I = function($, _) {
      return $ ? y($) ? { negative: !0, format: "" + A($) + _ } : { negative: !1, format: "" + $ + _ } : { negative: !1, format: "" };
    }, j = function() {
      function $(M, V, G) {
        var O = this;
        if (this.$d = {}, this.$l = G, M === void 0 && (this.$ms = 0, this.parseFromMilliseconds()), V)
          return v(M * p[E(V)], this);
        if (typeof M == "number")
          return this.$ms = M, this.parseFromMilliseconds(), this;
        if (typeof M == "object")
          return Object.keys(M).forEach(function(H) {
            O.$d[E(H)] = M[H];
          }), this.calMilliseconds(), this;
        if (typeof M == "string") {
          var Q = M.match(h);
          if (Q) {
            var ee = Q.slice(2).map(function(H) {
              return H != null ? Number(H) : 0;
            });
            return this.$d.years = ee[0], this.$d.months = ee[1], this.$d.weeks = ee[2], this.$d.days = ee[3], this.$d.hours = ee[4], this.$d.minutes = ee[5], this.$d.seconds = ee[6], this.calMilliseconds(), this;
          }
        }
        return this;
      }
      var _ = $.prototype;
      return _.calMilliseconds = function() {
        var M = this;
        this.$ms = Object.keys(this.$d).reduce(function(V, G) {
          return V + (M.$d[G] || 0) * p[G];
        }, 0);
      }, _.parseFromMilliseconds = function() {
        var M = this.$ms;
        this.$d.years = N(M / l), M %= l, this.$d.months = N(M / f), M %= f, this.$d.days = N(M / o), M %= o, this.$d.hours = N(M / s), M %= s, this.$d.minutes = N(M / i), M %= i, this.$d.seconds = N(M / a), M %= a, this.$d.milliseconds = M;
      }, _.toISOString = function() {
        var M = I(this.$d.years, "Y"), V = I(this.$d.months, "M"), G = +this.$d.days || 0;
        this.$d.weeks && (G += 7 * this.$d.weeks);
        var O = I(G, "D"), Q = I(this.$d.hours, "H"), ee = I(this.$d.minutes, "M"), H = this.$d.seconds || 0;
        this.$d.milliseconds && (H += this.$d.milliseconds / 1e3);
        var D = I(H, "S"), R = M.negative || V.negative || O.negative || Q.negative || ee.negative || D.negative, Y = Q.format || ee.format || D.format ? "T" : "", P = (R ? "-" : "") + "P" + M.format + V.format + O.format + Y + Q.format + ee.format + D.format;
        return P === "P" || P === "-P" ? "P0D" : P;
      }, _.toJSON = function() {
        return this.toISOString();
      }, _.format = function(M) {
        var V = M || "YYYY-MM-DDTHH:mm:ss", G = { Y: this.$d.years, YY: r.s(this.$d.years, 2, "0"), YYYY: r.s(this.$d.years, 4, "0"), M: this.$d.months, MM: r.s(this.$d.months, 2, "0"), D: this.$d.days, DD: r.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: r.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: r.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: r.s(this.$d.seconds, 2, "0"), SSS: r.s(this.$d.milliseconds, 3, "0") };
        return V.replace(u, function(O, Q) {
          return Q || String(G[O]);
        });
      }, _.as = function(M) {
        return this.$ms / p[E(M)];
      }, _.get = function(M) {
        var V = this.$ms, G = E(M);
        return G === "milliseconds" ? V %= 1e3 : V = G === "weeks" ? N(V / p[G]) : this.$d[G], V === 0 ? 0 : V;
      }, _.add = function(M, V, G) {
        var O;
        return O = V ? M * p[E(V)] : b(M) ? M.$ms : v(M, this).$ms, v(this.$ms + O * (G ? -1 : 1), this);
      }, _.subtract = function(M, V) {
        return this.add(M, V, !0);
      }, _.locale = function(M) {
        var V = this.clone();
        return V.$l = M, V;
      }, _.clone = function() {
        return v(this.$ms, this);
      }, _.humanize = function(M) {
        return n().add(this.$ms, "ms").locale(this.$l).fromNow(!M);
      }, _.milliseconds = function() {
        return this.get("milliseconds");
      }, _.asMilliseconds = function() {
        return this.as("milliseconds");
      }, _.seconds = function() {
        return this.get("seconds");
      }, _.asSeconds = function() {
        return this.as("seconds");
      }, _.minutes = function() {
        return this.get("minutes");
      }, _.asMinutes = function() {
        return this.as("minutes");
      }, _.hours = function() {
        return this.get("hours");
      }, _.asHours = function() {
        return this.as("hours");
      }, _.days = function() {
        return this.get("days");
      }, _.asDays = function() {
        return this.as("days");
      }, _.weeks = function() {
        return this.get("weeks");
      }, _.asWeeks = function() {
        return this.as("weeks");
      }, _.months = function() {
        return this.get("months");
      }, _.asMonths = function() {
        return this.as("months");
      }, _.years = function() {
        return this.get("years");
      }, _.asYears = function() {
        return this.as("years");
      }, $;
    }();
    return function($, _, M) {
      n = M, r = M().$utils(), M.duration = function(O, Q) {
        var ee = M.locale();
        return v(O, { $l: ee }, Q);
      }, M.isDuration = b;
      var V = _.prototype.add, G = _.prototype.subtract;
      _.prototype.add = function(O, Q) {
        return b(O) && (O = O.asMilliseconds()), V.bind(this)(O, Q);
      }, _.prototype.subtract = function(O, Q) {
        return b(O) && (O = O.asMilliseconds()), G.bind(this)(O, Q);
      };
    };
  });
})(Nb);
var PR = Nb.exports;
const LR = /* @__PURE__ */ Ft(PR);
var Rb = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    return function(n, r, a) {
      var i = function(s, o) {
        if (!o || !o.length || !o[0] || o.length === 1 && !o[0].length)
          return null;
        var u;
        o.length === 1 && o[0].length > 0 && (o = o[0]), u = o[0];
        for (var l = 1; l < o.length; l += 1)
          o[l].isValid() && !o[l][s](u) || (u = o[l]);
        return u;
      };
      a.max = function() {
        var s = [].slice.call(arguments, 0);
        return i("isAfter", s);
      }, a.min = function() {
        var s = [].slice.call(arguments, 0);
        return i("isBefore", s);
      };
    };
  });
})(Rb);
var MR = Rb.exports;
const $R = /* @__PURE__ */ Ft(MR);
var kb = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    return function(n, r, a) {
      n = n || {};
      var i = r.prototype, s = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function o(l, f, h, p) {
        return i.fromToBase(l, f, h, p);
      }
      a.en.relativeTime = s, i.fromToBase = function(l, f, h, p, b) {
        for (var v, E, y, N = h.$locale().relativeTime || s, A = n.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], I = A.length, j = 0; j < I; j += 1) {
          var $ = A[j];
          $.d && (v = p ? a(l).diff(h, $.d, !0) : h.diff(l, $.d, !0));
          var _ = (n.rounding || Math.round)(Math.abs(v));
          if (y = v > 0, _ <= $.r || !$.r) {
            _ <= 1 && j > 0 && ($ = A[j - 1]);
            var M = N[$.l];
            b && (_ = b("" + _)), E = typeof M == "string" ? M.replace("%d", _) : M(_, f, $.l, y);
            break;
          }
        }
        if (f)
          return E;
        var V = y ? N.future : N.past;
        return typeof V == "function" ? V(E) : V.replace("%s", E);
      }, i.to = function(l, f) {
        return o(l, f, this, !0);
      }, i.from = function(l, f) {
        return o(l, f, this);
      };
      var u = function(l) {
        return l.$u ? a.utc() : a();
      };
      i.toNow = function(l) {
        return this.to(u(this), l);
      }, i.fromNow = function(l) {
        return this.from(u(this), l);
      };
    };
  });
})(kb);
var BR = kb.exports;
const FR = /* @__PURE__ */ Ft(BR);
var wb = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    return function(n, r, a) {
      a.updateLocale = function(i, s) {
        var o = a.Ls[i];
        if (o)
          return (s ? Object.keys(s) : []).forEach(function(u) {
            o[u] = s[u];
          }), o;
      };
    };
  });
})(wb);
var UR = wb.exports;
const HR = /* @__PURE__ */ Ft(UR);
var Db = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    var n = "minute", r = /[+-]\d\d(?::?\d\d)?/g, a = /([+-]|\d\d)/g;
    return function(i, s, o) {
      var u = s.prototype;
      o.utc = function(E) {
        var y = { date: E, utc: !0, args: arguments };
        return new s(y);
      }, u.utc = function(E) {
        var y = o(this.toDate(), { locale: this.$L, utc: !0 });
        return E ? y.add(this.utcOffset(), n) : y;
      }, u.local = function() {
        return o(this.toDate(), { locale: this.$L, utc: !1 });
      };
      var l = u.parse;
      u.parse = function(E) {
        E.utc && (this.$u = !0), this.$utils().u(E.$offset) || (this.$offset = E.$offset), l.call(this, E);
      };
      var f = u.init;
      u.init = function() {
        if (this.$u) {
          var E = this.$d;
          this.$y = E.getUTCFullYear(), this.$M = E.getUTCMonth(), this.$D = E.getUTCDate(), this.$W = E.getUTCDay(), this.$H = E.getUTCHours(), this.$m = E.getUTCMinutes(), this.$s = E.getUTCSeconds(), this.$ms = E.getUTCMilliseconds();
        } else
          f.call(this);
      };
      var h = u.utcOffset;
      u.utcOffset = function(E, y) {
        var N = this.$utils().u;
        if (N(E))
          return this.$u ? 0 : N(this.$offset) ? h.call(this) : this.$offset;
        if (typeof E == "string" && (E = function($) {
          $ === void 0 && ($ = "");
          var _ = $.match(r);
          if (!_)
            return null;
          var M = ("" + _[0]).match(a) || ["-", 0, 0], V = M[0], G = 60 * +M[1] + +M[2];
          return G === 0 ? 0 : V === "+" ? G : -G;
        }(E)) === null)
          return this;
        var A = Math.abs(E) <= 16 ? 60 * E : E, I = this;
        if (y)
          return I.$offset = A, I.$u = E === 0, I;
        if (E !== 0) {
          var j = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (I = this.local().add(A + j, n)).$offset = A, I.$x.$localOffset = j;
        } else
          I = this.utc();
        return I;
      };
      var p = u.format;
      u.format = function(E) {
        var y = E || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return p.call(this, y);
      }, u.valueOf = function() {
        var E = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || (/* @__PURE__ */ new Date()).getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * E;
      }, u.isUTC = function() {
        return !!this.$u;
      }, u.toISOString = function() {
        return this.toDate().toISOString();
      }, u.toString = function() {
        return this.toDate().toUTCString();
      };
      var b = u.toDate;
      u.toDate = function(E) {
        return E === "s" && this.$offset ? o(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : b.call(this);
      };
      var v = u.diff;
      u.diff = function(E, y, N) {
        if (E && this.$u === E.$u)
          return v.call(this, E, y, N);
        var A = this.local(), I = o(E).local();
        return v.call(A, I, y, N);
      };
    };
  });
})(Db);
var jR = Db.exports;
const zR = /* @__PURE__ */ Ft(jR);
la.extend(zR);
la.extend(LR);
la.extend(FR);
la.extend(DR);
la.extend($R);
la.extend(kR);
la.extend(HR);
la.updateLocale("en", {
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
  }
});
const VR = [
  {
    group: "US (Common)",
    zones: [
      {
        value: "US/Puerto_Rico",
        name: "Puerto Rico (Atlantic)"
      },
      {
        value: "US/New_York",
        name: "New York (Eastern)"
      },
      {
        value: "US/Chicago",
        name: "Chicago (Central)"
      },
      {
        value: "US/Denver",
        name: "Denver (Mountain)"
      },
      {
        value: "US/Phoenix",
        name: "Phoenix (MST)"
      },
      {
        value: "US/Los_Angeles",
        name: "Los Angeles (Pacific)"
      },
      {
        value: "US/Anchorage",
        name: "Anchorage (Alaska)"
      },
      {
        value: "America Pacific/Honolulu",
        name: "Honolulu (Hawaii)"
      }
    ]
  },
  {
    group: "America",
    zones: [
      {
        value: "America/Adak",
        name: "Adak"
      },
      {
        value: "America/Anchorage",
        name: "Anchorage"
      },
      {
        value: "America/Anguilla",
        name: "Anguilla"
      },
      {
        value: "America/Antigua",
        name: "Antigua"
      },
      {
        value: "America/Araguaina",
        name: "Araguaina"
      },
      {
        value: "America/Argentina/Buenos_Aires",
        name: "Argentina - Buenos Aires"
      },
      {
        value: "America/Argentina/Catamarca",
        name: "Argentina - Catamarca"
      },
      {
        value: "America/Argentina/ComodRivadavia",
        name: "Argentina - ComodRivadavia"
      },
      {
        value: "America/Argentina/Cordoba",
        name: "Argentina - Cordoba"
      },
      {
        value: "America/Argentina/Jujuy",
        name: "Argentina - Jujuy"
      },
      {
        value: "America/Argentina/La_Rioja",
        name: "Argentina - La Rioja"
      },
      {
        value: "America/Argentina/Mendoza",
        name: "Argentina - Mendoza"
      },
      {
        value: "America/Argentina/Rio_Gallegos",
        name: "Argentina - Rio Gallegos"
      },
      {
        value: "America/Argentina/Salta",
        name: "Argentina - Salta"
      },
      {
        value: "America/Argentina/San_Juan",
        name: "Argentina - San Juan"
      },
      {
        value: "America/Argentina/San_Luis",
        name: "Argentina - San Luis"
      },
      {
        value: "America/Argentina/Tucuman",
        name: "Argentina - Tucuman"
      },
      {
        value: "America/Argentina/Ushuaia",
        name: "Argentina - Ushuaia"
      },
      {
        value: "America/Aruba",
        name: "Aruba"
      },
      {
        value: "America/Asuncion",
        name: "Asuncion"
      },
      {
        value: "America/Atikokan",
        name: "Atikokan"
      },
      {
        value: "America/Atka",
        name: "Atka"
      },
      {
        value: "America/Bahia",
        name: "Bahia"
      },
      {
        value: "America/Barbados",
        name: "Barbados"
      },
      {
        value: "America/Belem",
        name: "Belem"
      },
      {
        value: "America/Belize",
        name: "Belize"
      },
      {
        value: "America/Blanc-Sablon",
        name: "Blanc-Sablon"
      },
      {
        value: "America/Boa_Vista",
        name: "Boa Vista"
      },
      {
        value: "America/Bogota",
        name: "Bogota"
      },
      {
        value: "America/Boise",
        name: "Boise"
      },
      {
        value: "America/Buenos_Aires",
        name: "Buenos Aires"
      },
      {
        value: "America/Cambridge_Bay",
        name: "Cambridge Bay"
      },
      {
        value: "America/Campo_Grande",
        name: "Campo Grande"
      },
      {
        value: "America/Cancun",
        name: "Cancun"
      },
      {
        value: "America/Caracas",
        name: "Caracas"
      },
      {
        value: "America/Catamarca",
        name: "Catamarca"
      },
      {
        value: "America/Cayenne",
        name: "Cayenne"
      },
      {
        value: "America/Cayman",
        name: "Cayman"
      },
      {
        value: "America/Chicago",
        name: "Chicago"
      },
      {
        value: "America/Chihuahua",
        name: "Chihuahua"
      },
      {
        value: "America/Coral_Harbour",
        name: "Coral Harbour"
      },
      {
        value: "America/Cordoba",
        name: "Cordoba"
      },
      {
        value: "America/Costa_Rica",
        name: "Costa Rica"
      },
      {
        value: "America/Cuiaba",
        name: "Cuiaba"
      },
      {
        value: "America/Curacao",
        name: "Curacao"
      },
      {
        value: "America/Danmarkshavn",
        name: "Danmarkshavn"
      },
      {
        value: "America/Dawson",
        name: "Dawson"
      },
      {
        value: "America/Dawson_Creek",
        name: "Dawson Creek"
      },
      {
        value: "America/Denver",
        name: "Denver"
      },
      {
        value: "America/Detroit",
        name: "Detroit"
      },
      {
        value: "America/Dominica",
        name: "Dominica"
      },
      {
        value: "America/Edmonton",
        name: "Edmonton"
      },
      {
        value: "America/Eirunepe",
        name: "Eirunepe"
      },
      {
        value: "America/El_Salvador",
        name: "El Salvador"
      },
      {
        value: "America/Ensenada",
        name: "Ensenada"
      },
      {
        value: "America/Fortaleza",
        name: "Fortaleza"
      },
      {
        value: "America/Fort_Wayne",
        name: "Fort Wayne"
      },
      {
        value: "America/Glace_Bay",
        name: "Glace Bay"
      },
      {
        value: "America/Godthab",
        name: "Godthab"
      },
      {
        value: "America/Goose_Bay",
        name: "Goose Bay"
      },
      {
        value: "America/Grand_Turk",
        name: "Grand Turk"
      },
      {
        value: "America/Grenada",
        name: "Grenada"
      },
      {
        value: "America/Guadeloupe",
        name: "Guadeloupe"
      },
      {
        value: "America/Guatemala",
        name: "Guatemala"
      },
      {
        value: "America/Guayaquil",
        name: "Guayaquil"
      },
      {
        value: "America/Guyana",
        name: "Guyana"
      },
      {
        value: "America/Halifax",
        name: "Halifax"
      },
      {
        value: "America/Havana",
        name: "Havana"
      },
      {
        value: "America/Hermosillo",
        name: "Hermosillo"
      },
      {
        value: "America/Indiana/Indianapolis",
        name: "Indiana - Indianapolis"
      },
      {
        value: "America/Indiana/Knox",
        name: "Indiana - Knox"
      },
      {
        value: "America/Indiana/Marengo",
        name: "Indiana - Marengo"
      },
      {
        value: "America/Indiana/Petersburg",
        name: "Indiana - Petersburg"
      },
      {
        value: "America/Indiana/Tell_City",
        name: "Indiana - Tell City"
      },
      {
        value: "America/Indiana/Vevay",
        name: "Indiana - Vevay"
      },
      {
        value: "America/Indiana/Vincennes",
        name: "Indiana - Vincennes"
      },
      {
        value: "America/Indiana/Winamac",
        name: "Indiana - Winamac"
      },
      {
        value: "America/Indianapolis",
        name: "Indianapolis"
      },
      {
        value: "America/Inuvik",
        name: "Inuvik"
      },
      {
        value: "America/Iqaluit",
        name: "Iqaluit"
      },
      {
        value: "America/Jamaica",
        name: "Jamaica"
      },
      {
        value: "America/Jujuy",
        name: "Jujuy"
      },
      {
        value: "America/Juneau",
        name: "Juneau"
      },
      {
        value: "America/Kentucky/Louisville",
        name: "Kentucky - Louisville"
      },
      {
        value: "America/Kentucky/Monticello",
        name: "Kentucky - Monticello"
      },
      {
        value: "America/Knox_IN",
        name: "Knox IN"
      },
      {
        value: "America/La_Paz",
        name: "La Paz"
      },
      {
        value: "America/Lima",
        name: "Lima"
      },
      {
        value: "America/Los_Angeles",
        name: "Los Angeles"
      },
      {
        value: "America/Louisville",
        name: "Louisville"
      },
      {
        value: "America/Maceio",
        name: "Maceio"
      },
      {
        value: "America/Managua",
        name: "Managua"
      },
      {
        value: "America/Manaus",
        name: "Manaus"
      },
      {
        value: "America/Marigot",
        name: "Marigot"
      },
      {
        value: "America/Martinique",
        name: "Martinique"
      },
      {
        value: "America/Matamoros",
        name: "Matamoros"
      },
      {
        value: "America/Mazatlan",
        name: "Mazatlan"
      },
      {
        value: "America/Mendoza",
        name: "Mendoza"
      },
      {
        value: "America/Menominee",
        name: "Menominee"
      },
      {
        value: "America/Merida",
        name: "Merida"
      },
      {
        value: "America/Mexico_City",
        name: "Mexico City"
      },
      {
        value: "America/Miquelon",
        name: "Miquelon"
      },
      {
        value: "America/Moncton",
        name: "Moncton"
      },
      {
        value: "America/Monterrey",
        name: "Monterrey"
      },
      {
        value: "America/Montevideo",
        name: "Montevideo"
      },
      {
        value: "America/Montreal",
        name: "Montreal"
      },
      {
        value: "America/Montserrat",
        name: "Montserrat"
      },
      {
        value: "America/Nassau",
        name: "Nassau"
      },
      {
        value: "America/New_York",
        name: "New York"
      },
      {
        value: "America/Nipigon",
        name: "Nipigon"
      },
      {
        value: "America/Nome",
        name: "Nome"
      },
      {
        value: "America/Noronha",
        name: "Noronha"
      },
      {
        value: "America/North_Dakota/Center",
        name: "North Dakota - Center"
      },
      {
        value: "America/North_Dakota/New_Salem",
        name: "North Dakota - New Salem"
      },
      {
        value: "America/Ojinaga",
        name: "Ojinaga"
      },
      {
        value: "America/Panama",
        name: "Panama"
      },
      {
        value: "America/Pangnirtung",
        name: "Pangnirtung"
      },
      {
        value: "America/Paramaribo",
        name: "Paramaribo"
      },
      {
        value: "America/Phoenix",
        name: "Phoenix"
      },
      {
        value: "America/Port-au-Prince",
        name: "Port-au-Prince"
      },
      {
        value: "America/Porto_Acre",
        name: "Porto Acre"
      },
      {
        value: "America/Port_of_Spain",
        name: "Port of Spain"
      },
      {
        value: "America/Porto_Velho",
        name: "Porto Velho"
      },
      {
        value: "America/Puerto_Rico",
        name: "Puerto Rico"
      },
      {
        value: "America/Rainy_River",
        name: "Rainy River"
      },
      {
        value: "America/Rankin_Inlet",
        name: "Rankin Inlet"
      },
      {
        value: "America/Recife",
        name: "Recife"
      },
      {
        value: "America/Regina",
        name: "Regina"
      },
      {
        value: "America/Resolute",
        name: "Resolute"
      },
      {
        value: "America/Rio_Branco",
        name: "Rio Branco"
      },
      {
        value: "America/Rosario",
        name: "Rosario"
      },
      {
        value: "America/Santa_Isabel",
        name: "Santa Isabel"
      },
      {
        value: "America/Santarem",
        name: "Santarem"
      },
      {
        value: "America/Santiago",
        name: "Santiago"
      },
      {
        value: "America/Santo_Domingo",
        name: "Santo Domingo"
      },
      {
        value: "America/Sao_Paulo",
        name: "Sao Paulo"
      },
      {
        value: "America/Scoresbysund",
        name: "Scoresbysund"
      },
      {
        value: "America/Shiprock",
        name: "Shiprock"
      },
      {
        value: "America/St_Barthelemy",
        name: "St Barthelemy"
      },
      {
        value: "America/St_Johns",
        name: "St Johns"
      },
      {
        value: "America/St_Kitts",
        name: "St Kitts"
      },
      {
        value: "America/St_Lucia",
        name: "St Lucia"
      },
      {
        value: "America/St_Thomas",
        name: "St Thomas"
      },
      {
        value: "America/St_Vincent",
        name: "St Vincent"
      },
      {
        value: "America/Swift_Current",
        name: "Swift Current"
      },
      {
        value: "America/Tegucigalpa",
        name: "Tegucigalpa"
      },
      {
        value: "America/Thule",
        name: "Thule"
      },
      {
        value: "America/Thunder_Bay",
        name: "Thunder Bay"
      },
      {
        value: "America/Tijuana",
        name: "Tijuana"
      },
      {
        value: "America/Toronto",
        name: "Toronto"
      },
      {
        value: "America/Tortola",
        name: "Tortola"
      },
      {
        value: "America/Vancouver",
        name: "Vancouver"
      },
      {
        value: "America/Virgin",
        name: "Virgin"
      },
      {
        value: "America/Whitehorse",
        name: "Whitehorse"
      },
      {
        value: "America/Winnipeg",
        name: "Winnipeg"
      },
      {
        value: "America/Yakutat",
        name: "Yakutat"
      },
      {
        value: "America/Yellowknife",
        name: "Yellowknife"
      }
    ]
  },
  {
    group: "Europe",
    zones: [
      {
        value: "Europe/Amsterdam",
        name: "Amsterdam"
      },
      {
        value: "Europe/Andorra",
        name: "Andorra"
      },
      {
        value: "Europe/Athens",
        name: "Athens"
      },
      {
        value: "Europe/Belfast",
        name: "Belfast"
      },
      {
        value: "Europe/Belgrade",
        name: "Belgrade"
      },
      {
        value: "Europe/Berlin",
        name: "Berlin"
      },
      {
        value: "Europe/Bratislava",
        name: "Bratislava"
      },
      {
        value: "Europe/Brussels",
        name: "Brussels"
      },
      {
        value: "Europe/Bucharest",
        name: "Bucharest"
      },
      {
        value: "Europe/Budapest",
        name: "Budapest"
      },
      {
        value: "Europe/Chisinau",
        name: "Chisinau"
      },
      {
        value: "Europe/Copenhagen",
        name: "Copenhagen"
      },
      {
        value: "Europe/Dublin",
        name: "Dublin"
      },
      {
        value: "Europe/Gibraltar",
        name: "Gibraltar"
      },
      {
        value: "Europe/Guernsey",
        name: "Guernsey"
      },
      {
        value: "Europe/Helsinki",
        name: "Helsinki"
      },
      {
        value: "Europe/Isle_of_Man",
        name: "Isle of Man"
      },
      {
        value: "Europe/Istanbul",
        name: "Istanbul"
      },
      {
        value: "Europe/Jersey",
        name: "Jersey"
      },
      {
        value: "Europe/Kaliningrad",
        name: "Kaliningrad"
      },
      {
        value: "Europe/Kiev",
        name: "Kiev"
      },
      {
        value: "Europe/Lisbon",
        name: "Lisbon"
      },
      {
        value: "Europe/Ljubljana",
        name: "Ljubljana"
      },
      {
        value: "Europe/London",
        name: "London"
      },
      {
        value: "Europe/Luxembourg",
        name: "Luxembourg"
      },
      {
        value: "Europe/Madrid",
        name: "Madrid"
      },
      {
        value: "Europe/Malta",
        name: "Malta"
      },
      {
        value: "Europe/Mariehamn",
        name: "Mariehamn"
      },
      {
        value: "Europe/Minsk",
        name: "Minsk"
      },
      {
        value: "Europe/Monaco",
        name: "Monaco"
      },
      {
        value: "Europe/Moscow",
        name: "Moscow"
      },
      {
        value: "Europe/Nicosia",
        name: "Nicosia"
      },
      {
        value: "Europe/Oslo",
        name: "Oslo"
      },
      {
        value: "Europe/Paris",
        name: "Paris"
      },
      {
        value: "Europe/Podgorica",
        name: "Podgorica"
      },
      {
        value: "Europe/Prague",
        name: "Prague"
      },
      {
        value: "Europe/Riga",
        name: "Riga"
      },
      {
        value: "Europe/Rome",
        name: "Rome"
      },
      {
        value: "Europe/Samara",
        name: "Samara"
      },
      {
        value: "Europe/San_Marino",
        name: "San Marino"
      },
      {
        value: "Europe/Sarajevo",
        name: "Sarajevo"
      },
      {
        value: "Europe/Simferopol",
        name: "Simferopol"
      },
      {
        value: "Europe/Skopje",
        name: "Skopje"
      },
      {
        value: "Europe/Sofia",
        name: "Sofia"
      },
      {
        value: "Europe/Stockholm",
        name: "Stockholm"
      },
      {
        value: "Europe/Tallinn",
        name: "Tallinn"
      },
      {
        value: "Europe/Tirane",
        name: "Tirane"
      },
      {
        value: "Europe/Tiraspol",
        name: "Tiraspol"
      },
      {
        value: "Europe/Uzhgorod",
        name: "Uzhgorod"
      },
      {
        value: "Europe/Vaduz",
        name: "Vaduz"
      },
      {
        value: "Europe/Vatican",
        name: "Vatican"
      },
      {
        value: "Europe/Vienna",
        name: "Vienna"
      },
      {
        value: "Europe/Vilnius",
        name: "Vilnius"
      },
      {
        value: "Europe/Volgograd",
        name: "Volgograd"
      },
      {
        value: "Europe/Warsaw",
        name: "Warsaw"
      },
      {
        value: "Europe/Zagreb",
        name: "Zagreb"
      },
      {
        value: "Europe/Zaporozhye",
        name: "Zaporozhye"
      },
      {
        value: "Europe/Zurich",
        name: "Zurich"
      }
    ]
  },
  {
    group: "Asia",
    zones: [
      {
        value: "Asia/Aden",
        name: "Aden"
      },
      {
        value: "Asia/Almaty",
        name: "Almaty"
      },
      {
        value: "Asia/Amman",
        name: "Amman"
      },
      {
        value: "Asia/Anadyr",
        name: "Anadyr"
      },
      {
        value: "Asia/Aqtau",
        name: "Aqtau"
      },
      {
        value: "Asia/Aqtobe",
        name: "Aqtobe"
      },
      {
        value: "Asia/Ashgabat",
        name: "Ashgabat"
      },
      {
        value: "Asia/Ashkhabad",
        name: "Ashkhabad"
      },
      {
        value: "Asia/Baghdad",
        name: "Baghdad"
      },
      {
        value: "Asia/Bahrain",
        name: "Bahrain"
      },
      {
        value: "Asia/Baku",
        name: "Baku"
      },
      {
        value: "Asia/Bangkok",
        name: "Bangkok"
      },
      {
        value: "Asia/Beirut",
        name: "Beirut"
      },
      {
        value: "Asia/Bishkek",
        name: "Bishkek"
      },
      {
        value: "Asia/Brunei",
        name: "Brunei"
      },
      {
        value: "Asia/Calcutta",
        name: "Calcutta"
      },
      {
        value: "Asia/Choibalsan",
        name: "Choibalsan"
      },
      {
        value: "Asia/Chongqing",
        name: "Chongqing"
      },
      {
        value: "Asia/Chungking",
        name: "Chungking"
      },
      {
        value: "Asia/Colombo",
        name: "Colombo"
      },
      {
        value: "Asia/Dacca",
        name: "Dacca"
      },
      {
        value: "Asia/Damascus",
        name: "Damascus"
      },
      {
        value: "Asia/Dhaka",
        name: "Dhaka"
      },
      {
        value: "Asia/Dili",
        name: "Dili"
      },
      {
        value: "Asia/Dubai",
        name: "Dubai"
      },
      {
        value: "Asia/Dushanbe",
        name: "Dushanbe"
      },
      {
        value: "Asia/Gaza",
        name: "Gaza"
      },
      {
        value: "Asia/Harbin",
        name: "Harbin"
      },
      {
        value: "Asia/Ho_Chi_Minh",
        name: "Ho Chi Minh"
      },
      {
        value: "Asia/Hong_Kong",
        name: "Hong Kong"
      },
      {
        value: "Asia/Hovd",
        name: "Hovd"
      },
      {
        value: "Asia/Irkutsk",
        name: "Irkutsk"
      },
      {
        value: "Asia/Istanbul",
        name: "Istanbul"
      },
      {
        value: "Asia/Jakarta",
        name: "Jakarta"
      },
      {
        value: "Asia/Jayapura",
        name: "Jayapura"
      },
      {
        value: "Asia/Jerusalem",
        name: "Jerusalem"
      },
      {
        value: "Asia/Kabul",
        name: "Kabul"
      },
      {
        value: "Asia/Kamchatka",
        name: "Kamchatka"
      },
      {
        value: "Asia/Karachi",
        name: "Karachi"
      },
      {
        value: "Asia/Kashgar",
        name: "Kashgar"
      },
      {
        value: "Asia/Kathmandu",
        name: "Kathmandu"
      },
      {
        value: "Asia/Katmandu",
        name: "Katmandu"
      },
      {
        value: "Asia/Kolkata",
        name: "Kolkata"
      },
      {
        value: "Asia/Krasnoyarsk",
        name: "Krasnoyarsk"
      },
      {
        value: "Asia/Kuala_Lumpur",
        name: "Kuala Lumpur"
      },
      {
        value: "Asia/Kuching",
        name: "Kuching"
      },
      {
        value: "Asia/Kuwait",
        name: "Kuwait"
      },
      {
        value: "Asia/Macao",
        name: "Macao"
      },
      {
        value: "Asia/Macau",
        name: "Macau"
      },
      {
        value: "Asia/Magadan",
        name: "Magadan"
      },
      {
        value: "Asia/Makassar",
        name: "Makassar"
      },
      {
        value: "Asia/Manila",
        name: "Manila"
      },
      {
        value: "Asia/Muscat",
        name: "Muscat"
      },
      {
        value: "Asia/Nicosia",
        name: "Nicosia"
      },
      {
        value: "Asia/Novokuznetsk",
        name: "Novokuznetsk"
      },
      {
        value: "Asia/Novosibirsk",
        name: "Novosibirsk"
      },
      {
        value: "Asia/Omsk",
        name: "Omsk"
      },
      {
        value: "Asia/Oral",
        name: "Oral"
      },
      {
        value: "Asia/Phnom_Penh",
        name: "Phnom Penh"
      },
      {
        value: "Asia/Pontianak",
        name: "Pontianak"
      },
      {
        value: "Asia/Pyongyang",
        name: "Pyongyang"
      },
      {
        value: "Asia/Qatar",
        name: "Qatar"
      },
      {
        value: "Asia/Qyzylorda",
        name: "Qyzylorda"
      },
      {
        value: "Asia/Rangoon",
        name: "Rangoon"
      },
      {
        value: "Asia/Riyadh",
        name: "Riyadh"
      },
      {
        value: "Asia/Saigon",
        name: "Saigon"
      },
      {
        value: "Asia/Sakhalin",
        name: "Sakhalin"
      },
      {
        value: "Asia/Samarkand",
        name: "Samarkand"
      },
      {
        value: "Asia/Seoul",
        name: "Seoul"
      },
      {
        value: "Asia/Shanghai",
        name: "Shanghai"
      },
      {
        value: "Asia/Singapore",
        name: "Singapore"
      },
      {
        value: "Asia/Taipei",
        name: "Taipei"
      },
      {
        value: "Asia/Tashkent",
        name: "Tashkent"
      },
      {
        value: "Asia/Tbilisi",
        name: "Tbilisi"
      },
      {
        value: "Asia/Tehran",
        name: "Tehran"
      },
      {
        value: "Asia/Tel_Aviv",
        name: "Tel Aviv"
      },
      {
        value: "Asia/Thimbu",
        name: "Thimbu"
      },
      {
        value: "Asia/Thimphu",
        name: "Thimphu"
      },
      {
        value: "Asia/Tokyo",
        name: "Tokyo"
      },
      {
        value: "Asia/Ujung_Pandang",
        name: "Ujung Pandang"
      },
      {
        value: "Asia/Ulaanbaatar",
        name: "Ulaanbaatar"
      },
      {
        value: "Asia/Ulan_Bator",
        name: "Ulan Bator"
      },
      {
        value: "Asia/Urumqi",
        name: "Urumqi"
      },
      {
        value: "Asia/Vientiane",
        name: "Vientiane"
      },
      {
        value: "Asia/Vladivostok",
        name: "Vladivostok"
      },
      {
        value: "Asia/Yakutsk",
        name: "Yakutsk"
      },
      {
        value: "Asia/Yekaterinburg",
        name: "Yekaterinburg"
      },
      {
        value: "Asia/Yerevan",
        name: "Yerevan"
      }
    ]
  },
  {
    group: "Africa",
    zones: [
      {
        value: "Africa/Abidjan",
        name: "Abidjan"
      },
      {
        value: "Africa/Accra",
        name: "Accra"
      },
      {
        value: "Africa/Addis_Ababa",
        name: "Addis Ababa"
      },
      {
        value: "Africa/Algiers",
        name: "Algiers"
      },
      {
        value: "Africa/Asmara",
        name: "Asmara"
      },
      {
        value: "Africa/Asmera",
        name: "Asmera"
      },
      {
        value: "Africa/Bamako",
        name: "Bamako"
      },
      {
        value: "Africa/Bangui",
        name: "Bangui"
      },
      {
        value: "Africa/Banjul",
        name: "Banjul"
      },
      {
        value: "Africa/Bissau",
        name: "Bissau"
      },
      {
        value: "Africa/Blantyre",
        name: "Blantyre"
      },
      {
        value: "Africa/Brazzaville",
        name: "Brazzaville"
      },
      {
        value: "Africa/Bujumbura",
        name: "Bujumbura"
      },
      {
        value: "Africa/Cairo",
        name: "Cairo"
      },
      {
        value: "Africa/Casablanca",
        name: "Casablanca"
      },
      {
        value: "Africa/Ceuta",
        name: "Ceuta"
      },
      {
        value: "Africa/Conakry",
        name: "Conakry"
      },
      {
        value: "Africa/Dakar",
        name: "Dakar"
      },
      {
        value: "Africa/Dar_es_Salaam",
        name: "Dar es Salaam"
      },
      {
        value: "Africa/Djibouti",
        name: "Djibouti"
      },
      {
        value: "Africa/Douala",
        name: "Douala"
      },
      {
        value: "Africa/El_Aaiun",
        name: "El Aaiun"
      },
      {
        value: "Africa/Freetown",
        name: "Freetown"
      },
      {
        value: "Africa/Gaborone",
        name: "Gaborone"
      },
      {
        value: "Africa/Harare",
        name: "Harare"
      },
      {
        value: "Africa/Johannesburg",
        name: "Johannesburg"
      },
      {
        value: "Africa/Kampala",
        name: "Kampala"
      },
      {
        value: "Africa/Khartoum",
        name: "Khartoum"
      },
      {
        value: "Africa/Kigali",
        name: "Kigali"
      },
      {
        value: "Africa/Kinshasa",
        name: "Kinshasa"
      },
      {
        value: "Africa/Lagos",
        name: "Lagos"
      },
      {
        value: "Africa/Libreville",
        name: "Libreville"
      },
      {
        value: "Africa/Lome",
        name: "Lome"
      },
      {
        value: "Africa/Luanda",
        name: "Luanda"
      },
      {
        value: "Africa/Lubumbashi",
        name: "Lubumbashi"
      },
      {
        value: "Africa/Lusaka",
        name: "Lusaka"
      },
      {
        value: "Africa/Malabo",
        name: "Malabo"
      },
      {
        value: "Africa/Maputo",
        name: "Maputo"
      },
      {
        value: "Africa/Maseru",
        name: "Maseru"
      },
      {
        value: "Africa/Mbabane",
        name: "Mbabane"
      },
      {
        value: "Africa/Mogadishu",
        name: "Mogadishu"
      },
      {
        value: "Africa/Monrovia",
        name: "Monrovia"
      },
      {
        value: "Africa/Nairobi",
        name: "Nairobi"
      },
      {
        value: "Africa/Ndjamena",
        name: "Ndjamena"
      },
      {
        value: "Africa/Niamey",
        name: "Niamey"
      },
      {
        value: "Africa/Nouakchott",
        name: "Nouakchott"
      },
      {
        value: "Africa/Ouagadougou",
        name: "Ouagadougou"
      },
      {
        value: "Africa/Porto-Novo",
        name: "Porto-Novo"
      },
      {
        value: "Africa/Sao_Tome",
        name: "Sao Tome"
      },
      {
        value: "Africa/Timbuktu",
        name: "Timbuktu"
      },
      {
        value: "Africa/Tripoli",
        name: "Tripoli"
      },
      {
        value: "Africa/Tunis",
        name: "Tunis"
      },
      {
        value: "Africa/Windhoek",
        name: "Windhoek"
      }
    ]
  },
  {
    group: "Australia",
    zones: [
      {
        value: "Australia/ACT",
        name: "ACT"
      },
      {
        value: "Australia/Adelaide",
        name: "Adelaide"
      },
      {
        value: "Australia/Brisbane",
        name: "Brisbane"
      },
      {
        value: "Australia/Broken_Hill",
        name: "Broken Hill"
      },
      {
        value: "Australia/Canberra",
        name: "Canberra"
      },
      {
        value: "Australia/Currie",
        name: "Currie"
      },
      {
        value: "Australia/Darwin",
        name: "Darwin"
      },
      {
        value: "Australia/Eucla",
        name: "Eucla"
      },
      {
        value: "Australia/Hobart",
        name: "Hobart"
      },
      {
        value: "Australia/LHI",
        name: "LHI"
      },
      {
        value: "Australia/Lindeman",
        name: "Lindeman"
      },
      {
        value: "Australia/Lord_Howe",
        name: "Lord Howe"
      },
      {
        value: "Australia/Melbourne",
        name: "Melbourne"
      },
      {
        value: "Australia/North",
        name: "North"
      },
      {
        value: "Australia/NSW",
        name: "NSW"
      },
      {
        value: "Australia/Perth",
        name: "Perth"
      },
      {
        value: "Australia/Queensland",
        name: "Queensland"
      },
      {
        value: "Australia/South",
        name: "South"
      },
      {
        value: "Australia/Sydney",
        name: "Sydney"
      },
      {
        value: "Australia/Tasmania",
        name: "Tasmania"
      },
      {
        value: "Australia/Victoria",
        name: "Victoria"
      },
      {
        value: "Australia/West",
        name: "West"
      },
      {
        value: "Australia/Yancowinna",
        name: "Yancowinna"
      }
    ]
  },
  {
    group: "Indian",
    zones: [
      {
        value: "Indian/Antananarivo",
        name: "Antananarivo"
      },
      {
        value: "Indian/Chagos",
        name: "Chagos"
      },
      {
        value: "Indian/Christmas",
        name: "Christmas"
      },
      {
        value: "Indian/Cocos",
        name: "Cocos"
      },
      {
        value: "Indian/Comoro",
        name: "Comoro"
      },
      {
        value: "Indian/Kerguelen",
        name: "Kerguelen"
      },
      {
        value: "Indian/Mahe",
        name: "Mahe"
      },
      {
        value: "Indian/Maldives",
        name: "Maldives"
      },
      {
        value: "Indian/Mauritius",
        name: "Mauritius"
      },
      {
        value: "Indian/Mayotte",
        name: "Mayotte"
      },
      {
        value: "Indian/Reunion",
        name: "Reunion"
      }
    ]
  },
  {
    group: "Atlantic",
    zones: [
      {
        value: "Atlantic/Azores",
        name: "Azores"
      },
      {
        value: "Atlantic/Bermuda",
        name: "Bermuda"
      },
      {
        value: "Atlantic/Canary",
        name: "Canary"
      },
      {
        value: "Atlantic/Cape_Verde",
        name: "Cape Verde"
      },
      {
        value: "Atlantic/Faeroe",
        name: "Faeroe"
      },
      {
        value: "Atlantic/Faroe",
        name: "Faroe"
      },
      {
        value: "Atlantic/Jan_Mayen",
        name: "Jan Mayen"
      },
      {
        value: "Atlantic/Madeira",
        name: "Madeira"
      },
      {
        value: "Atlantic/Reykjavik",
        name: "Reykjavik"
      },
      {
        value: "Atlantic/South_Georgia",
        name: "South Georgia"
      },
      {
        value: "Atlantic/Stanley",
        name: "Stanley"
      },
      {
        value: "Atlantic/St_Helena",
        name: "St Helena"
      }
    ]
  },
  {
    group: "Pacific",
    zones: [
      {
        value: "Pacific/Apia",
        name: "Apia"
      },
      {
        value: "Pacific/Auckland",
        name: "Auckland"
      },
      {
        value: "Pacific/Chatham",
        name: "Chatham"
      },
      {
        value: "Pacific/Easter",
        name: "Easter"
      },
      {
        value: "Pacific/Efate",
        name: "Efate"
      },
      {
        value: "Pacific/Enderbury",
        name: "Enderbury"
      },
      {
        value: "Pacific/Fakaofo",
        name: "Fakaofo"
      },
      {
        value: "Pacific/Fiji",
        name: "Fiji"
      },
      {
        value: "Pacific/Funafuti",
        name: "Funafuti"
      },
      {
        value: "Pacific/Galapagos",
        name: "Galapagos"
      },
      {
        value: "Pacific/Gambier",
        name: "Gambier"
      },
      {
        value: "Pacific/Guadalcanal",
        name: "Guadalcanal"
      },
      {
        value: "Pacific/Guam",
        name: "Guam"
      },
      {
        value: "Pacific/Honolulu",
        name: "Honolulu"
      },
      {
        value: "Pacific/Johnston",
        name: "Johnston"
      },
      {
        value: "Pacific/Kiritimati",
        name: "Kiritimati"
      },
      {
        value: "Pacific/Kosrae",
        name: "Kosrae"
      },
      {
        value: "Pacific/Kwajalein",
        name: "Kwajalein"
      },
      {
        value: "Pacific/Majuro",
        name: "Majuro"
      },
      {
        value: "Pacific/Marquesas",
        name: "Marquesas"
      },
      {
        value: "Pacific/Midway",
        name: "Midway"
      },
      {
        value: "Pacific/Nauru",
        name: "Nauru"
      },
      {
        value: "Pacific/Niue",
        name: "Niue"
      },
      {
        value: "Pacific/Norfolk",
        name: "Norfolk"
      },
      {
        value: "Pacific/Noumea",
        name: "Noumea"
      },
      {
        value: "Pacific/Pago_Pago",
        name: "Pago Pago"
      },
      {
        value: "Pacific/Palau",
        name: "Palau"
      },
      {
        value: "Pacific/Pitcairn",
        name: "Pitcairn"
      },
      {
        value: "Pacific/Ponape",
        name: "Ponape"
      },
      {
        value: "Pacific/Port_Moresby",
        name: "Port Moresby"
      },
      {
        value: "Pacific/Rarotonga",
        name: "Rarotonga"
      },
      {
        value: "Pacific/Saipan",
        name: "Saipan"
      },
      {
        value: "Pacific/Samoa",
        name: "Samoa"
      },
      {
        value: "Pacific/Tahiti",
        name: "Tahiti"
      },
      {
        value: "Pacific/Tarawa",
        name: "Tarawa"
      },
      {
        value: "Pacific/Tongatapu",
        name: "Tongatapu"
      },
      {
        value: "Pacific/Truk",
        name: "Truk"
      },
      {
        value: "Pacific/Wake",
        name: "Wake"
      },
      {
        value: "Pacific/Wallis",
        name: "Wallis"
      },
      {
        value: "Pacific/Yap",
        name: "Yap"
      }
    ]
  },
  {
    group: "Antarctica",
    zones: [
      {
        value: "Antarctica/Casey",
        name: "Casey"
      },
      {
        value: "Antarctica/Davis",
        name: "Davis"
      },
      {
        value: "Antarctica/DumontDUrville",
        name: "DumontDUrville"
      },
      {
        value: "Antarctica/Macquarie",
        name: "Macquarie"
      },
      {
        value: "Antarctica/Mawson",
        name: "Mawson"
      },
      {
        value: "Antarctica/McMurdo",
        name: "McMurdo"
      },
      {
        value: "Antarctica/Palmer",
        name: "Palmer"
      },
      {
        value: "Antarctica/Rothera",
        name: "Rothera"
      },
      {
        value: "Antarctica/South_Pole",
        name: "South Pole"
      },
      {
        value: "Antarctica/Syowa",
        name: "Syowa"
      },
      {
        value: "Antarctica/Vostok",
        name: "Vostok"
      }
    ]
  },
  {
    group: "Arctic",
    zones: [
      {
        value: "Arctic/Longyearbyen",
        name: "Longyearbyen"
      }
    ]
  },
  {
    group: "UTC",
    zones: [
      {
        value: "UTC",
        name: "UTC"
      }
    ]
  },
  {
    group: "Manual Offsets",
    zones: [
      {
        value: "UTC-12",
        name: "UTC-12"
      },
      {
        value: "UTC-11",
        name: "UTC-11"
      },
      {
        value: "UTC-10",
        name: "UTC-10"
      },
      {
        value: "UTC-9",
        name: "UTC-9"
      },
      {
        value: "UTC-8",
        name: "UTC-8"
      },
      {
        value: "UTC-7",
        name: "UTC-7"
      },
      {
        value: "UTC-6",
        name: "UTC-6"
      },
      {
        value: "UTC-5",
        name: "UTC-5"
      },
      {
        value: "UTC-4",
        name: "UTC-4"
      },
      {
        value: "UTC-3",
        name: "UTC-3"
      },
      {
        value: "UTC-2",
        name: "UTC-2"
      },
      {
        value: "UTC-1",
        name: "UTC-1"
      },
      {
        value: "UTC+0",
        name: "UTC+0"
      },
      {
        value: "UTC+1",
        name: "UTC+1"
      },
      {
        value: "UTC+2",
        name: "UTC+2"
      },
      {
        value: "UTC+3",
        name: "UTC+3"
      },
      {
        value: "UTC+4",
        name: "UTC+4"
      },
      {
        value: "UTC+5",
        name: "UTC+5"
      },
      {
        value: "UTC+6",
        name: "UTC+6"
      },
      {
        value: "UTC+7",
        name: "UTC+7"
      },
      {
        value: "UTC+8",
        name: "UTC+8"
      },
      {
        value: "UTC+9",
        name: "UTC+9"
      },
      {
        value: "UTC+10",
        name: "UTC+10"
      },
      {
        value: "UTC+11",
        name: "UTC+11"
      },
      {
        value: "UTC+12",
        name: "UTC+12"
      },
      {
        value: "UTC+13",
        name: "UTC+13"
      },
      {
        value: "UTC+14",
        name: "UTC+14"
      }
    ]
  }
], GR = () => VR.flatMap((e) => e.zones.map((t) => t.value));
GR();
const YR = () => (e) => (t) => !!t && (Array.isArray(e) ? e.includes(t) : e === t), Pb = () => (e) => (t) => Array.isArray(e) ? e.includes(t.type) : t.type === e, Tt = Pb(), WR = (e) => KI(e, "_v") && e._v === 1, qR = Tt(re.IF), KR = Tt(re.URL), XR = Tt(re.SET), ZR = Tt(re.TEXT), QR = Tt(re.GOTO), JR = Tt(re.CARD), ek = Tt(re.IF_V2), tk = Tt(re.FLOW), nk = Tt(re.CODE), rk = Tt(re.EXIT), ak = Tt(re.SPEAK), ik = Tt(re.START), sk = Tt(re.SET_V2), ok = Tt(re.VISUAL), uk = Tt(re.STREAM), lk = Tt(re.RANDOM), ck = Tt(re.CARD_V2), fk = Tt(re.CAPTURE), dk = Tt(re.GENERAL), hk = Tt(re.CAROUSEL), mk = Tt(re.RANDOM_V2), pk = Tt(re.GOTO_NODE), gk = Tt(re.DIRECTIVE), bk = Tt(re.CAPTURE_V2), Ek = Tt(re.INTERACTION), vk = Tt(re.INTEGRATIONS), Tk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createNodeTypeguard: Tt,
  isCapture: fk,
  isCaptureV2: bk,
  isCard: JR,
  isCardV2: ck,
  isCarousel: hk,
  isCode: nk,
  isDirective: gk,
  isExit: rk,
  isFlow: tk,
  isGeneral: dk,
  isGoTo: QR,
  isGoToNode: pk,
  isIf: qR,
  isIfV2: ek,
  isIntegrations: vk,
  isInteraction: Ek,
  isRandom: lk,
  isRandomV2: mk,
  isSet: XR,
  isSetV2: sk,
  isSpeak: ak,
  isStart: ik,
  isStream: uk,
  isText: ZR,
  isUrl: KR,
  isV1: WR,
  isVisual: ok
}, Symbol.toStringTag, { value: "Module" })), rt = YR(), Ak = rt(re.IF), _k = rt(re.URL), yk = rt(re.SET), Sk = rt(re.API), Ck = rt(re.GOTO), Ok = rt(re.TEXT), Ik = rt(re.CARD), xk = rt(re.IF_V2), Nk = rt(re.FLOW), Rk = rt(re.CODE), kk = rt(re.EXIT), wk = rt(re.SPEAK), Dk = rt(re.START), Pk = rt(re.SET_V2), Lk = rt(re.CAROUSEL), Mk = rt(re.PROMPT), $k = rt(re.VISUAL), Bk = rt(re.INTENT), Fk = rt(re.STREAM), Uk = rt(re.ZAPIER), Hk = rt(re.RANDOM), jk = rt(re.RANDOM_V2), zk = rt(re.COMMAND), Vk = rt(re.BUTTONS), Gk = rt(re.CAPTURE), Yk = rt(re.GENERAL), Wk = rt(re.GOTO_NODE), qk = rt(re.DIRECTIVE), Kk = rt(re.COMPONENT), Xk = rt(re.CAPTURE_V2), Zk = rt(re.GOTO_DOMAIN), Qk = rt(re.DEPRECATED), Jk = rt(re.INTERACTION), ew = rt(re.INTEGRATIONS), tw = rt(re.GOOGLE_SHEETS), nw = rt(sb), rw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createNodeTypeTypeguard: rt,
  isApi: Sk,
  isButtons: Vk,
  isCapture: Gk,
  isCaptureV2: Xk,
  isCard: Ik,
  isCarousel: Lk,
  isCode: Rk,
  isCommand: zk,
  isComponent: Kk,
  isDeprecated: Qk,
  isDirective: qk,
  isExit: kk,
  isFlow: Nk,
  isGeneral: Yk,
  isGoTo: Ck,
  isGoToDomain: Zk,
  isGoToNode: Wk,
  isGoogleSheets: tw,
  isIf: Ak,
  isIfV2: xk,
  isIntegrations: ew,
  isIntent: Bk,
  isInteraction: Jk,
  isPrompt: Mk,
  isRandom: Hk,
  isRandomV2: jk,
  isRuntimeOnly: nw,
  isSet: yk,
  isSetV2: Pk,
  isSpeak: wk,
  isStart: Dk,
  isStream: Fk,
  isText: Ok,
  isUrl: _k,
  isVisual: $k,
  isZapier: Uk
}, Symbol.toStringTag, { value: "Module" })), We = Pb(), aw = We(re.IF), iw = We(re.URL), sw = We(re.SET), ow = We(re.API), uw = We(re.TEXT), lw = We(re.CARD), cw = We(re.CARD_V2), fw = We(re.IF_V2), dw = We(re.FLOW), hw = We(re.GOTO), mw = We(re.CODE), pw = We(re.EXIT), gw = We(re.SPEAK), bw = We(re.START), Ew = We(re.SET_V2), vw = We(re.PROMPT), Tw = We(re.CAROUSEL), Aw = We(re.VISUAL), _w = We(re.INTENT), yw = We(re.STREAM), Sw = We(re.ZAPIER), Cw = We(re.RANDOM), Ow = We(re.RANDOM_V2), Iw = We(re.COMMAND), xw = We(re.BUTTONS), Nw = We(re.CAPTURE), Rw = We(re.GENERAL), kw = We(re.GOTO_NODE), ww = We(re.DIRECTIVE), Dw = We(re.COMPONENT), Pw = We(re.CAPTURE_V2), Lw = We(re.GOTO_DOMAIN), Mw = We(re.DEPRECATED), $w = We(re.INTERACTION), Bw = We(re.GOOGLE_SHEETS), Fw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createStepTypeguard: We,
  isApi: ow,
  isButtons: xw,
  isCapture: Nw,
  isCaptureV2: Pw,
  isCard: lw,
  isCardV2: cw,
  isCarousel: Tw,
  isCode: mw,
  isCommand: Iw,
  isComponent: Dw,
  isDeprecated: Mw,
  isDirective: ww,
  isExit: pw,
  isFlow: dw,
  isGeneral: Rw,
  isGoTo: hw,
  isGoToDomain: Lw,
  isGoToNode: kw,
  isGoogleSheets: Bw,
  isIf: aw,
  isIfV2: fw,
  isIntent: _w,
  isInteraction: $w,
  isPrompt: vw,
  isRandom: Cw,
  isRandomV2: Ow,
  isSet: sw,
  isSetV2: Ew,
  isSpeak: gw,
  isStart: bw,
  isStream: yw,
  isText: uw,
  isUrl: iw,
  isVisual: Aw,
  isZapier: Sw
}, Symbol.toStringTag, { value: "Module" })), o0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ai: oI,
  node: Tk,
  nodeType: rw,
  step: Fw
}, Symbol.toStringTag, { value: "Module" }));
var $o;
(function(e) {
  e.OFF = "OFF", e.ALL = "ALL", e.DIALOG = "DIALOG";
})($o || ($o = {}));
var Bo;
(function(e) {
  e.RESUME = "resume", e.RESTART = "restart";
})(Bo || (Bo = {}));
var Fo;
(function(e) {
  e.STATIC = "static", e.GENERATIVE = "generative";
})(Fo || (Fo = {}));
const hd = ({ error: e = null, repeat: t = $o.ALL, session: n = { type: Bo.RESTART }, defaultCanvasNodeVisibility: r = null, defaultCarouselLayout: a = null, globalNoMatch: i = { type: Fo.STATIC, prompt: void 0 }, globalNoReply: s = { delay: void 0, prompt: void 0 }, intentConfidence: o = 0.6 } = {}) => ({
  error: e,
  repeat: t,
  session: n,
  defaultCanvasNodeVisibility: r,
  defaultCarouselLayout: a,
  globalNoMatch: i,
  globalNoReply: s,
  intentConfidence: o
});
var mf;
(function(e) {
  e.PRODUCTION = "production", e.DEVELOPMENT = "development";
})(mf || (mf = {}));
const Lb = ({ slots: e = [], intents: t = [], settings: n = {}, publishing: r = {} }) => ({
  slots: e,
  intents: t,
  settings: hd(n),
  publishing: r
}), Nl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get GlobalNoMatchType() {
    return Fo;
  },
  get RepeatType() {
    return $o;
  },
  get SessionType() {
    return Bo;
  },
  get VersionTag() {
    return mf;
  },
  defaultPlatformData: Lb,
  defaultSettings: hd
}, Symbol.toStringTag, { value: "Module" })), Uw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseButton: Rm,
  BaseModels: km,
  BaseNode: wm,
  BaseProject: Dm,
  BaseRequest: Pm,
  BaseText: Mm,
  BaseTrace: $m,
  BaseUtils: o0,
  BaseVersion: Nl,
  Button: Rm,
  Models: km,
  Node: wm,
  Project: Dm,
  Request: Pm,
  RuntimeLogs: nI,
  Text: Mm,
  Trace: $m,
  Utils: o0,
  VariableState: Nl,
  Version: Nl
}, Symbol.toStringTag, { value: "Module" }));
var Mb = {}, $b = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isOpenURLAction = e.ActionType = void 0;
  var t;
  (function(r) {
    r.OPEN_URL = "open_url";
  })(t = e.ActionType || (e.ActionType = {}));
  const n = (r) => r.type === t.OPEN_URL;
  e.isOpenURLAction = n;
})($b);
(function(e) {
  var t = je && je.__createBinding || (Object.create ? function(p, b, v, E) {
    E === void 0 && (E = v);
    var y = Object.getOwnPropertyDescriptor(b, v);
    (!y || ("get" in y ? !b.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return b[v];
    } }), Object.defineProperty(p, E, y);
  } : function(p, b, v, E) {
    E === void 0 && (E = v), p[E] = b[v];
  }), n = je && je.__setModuleDefault || (Object.create ? function(p, b) {
    Object.defineProperty(p, "default", { enumerable: !0, value: b });
  } : function(p, b) {
    p.default = b;
  }), r = je && je.__importStar || function(p) {
    if (p && p.__esModule)
      return p;
    var b = {};
    if (p != null)
      for (var v in p)
        v !== "default" && Object.prototype.hasOwnProperty.call(p, v) && t(b, p, v);
    return n(b, p), b;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isGeneralRequest = e.isIntentRequest = e.isNoReplyRequest = e.isLaunchRequest = e.isActionRequest = e.isTextRequest = e.RequestType = e.Action = void 0, e.Action = r($b);
  var a;
  (function(p) {
    p.TEXT = "text", p.ACTION = "action", p.INTENT = "intent", p.LAUNCH = "launch", p.NO_REPLY = "no-reply";
  })(a = e.RequestType || (e.RequestType = {}));
  const i = (p) => p.type === a.TEXT;
  e.isTextRequest = i;
  const s = (p) => p.type === a.ACTION;
  e.isActionRequest = s;
  const o = (p) => p.type === a.LAUNCH;
  e.isLaunchRequest = o;
  const u = (p) => p.type === a.NO_REPLY;
  e.isNoReplyRequest = u;
  const l = (p) => p.type === a.INTENT;
  e.isIntentRequest = l;
  const f = Object.values(a), h = (p) => !f.includes(p.type);
  e.isGeneralRequest = h;
})(Mb);
const Hw = (e) => typeof e == "function", jw = (e) => {
  const [t, n] = _n(e), r = Xn(t), a = ra((i) => {
    r.current = Hw(i) ? i(r.current) : i, n(r.current);
  }, []);
  return [t, a, r];
};
var Un = {};
const zw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Vw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Gw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Yw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Ww = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), qw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Kw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Xw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Zw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Qw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Buttons: Vw,
  Capture: Gw,
  CaptureV2: Yw,
  CardV2: Ww,
  Carousel: qw,
  Interaction: Kw,
  Prompt: Xw,
  Utils: Zw
}, Symbol.toStringTag, { value: "Module" })), Jw = (e = {}) => Object.assign({}, ob(e)), eD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultPlatformData: Jw
}, Symbol.toStringTag, { value: "Module" })), tD = Tt(re.CAPTURE), nD = Tt(re.CAPTURE_V2), rD = Tt(re.INTERACTION), aD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isCapture: tD,
  isCaptureV2: nD,
  isInteraction: rD
}, Symbol.toStringTag, { value: "Module" })), Bb = (e) => e != null && e.content ? {
  id: e.id,
  content: e.content
} : null, iD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultPrompt: Bb
}, Symbol.toStringTag, { value: "Module" })), sD = We(re.PROMPT), oD = We(re.BUTTONS), uD = We(re.CAPTURE), lD = We(re.CAPTURE_V2), cD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isButtons: oD,
  isCapture: uD,
  isCaptureV2: lD,
  isPrompt: sD
}, Symbol.toStringTag, { value: "Module" })), fD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  node: aD,
  prompt: iD,
  step: cD
}, Symbol.toStringTag, { value: "Module" }));
var dD = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(e); a < r.length; a++)
      t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a]) && (n[r[a]] = e[r[a]]);
  return n;
};
const Fb = ({ durationMilliseconds: e = 1e3 } = {}) => ({
  durationMilliseconds: e
}), Ub = (e = {}) => {
  var { error: t, messageDelay: n } = e, r = dD(e, ["error", "messageDelay"]);
  return Object.assign(Object.assign({}, hd(r)), { error: Bb(t), messageDelay: Fb(n) });
};
var hD = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(e); a < r.length; a++)
      t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a]) && (n[r[a]] = e[r[a]]);
  return n;
};
const mD = (e) => {
  var { intents: t = [], settings: n = {} } = e, r = hD(e, ["intents", "settings"]);
  return Object.assign(Object.assign({}, Lb(r)), { intents: t, settings: Ub(n) });
}, pD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultMessageDelay: Fb,
  defaultPlatformData: mD,
  defaultSettings: Ub
}, Symbol.toStringTag, { value: "Module" })), gD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ChatModels: zw,
  ChatNode: Qw,
  ChatProject: eD,
  ChatUtils: fD,
  ChatVersion: pD
}, Symbol.toStringTag, { value: "Module" })), Hb = /* @__PURE__ */ Jf(gD);
var pf = {}, Tu = {}, jb = {}, Au = {};
Object.defineProperty(Au, "__esModule", { value: !0 });
Au.AZURE_LOCALE_VOICE_META = void 0;
Au.AZURE_LOCALE_VOICE_META = {
  "ar-EG": { language: "Arabic (Arabic )", locale: "ar-EG", voices: [{ gender: "Female", voiceID: "ar-EG-SalmaNeural" }] },
  "ar-SA": { language: "Arabic (Saudi Arabia)", locale: "ar-SA", voices: [{ gender: "Male", voiceID: "ar-SA-HamedNeural" }] },
  "bg-BG": { language: "Bulgarian (Bulgaria)", locale: "bg-BG", voices: [{ gender: "Male", voiceID: "bg-BG-KalinaNeural" }] },
  "ca-ES": { language: "Catalan (Spain)", locale: "ca-ES", voices: [{ gender: "Female", voiceID: "ca-ES-AlbaNeural" }] },
  "zh-HK": {
    language: "Chinese (Cantonese, Traditional)",
    locale: "zh-HK",
    voices: [
      { gender: "Male", voiceID: "zh-HK-WanLungNeural" },
      { gender: "Female", voiceID: "zh-HK-HiuGaaiNeural" }
    ]
  },
  "zh-CN": {
    language: "Chinese (Mandarin, Simplified)",
    locale: "zh-CN",
    voices: [
      { gender: "Female", voiceID: "zh-CN-XiaochenNeural" },
      { gender: "Male", voiceID: "zh-CN-YunxiNeural" },
      { gender: "Female", voiceID: "zh-CN-XiaohanNeural" }
    ]
  },
  "zh-TW": {
    language: "Chinese (Taiwanese Mandarin)",
    locale: "zh-TW",
    voices: [
      { gender: "Female", voiceID: "zh-TW-HsiaoChenNeural" },
      { gender: "Female", voiceID: "zh-TW-HsiaoYuNeural" },
      { gender: "Male", voiceID: "zh-TW-YunJheNeural" }
    ]
  },
  "hr-HR": { language: "Croatian (Croatia)", locale: "hr-HR", voices: [{ gender: "Male", voiceID: "hr-HR-SreckoNeural" }] },
  "cs-CZ": { language: "Czech (Czech Republic)", locale: "cs-CZ", voices: [{ gender: "Male", voiceID: "cs-CZ-AntoninNeural" }] },
  "da-DK": { language: "Danish (Denmark)", locale: "da-DK", voices: [{ gender: "Female", voiceID: "da-DK-ChristelNeural" }] },
  "nl-NL": { language: "Dutch (Netherlands)", locale: "nl-NL", voices: [{ gender: "Female", voiceID: "nl-NL-ColetteNeural" }] },
  "en-AU": {
    language: "English (Australia)",
    locale: "en-AU",
    voices: [
      { gender: "Female", voiceID: "en-AU-NatashaNeural" },
      { gender: "Male", voiceID: "en-AU-WilliamNeural" }
    ]
  },
  "en-CA": {
    language: "English (Canada)",
    locale: "en-CA",
    voices: [
      { gender: "Female", voiceID: "en-CA-ClaraNeural" },
      { gender: "Male", voiceID: "en-CA-LiamNeural" }
    ]
  },
  "en-IN": {
    language: "English (India)",
    locale: "en-IN",
    voices: [
      { gender: "Female", voiceID: "en-IN-NeerjaNeural" },
      { gender: "Male", voiceID: "en-IN-PrabhatNeural" }
    ]
  },
  "en-IE": { language: "English (Ireland)", locale: "en-IE", voices: [{ gender: "Male", voiceID: "en-IE-ConnorNeural" }] },
  "en-GB": {
    language: "English (United Kingdom)",
    locale: "en-GB",
    voices: [
      { gender: "Male", voiceID: "en-GB-RyanNeural" },
      { gender: "Female", voiceID: "en-GB-LibbyNeural" },
      { gender: "Female", voiceID: "en-GB-SoniaNeural" }
    ]
  },
  "en-US": {
    language: "English (United States)",
    locale: "en-US",
    voices: [
      { gender: "Male", voiceID: "en-US-SaraNeural" },
      { gender: "Male", voiceID: "en-US-ElizabethNeural" },
      { gender: "Female", voiceID: "en-US-BrandonNeural" },
      { gender: "Female", voiceID: "en-US-ChristopherNeural" }
    ]
  },
  "fi-FI": { language: "Finnish (Finland)", locale: "fi-FI", voices: [{ gender: "Female", voiceID: "fi-FI-NooraNeural" }] },
  "fr-CA": {
    language: "French (Canada)",
    locale: "fr-CA",
    voices: [
      { gender: "Female", voiceID: "fr-CA-SylvieNeural" },
      { gender: "Male", voiceID: "fr-CA-AntoineNeural" }
    ]
  },
  "fr-FR": {
    language: "French (France)",
    locale: "fr-FR",
    voices: [
      { gender: "Female", voiceID: "fr-FR-DeniseNeural" },
      { gender: "Male", voiceID: "fr-FR-HenriNeural" }
    ]
  },
  "fr-CH": { language: "French (Switzerland)", locale: "fr-CH", voices: [{ gender: "Male", voiceID: "fr-CH-FabriceNeural" }] },
  "de-AT": { language: "German (Austria)", locale: "de-AT", voices: [{ gender: "Male", voiceID: "de-AT-JonasNeural" }] },
  "de-DE": {
    language: "German (Germany)",
    locale: "de-DE",
    voices: [
      { gender: "Female", voiceID: "de-DE-KatjaNeural" },
      { gender: "Male", voiceID: "de-DE-ConradNeural" }
    ]
  },
  "de-CH": { language: "German (Switzerland)", locale: "de-CH", voices: [{ gender: "Male", voiceID: "de-CH-JanNeural" }] },
  "el-GR": { language: "Greek (Greece)", locale: "el-GR", voices: [{ gender: "Male", voiceID: "el-GR-NestorasNeural" }] },
  "he-IL": { language: "Hebrew (Israel)", locale: "he-IL", voices: [{ gender: "Male", voiceID: "he-IL-AvriNeural" }] },
  "hi-IN": {
    language: "Hindi (India)",
    locale: "hi-IN",
    voices: [
      { gender: "Male", voiceID: "hi-IN-MadhurNeural" },
      { gender: "Female", voiceID: "hi-IN-SwaraNeural" }
    ]
  },
  "hu-HU": { language: "Hungarian (Hungary)", locale: "hu-HU", voices: [{ gender: "Male", voiceID: "hu-HU-TamasNeural" }] },
  "id-ID": { language: "Indonesian (Indonesia)", locale: "id-ID", voices: [{ gender: "Male", voiceID: "id-ID-ArdiNeural" }] },
  "it-IT": {
    language: "Italian (Italy)",
    locale: "it-IT",
    voices: [
      { gender: "Male", voiceID: "it-IT-DiegoNeural" },
      { gender: "Female", voiceID: "it-IT-ElsaNeural" }
    ]
  },
  "ja-JP": {
    language: "Japanese (Japan)",
    locale: "ja-JP",
    voices: [
      { gender: "Female", voiceID: "ja-JP-NanamiNeural" },
      { gender: "Male", voiceID: "ja-JP-KeitaNeural" }
    ]
  },
  "ko-KR": { language: "Korean (Korea)", locale: "ko-KR", voices: [{ gender: "Female", voiceID: "ko-KR-SunHiNeural" }] },
  "ms-MY": { language: "Malay (Malaysia)", locale: "ms-MY", voices: [{ gender: "Male", voiceID: "ms-MY-OsmanNeural" }] },
  "nb-NO": { language: "Norwegian (Bokml, Norway)", locale: "nb-NO", voices: [{ gender: "Female", voiceID: "nb-NO-IselinNeural" }] },
  "pl-PL": { language: "Polish (Poland)", locale: "pl-PL", voices: [{ gender: "Female", voiceID: "pl-PL-AgnieszkaNeural" }] },
  "pt-BR": {
    language: "Portuguese (Brazil)",
    locale: "pt-BR",
    voices: [
      { gender: "Male", voiceID: "pt-BR-AntonioNeural" },
      { gender: "Female", voiceID: "pt-BR-FranciscaNeural" }
    ]
  },
  "pt-PT": { language: "Portuguese (Portugal)", locale: "pt-PT", voices: [{ gender: "Female", voiceID: "pt-PT-FernandaNeural" }] },
  "ro-RO": { language: "Romanian (Romania)", locale: "ro-RO", voices: [{ gender: "Male", voiceID: "ro-RO-EmilNeural" }] },
  "ru-RU": {
    language: "Russian (Russia)",
    locale: "ru-RU",
    voices: [
      { gender: "Female", voiceID: "ru-RU-DariyaNeural" },
      { gender: "Female", voiceID: "ru-RU-SvetlanaNeural" },
      { gender: "Male", voiceID: "ru-RU-DmitryNeural" }
    ]
  },
  "sk-SK": { language: "Slovak (Slovakia)", locale: "sk-SK", voices: [{ gender: "Male", voiceID: "sk-SK-ViktoriaNeural" }] },
  "sl-SI": { language: "Slovenian (Slovenia)", locale: "sl-SI", voices: [{ gender: "Male", voiceID: "sl-SI-RokNeural" }] },
  "es-MX": {
    language: "Spanish (Mexico)",
    locale: "es-MX",
    voices: [
      { gender: "Female", voiceID: "es-MX-DaliaNeural" },
      { gender: "Male", voiceID: "es-MX-JorgeNeural" }
    ]
  },
  "es-ES": {
    language: "Spanish (Spain)",
    locale: "es-ES",
    voices: [
      { gender: "Female", voiceID: "es-ES-ElviraNeural" },
      { gender: "Male", voiceID: "es-ES-AlvaroNeural" }
    ]
  },
  "sv-SE": { language: "Swedish (Sweden)", locale: "sv-SE", voices: [{ gender: "Female", voiceID: "sv-SE-HilleviNeural" }] },
  "ta-IN": { language: "Tamil (India)", locale: "ta-IN", voices: [{ gender: "Male", voiceID: "ta-IN-ValluvarNeural" }] },
  "te-IN": { language: "Telugu (India)", locale: "te-IN", voices: [{ gender: "Female", voiceID: "te-IN-ShrutiNeural" }] },
  "th-TH": { language: "Thai (Thailand)", locale: "th-TH", voices: [{ gender: "Male", voiceID: "th-TH-NiwatNeural" }] },
  "tr-TR": { language: "Turkish (Turkey)", locale: "tr-TR", voices: [{ gender: "Female", voiceID: "tr-TR-EmelNeural" }] },
  "vi-VN": { language: "Vietnamese (Vietnam)", locale: "vi-VN", voices: [{ gender: "Male", voiceID: "vi-VN-NamMinhNeural" }] }
};
var _u = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isVoiceflowLanguage = e.Language = e.Locale = e.Voice = void 0, function(a) {
    a.AUDIO = "audio", a.DEFAULT = "default";
  }(e.Voice || (e.Voice = {})), function(a) {
    a.EN_US = "en-US", a.AR_AR = "ar-AR", a.BG_BG = "bg-BG", a.CA_ES = "ca-ES", a.CS_CZ = "cs-CZ", a.ZH_CN = "zh-CN", a.ZH_TW = "zh-TW", a.DA_DK = "da-DK", a.NL_NL = "nl-NL", a.NL_BE = "nl-BE", a.ET_EE = "et-EE", a.FR_FR = "fr-FR", a.FR_CA = "fr-CA", a.DE_DE = "de-DE", a.HE_IL = "he-IL", a.HU_HU = "hu-HU", a.GU_IN = "gu-IN", a.HI_IN = "hi-IN", a.IT_IT = "it-IT", a.JA_JP = "ja-JP", a.KO_KR = "ko-KR", a.MR_IN = "mr-IN", a.PL_PL = "pl-PL", a.PT_PT = "pt-PT", a.PT_BR = "pt-BR", a.RO_RO = "ro-RO", a.RU_RU = "ru-RU", a.ES_ES = "es-ES", a.ES_MX = "es-MX", a.TA_IN = "ta-IN", a.TE_IN = "te-IN", a.TR_TR = "tr-TR", a.UK_UA = "uk-UA", a.VI_VN = "vi-VN";
  }(e.Locale || (e.Locale = {}));
  var t;
  (function(a) {
    a.EN = "en", a.AR = "ar", a.BG = "bg", a.CA = "ca", a.CS = "cs", a.ZH = "zh", a.DA = "da", a.NL = "nl", a.ET = "et", a.FR = "fr", a.DE = "de", a.GU = "gu", a.HE = "he", a.HI = "hi", a.HU = "hu", a.IT = "it", a.JA = "ja", a.KO = "ko", a.MR = "mr", a.PL = "pl", a.PT = "pt", a.RO = "ro", a.RU = "ru", a.ES = "es", a.TA = "ta", a.TE = "te", a.TR = "tr", a.UK = "uk", a.VI = "vi";
  })(t = e.Language || (e.Language = {}));
  const n = new Set(Object.values(t)), r = (a) => n.has(a);
  e.isVoiceflowLanguage = r;
})(_u);
var yu = {};
const bD = /* @__PURE__ */ Jf(Uw);
Object.defineProperty(yu, "__esModule", { value: !0 });
yu.DEVICE_SIZE_MAP = void 0;
const Mn = bD;
yu.DEVICE_SIZE_MAP = {
  [Mn.BaseNode.Visual.DeviceType.MOBILE]: { width: 375, height: 812 },
  [Mn.BaseNode.Visual.DeviceType.TABLET]: { width: 1024, height: 1366 },
  [Mn.BaseNode.Visual.DeviceType.DESKTOP]: { width: 1440, height: 900 },
  [Mn.BaseNode.Visual.DeviceType.SMART_WATCH]: { width: 184, height: 224 },
  [Mn.BaseNode.Visual.DeviceType.TELEVISION]: { width: 1920, height: 1200 },
  [Mn.BaseNode.Visual.DeviceType.IN_CAR_DISPLAY]: { width: 1200, height: 800 },
  [Mn.BaseNode.Visual.DeviceType.ECHO_SPOT]: { width: 480, height: 480 },
  [Mn.BaseNode.Visual.DeviceType.ECHO_SHOW_8]: { width: 1280, height: 800 },
  [Mn.BaseNode.Visual.DeviceType.ECHO_SHOW_10]: { width: 1280, height: 800 },
  [Mn.BaseNode.Visual.DeviceType.FIRE_HD_8]: { width: 1280, height: 800 },
  [Mn.BaseNode.Visual.DeviceType.FIRE_HD_10]: { width: 1920, height: 1200 },
  [Mn.BaseNode.Visual.DeviceType.FIRE_TV_CUBE]: { width: 1920, height: 1080 },
  [Mn.BaseNode.Visual.DeviceType.GOOGLE_NEST_HUB]: { width: 1280, height: 730 }
};
var zb = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DEFAULT_INTENTS_MAP = e.findDefaultIntent = e.IntentName = void 0;
  const t = _u;
  var n;
  (function(a) {
    a.NO = "VF.NO", a.YES = "VF.YES", a.STOP = "VF.STOP", a.NEXT = "VF.NEXT", a.HELP = "VF.HELP", a.PAUSE = "VF.PAUSE", a.CANCEL = "VF.CANCEL", a.RESUME = "VF.RESUME", a.REPEAT = "VF.REPEAT", a.PREVIOUS = "VF.PREVIOUS", a.START_OVER = "VF.START_OVER", a.NONE = "None";
  })(n = e.IntentName || (e.IntentName = {}));
  const r = (a, i) => {
    var s;
    return (s = e.DEFAULT_INTENTS_MAP === null || e.DEFAULT_INTENTS_MAP === void 0 ? void 0 : e.DEFAULT_INTENTS_MAP[a]) === null || s === void 0 ? void 0 : s.find((o) => o.name === i);
  };
  e.findDefaultIntent = r, e.DEFAULT_INTENTS_MAP = {
    // English (AU,CA,US,UK,IN)
    [t.Language.EN]: [
      {
        name: n.NO,
        samples: ["no", "nope", "nay", "nah", "no way", "negative"]
      },
      {
        name: n.YES,
        samples: ["yes", "yea", "ok", "okay", "yup", "ya", "sure"]
      },
      {
        name: n.STOP,
        samples: ["stop"]
      },
      {
        name: n.NEXT,
        samples: ["next"]
      },
      {
        name: n.HELP,
        samples: ["help", "help me", "i need help"]
      },
      {
        name: n.PAUSE,
        samples: ["pause"]
      },
      {
        name: n.CANCEL,
        samples: ["cancel"]
      },
      {
        name: n.RESUME,
        samples: ["resume"]
      },
      {
        name: n.REPEAT,
        samples: ["repeat", "again", "say again"]
      },
      {
        name: n.PREVIOUS,
        samples: ["previous"]
      },
      {
        name: n.START_OVER,
        samples: ["start over", "restart"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // French (CA,FR)
    [t.Language.FR]: [
      {
        name: n.NO,
        samples: ["non", "nan", "absolument pas", "hors de question", "bien sr que non"]
      },
      {
        name: n.YES,
        samples: ["oui", "yep", "ok", "bien sr", "ouais", "ouaip", "exactement", "correct", "okay", "d'accord"]
      },
      {
        name: n.STOP,
        samples: ["s'arrter", "arrter", "arrte", "stop", "fin", "cesser", "mettre fin", "stopper", "mettre un terme", "interrompre"]
      },
      {
        name: n.HELP,
        samples: ["aidez-moi", "l'assistance", "aider"]
      },
      {
        name: n.NEXT,
        samples: ["prochaine", "prochain", "suivant"]
      },
      {
        name: n.PAUSE,
        samples: ["pause"]
      },
      {
        name: n.CANCEL,
        samples: ["annuler", "annule"]
      },
      {
        name: n.RESUME,
        samples: ["reprendre"]
      },
      {
        name: n.REPEAT,
        samples: [
          "repeat",
          "est-ce que tu peux rpter",
          "rpte",
          "tu peux rpter",
          "dis-le  nouveau",
          "tu peux le redire",
          "redire a",
          "rpter a"
        ]
      },
      {
        name: n.PREVIOUS,
        samples: ["prcdente", "prcdent"]
      },
      {
        name: n.START_OVER,
        samples: ["recommencer", "redmarrer"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // Japanese (JA)
    [t.Language.JA]: [
      {
        name: n.NO,
        samples: ["no", "", "", "", "", "", ""]
      },
      {
        name: n.YES,
        samples: ["yes", "", "", ""]
      },
      {
        name: n.STOP,
        samples: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ]
      },
      {
        name: n.NEXT,
        samples: ["", ""]
      },
      {
        name: n.HELP,
        samples: ["", "", ""]
      },
      {
        name: n.PAUSE,
        samples: ["", ""]
      },
      {
        name: n.CANCEL,
        samples: ["", "", "", ""]
      },
      {
        name: n.RESUME,
        samples: [""]
      },
      {
        name: n.REPEAT,
        samples: ["repeat", "", "", "", ""]
      },
      {
        name: n.PREVIOUS,
        samples: ["", ""]
      },
      {
        name: n.START_OVER,
        samples: ["", ""]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // Italian (IT)
    [t.Language.IT]: [
      {
        name: n.NO,
        samples: ["no", "il no", "il rifiuto", "la negazione", "nessuno"]
      },
      {
        name: n.YES,
        samples: ["yes", "si", "certo"]
      },
      {
        name: n.STOP,
        samples: [
          "stop",
          "la fermata",
          "il fermo",
          "lo stop",
          "la sosta",
          "la tappa",
          "fermare",
          "interrompere",
          "smettere",
          "fermarsi",
          "arrestare",
          "cessare",
          "sostare",
          "finire",
          "stoppare",
          "fare una fermata"
        ]
      },
      {
        name: n.NEXT,
        samples: ["prossimo", "seguente", "succesivo"]
      },
      {
        name: n.HELP,
        samples: ["aiuto", "la assistenza", "aiutami"]
      },
      {
        name: n.PAUSE,
        samples: ["pausa", "la pausa"]
      },
      {
        name: n.CANCEL,
        samples: ["cancellare", "annullare", "disdire", "sopprimere", "rescindre", "chiudere", "abrogare", "obliterare"]
      },
      {
        name: n.RESUME,
        samples: ["riprendere"]
      },
      {
        name: n.REPEAT,
        samples: ["ripetere", "la ripetizione"]
      },
      {
        name: n.PREVIOUS,
        samples: ["precedente"]
      },
      {
        name: n.START_OVER,
        samples: ["ricominciare", "ricomincia"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // Spanish (ES,MX)
    [t.Language.ES]: [
      {
        name: n.NO,
        samples: ["no", "ninguno", "imposible", "prohibido", "la negativa", "el voto negativo", "el voto en contra"]
      },
      {
        name: n.YES,
        samples: ["yes", "si", "s", "decir si"]
      },
      {
        name: n.STOP,
        samples: ["detener", "dejar", "parar", "suspender", "cesar", "pararse", "terminar", "de alto"]
      },
      {
        name: n.NEXT,
        samples: ["siguiente", "prximo"]
      },
      {
        name: n.HELP,
        samples: ["ayuda", "ayuadame"]
      },
      {
        name: n.PAUSE,
        samples: ["pausa", "la pausa"]
      },
      {
        name: n.CANCEL,
        samples: [
          "cancelar",
          "anular",
          "suprimir",
          "abolir",
          "dar anulacin",
          "realizar anulacin",
          "hacer anulacin",
          "hacer dar anulacin",
          "noun la cancelacin",
          "la anulacin"
        ]
      },
      {
        name: n.RESUME,
        samples: ["reanudar"]
      },
      {
        name: n.REPEAT,
        samples: ["repeat", "repetir", "repetirse", "reiterar", "recitar", "volver a dar"]
      },
      {
        name: n.PREVIOUS,
        samples: ["previa", "previo"]
      },
      {
        name: n.START_OVER,
        samples: ["reiniciar"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // German (DE)
    [t.Language.DE]: [
      {
        name: n.NO,
        samples: ["no", "nein", "kein", "nicht"]
      },
      {
        name: n.YES,
        samples: ["yes", "ja", "doch", "jawohl"]
      },
      {
        name: n.STOP,
        samples: [
          "der stopp",
          "der anschlag",
          "die haltestelle",
          "der registerzug",
          "stoppen",
          "aufhren",
          "beenden",
          "anhalten",
          "halten",
          "verhindern",
          "aufhalten",
          "unterbrechen",
          "abbrechen",
          "unterbinden",
          "einstellen",
          "abbestellen",
          "absetzen"
        ]
      },
      {
        name: n.NEXT,
        samples: ["nchster", "nchste", "neben"]
      },
      {
        name: n.HELP,
        samples: ["hilfe", "hilf mir", "helfen"]
      },
      {
        name: n.PAUSE,
        samples: ["pause", "pausieren", "die pause"]
      },
      {
        name: n.CANCEL,
        samples: ["stornieren", "aufheben", "kndigen", "annullieren", "beenden", "absagen", "abbestellen", "abmelden", "auflsen", "zurcknehmen"]
      },
      {
        name: n.RESUME,
        samples: ["wieder aufnehmen", "fortsetzen", "fortfahren"]
      },
      {
        name: n.REPEAT,
        samples: ["repeat", "wiederholen", "wiedergeben", "repetieren", "weitersagen"]
      },
      {
        name: n.PREVIOUS,
        samples: ["bisherige", "frher"]
      },
      {
        name: n.START_OVER,
        samples: ["Von vorn anfangen", "Neustart", "wieder starten"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // Portuguese (PT)
    [t.Language.PT]: [
      {
        name: n.NO,
        samples: ["no", "no", "negativa"]
      },
      {
        name: n.YES,
        samples: ["yes", "sim", "o sim", "dizer sim"]
      },
      {
        name: n.STOP,
        samples: ["parar", "terminar", "impedir", "fazer parar"]
      },
      {
        name: n.NEXT,
        samples: ["prxima", "prximo", "seguinte", "seguida"]
      },
      {
        name: n.HELP,
        samples: ["socorro", "me ajude"]
      },
      {
        name: n.PAUSE,
        samples: ["pausa", "pausar"]
      },
      {
        name: n.CANCEL,
        samples: ["cancelar", "anular", "suspender"]
      },
      {
        name: n.RESUME,
        samples: ["retomar"]
      },
      {
        name: n.REPEAT,
        samples: ["repeat", "repetir", "reiterar", "refazer", "amiudar", "recitar de cor"]
      },
      {
        name: n.PREVIOUS,
        samples: ["anterior"]
      },
      {
        name: n.START_OVER,
        samples: ["recomear", "reiniciar"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // Hindi (IN)
    [t.Language.HI]: [
      {
        name: n.NO,
        samples: ["", "", "", "", ""]
      },
      {
        name: n.YES,
        samples: [
          "",
          "",
          "",
          "",
          " ",
          "",
          " ",
          "",
          " ",
          "",
          "  ",
          "",
          "",
          " ",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ]
      },
      {
        name: n.STOP,
        samples: ["", "", "", "", "", "", " ", "", " ", "  ", " ", ""]
      },
      {
        name: n.NEXT,
        samples: ["", "", "", ""]
      },
      {
        name: n.HELP,
        samples: ["", "  "]
      },
      {
        name: n.PAUSE,
        samples: ["", ""]
      },
      {
        name: n.CANCEL,
        samples: [
          " ",
          " ",
          "  ",
          " ",
          " ",
          "  ",
          " ",
          " ",
          " ",
          " ",
          " ",
          " ",
          "",
          " ",
          " ",
          "  "
        ]
      },
      {
        name: n.RESUME,
        samples: ["  ", "   ", "     "]
      },
      {
        name: n.REPEAT,
        samples: [
          " ",
          " ",
          "  ",
          " ",
          "  ",
          " ",
          "  ",
          " ",
          " ",
          "  ",
          " ",
          "  ",
          " ",
          "  ",
          " ",
          "  ",
          "",
          "  ",
          "",
          " "
        ]
      },
      {
        name: n.PREVIOUS,
        samples: ["", ""]
      },
      {
        name: n.START_OVER,
        samples: [" ", " "]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    [t.Language.BG]: [
      { name: n.NO, samples: ["", "", "", " ", ""] },
      {
        name: n.YES,
        samples: ["", "", "", "", "", " "]
      },
      {
        name: n.STOP,
        samples: ["", ""]
      },
      {
        name: n.NEXT,
        samples: ["", "", ""]
      },
      {
        name: n.HELP,
        samples: ["", " ", "  "]
      },
      {
        name: n.PAUSE,
        samples: ["", ""]
      },
      {
        name: n.CANCEL,
        samples: ["", ""]
      },
      {
        name: n.RESUME,
        samples: ["", ""]
      },
      {
        name: n.REPEAT,
        samples: ["", "", " "]
      },
      {
        name: n.PREVIOUS,
        samples: ["", "", ""]
      },
      {
        name: n.START_OVER,
        samples: [" ", ""]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // ca-ES
    [t.Language.CA]: [
      { name: n.NO, samples: ["no", "no", "no", "no", "de cap manera", "negatiu"] },
      {
        name: n.YES,
        samples: ["s", "s", "d'acord", "d'acord", "s", "s", "clar"]
      },
      {
        name: n.STOP,
        samples: ["atura"]
      },
      {
        name: n.NEXT,
        samples: ["segent"]
      },
      {
        name: n.HELP,
        samples: ["ajuda", "ajuda", "necessito ajuda"]
      },
      {
        name: n.PAUSE,
        samples: ["pausa"]
      },
      {
        name: n.CANCEL,
        samples: ["cancella"]
      },
      {
        name: n.RESUME,
        samples: ["continua"]
      },
      {
        name: n.REPEAT,
        samples: ["repeteix", "una altra vegada", "digues-ho una altra vegada"]
      },
      {
        name: n.PREVIOUS,
        samples: ["anterior"]
      },
      {
        name: n.START_OVER,
        samples: ["comena de nou", "reinicia"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // 'cs-CZ'
    [t.Language.CS]: [
      {
        name: n.NO,
        samples: ["ne", "nechci", "nic", "nikoliv", "nebylo by vhodn"]
      },
      {
        name: n.YES,
        samples: ["ano", "jist", "dobe", "jo", "urit"]
      },
      {
        name: n.STOP,
        samples: ["zastavit", "pestat", "skonit"]
      },
      {
        name: n.NEXT,
        samples: ["dal", "dl", "pokraovat"]
      },
      {
        name: n.HELP,
        samples: ["pomoc", "potebuji pomoc", "npovda"]
      },
      {
        name: n.PAUSE,
        samples: ["pauza", "pozastavit", "zastavit na chvli"]
      },
      {
        name: n.CANCEL,
        samples: ["zruit", "zruen", "odvolat"]
      },
      {
        name: n.RESUME,
        samples: ["obnovit", "pokraovat", "znovu spustit"]
      },
      {
        name: n.REPEAT,
        samples: ["opakovat", "znovu", "ci znovu"]
      },
      {
        name: n.PREVIOUS,
        samples: ["pedchoz", "zpt", "zpt na pedchoz"]
      },
      {
        name: n.START_OVER,
        samples: ["zat znovu", "restartovat"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // 'da-DK'
    [t.Language.DA]: [
      {
        name: n.NO,
        samples: ["nej", "n", "nej tak", "negative"]
      },
      {
        name: n.YES,
        samples: ["ja", "jo", "okay", "selvflgelig"]
      },
      {
        name: n.STOP,
        samples: ["stop"]
      },
      {
        name: n.NEXT,
        samples: ["nste"]
      },
      {
        name: n.HELP,
        samples: ["hjlp", "hjlp mig", "jeg har brug for hjlp"]
      },
      {
        name: n.PAUSE,
        samples: ["pause"]
      },
      {
        name: n.CANCEL,
        samples: ["annuller"]
      },
      {
        name: n.RESUME,
        samples: ["genoptag", "fortst"]
      },
      {
        name: n.REPEAT,
        samples: ["gentag", "igen", "sig det igen"]
      },
      {
        name: n.PREVIOUS,
        samples: ["forrige"]
      },
      {
        name: n.START_OVER,
        samples: ["start forfra", "genstart"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // et-EE
    [t.Language.ET]: [
      {
        name: n.NO,
        samples: ["ei", "ei ole", "ei taha", "mitte", "negatiivne"]
      },
      {
        name: n.YES,
        samples: ["jah", "okei", "ok", "kindlasti", "jah-jah", "jah, muidugi"]
      },
      {
        name: n.STOP,
        samples: ["peata", "lpeta", "stopp"]
      },
      {
        name: n.NEXT,
        samples: ["jrgmine", "edasi"]
      },
      {
        name: n.HELP,
        samples: ["abi", "aita mind", "vajan abi"]
      },
      {
        name: n.PAUSE,
        samples: ["paus", "peatus"]
      },
      {
        name: n.CANCEL,
        samples: ["thista", "katkesta"]
      },
      {
        name: n.RESUME,
        samples: ["jtka", "taasalusta"]
      },
      {
        name: n.REPEAT,
        samples: ["korda", "uuesti", "tle uuesti"]
      },
      {
        name: n.PREVIOUS,
        samples: ["eelmine", "tagasi"]
      },
      {
        name: n.START_OVER,
        samples: ["alusta otsast", "alusta uuesti"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // he-IL
    [t.Language.HE]: [
      {
        name: n.NO,
        samples: ["", " ", " ", "", " ", ""]
      },
      {
        name: n.YES,
        samples: ["", " ", "", "", "", " ", ""]
      },
      {
        name: n.STOP,
        samples: ["", ""]
      },
      {
        name: n.NEXT,
        samples: ["", " ", ""]
      },
      {
        name: n.HELP,
        samples: ["", " ", "  "]
      },
      {
        name: n.PAUSE,
        samples: ["", ""]
      },
      {
        name: n.CANCEL,
        samples: ["", "  "]
      },
      {
        name: n.RESUME,
        samples: ["", " "]
      },
      {
        name: n.REPEAT,
        samples: ["", "", " "]
      },
      {
        name: n.PREVIOUS,
        samples: ["", " ", " "]
      },
      {
        name: n.START_OVER,
        samples: [" ", " ", ""]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // hu-HU
    [t.Language.HU]: [
      {
        name: n.NO,
        samples: ["nem", "nincs", "nem", "nem", "nincs md", "negatv"]
      },
      {
        name: n.YES,
        samples: ["igen", "igen", "rendben", "ok", "igen", "igen", "biztos"]
      },
      {
        name: n.STOP,
        samples: ["llj", "llj le", "meglls"]
      },
      {
        name: n.NEXT,
        samples: ["kvetkez"]
      },
      {
        name: n.HELP,
        samples: ["segtsg", "segts nekem", "segtsg kell"]
      },
      {
        name: n.PAUSE,
        samples: ["sznet", "szneteltets"]
      },
      {
        name: n.CANCEL,
        samples: ["mgse", "mgsem", "megszntets"]
      },
      {
        name: n.RESUME,
        samples: ["folytats", "folytat", "jrakezds"]
      },
      {
        name: n.REPEAT,
        samples: ["ismteld", "mg egyszer", "ismteld meg"]
      },
      {
        name: n.PREVIOUS,
        samples: ["elz"]
      },
      {
        name: n.START_OVER,
        samples: ["jrakezds", "jraindts"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // pl-PL
    [t.Language.PL]: [
      {
        name: n.NO,
        samples: ["nie", "nie ma", "nigdy", "niech", "nie moliwe", "negatywne"]
      },
      {
        name: n.YES,
        samples: ["tak", "take", "ok", "dobrze", "oczywicie", "jasne", "pewnie"]
      },
      {
        name: n.STOP,
        samples: ["stop", "zatrzymaj"]
      },
      {
        name: n.NEXT,
        samples: ["nastpne", "dalej"]
      },
      {
        name: n.HELP,
        samples: ["pomoc", "pom mi", "potrzebuj pomocy"]
      },
      {
        name: n.PAUSE,
        samples: ["pauza", "zatrzymaj"]
      },
      {
        name: n.CANCEL,
        samples: ["anuluj"]
      },
      {
        name: n.RESUME,
        samples: ["wznw", "kontynuuj"]
      },
      {
        name: n.REPEAT,
        samples: ["powtrz", "ponw", "powiedz ponownie"]
      },
      {
        name: n.PREVIOUS,
        samples: ["poprzednie", "co byo wczeniej"]
      },
      {
        name: n.START_OVER,
        samples: ["zacznij od nowa", "zrestartuj"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // ro-RO
    [t.Language.RO]: [
      {
        name: n.NO,
        samples: ["nu", "niciun fel", "nici o ans", "negativ"]
      },
      {
        name: n.YES,
        samples: ["da", "bine", "ok", "bineneles", "sigur"]
      },
      {
        name: n.STOP,
        samples: ["oprete", "stop"]
      },
      {
        name: n.NEXT,
        samples: ["urmtorul", "urmtor"]
      },
      {
        name: n.HELP,
        samples: ["ajutor", "ajut-m", "am nevoie de ajutor"]
      },
      {
        name: n.PAUSE,
        samples: ["pauz", "oprete"]
      },
      {
        name: n.CANCEL,
        samples: ["anuleaz", "renun", "cancel"]
      },
      {
        name: n.RESUME,
        samples: ["continu", "reluare"]
      },
      {
        name: n.REPEAT,
        samples: ["repet", "iari", "spune din nou"]
      },
      {
        name: n.PREVIOUS,
        samples: ["anteriorul", "precedent"]
      },
      {
        name: n.START_OVER,
        samples: ["ncepe din nou", "restarteaz", "reia de la nceput"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // ru-RU
    [t.Language.RU]: [
      {
        name: n.NO,
        samples: ["", "", "", "", "", ""]
      },
      {
        name: n.YES,
        samples: ["", "", "", "", "", "", ""]
      },
      {
        name: n.STOP,
        samples: ["", ""]
      },
      {
        name: n.NEXT,
        samples: ["", "", " "]
      },
      {
        name: n.HELP,
        samples: ["", "", "  "]
      },
      {
        name: n.PAUSE,
        samples: ["", "  "]
      },
      {
        name: n.CANCEL,
        samples: ["", ""]
      },
      {
        name: n.RESUME,
        samples: ["", ""]
      },
      {
        name: n.REPEAT,
        samples: ["", " ", " "]
      },
      {
        name: n.PREVIOUS,
        samples: ["", " "]
      },
      {
        name: n.START_OVER,
        samples: [" ", ""]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // uk-UA
    [t.Language.UK]: [
      {
        name: n.NO,
        samples: ["", "", "", "", "   ", ""]
      },
      {
        name: n.YES,
        samples: ["", "", "", "", "", "", ""]
      },
      {
        name: n.STOP,
        samples: [""]
      },
      {
        name: n.NEXT,
        samples: [""]
      },
      {
        name: n.HELP,
        samples: ["", " ", "  "]
      },
      {
        name: n.PAUSE,
        samples: [""]
      },
      {
        name: n.CANCEL,
        samples: [""]
      },
      {
        name: n.RESUME,
        samples: [""]
      },
      {
        name: n.REPEAT,
        samples: ["", "", "  "]
      },
      {
        name: n.PREVIOUS,
        samples: [""]
      },
      {
        name: n.START_OVER,
        samples: ["  ", ""]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // vi-VN
    [t.Language.VI]: [
      {
        name: n.NO,
        samples: ["khng", "ko", "hng", "khng phi", "no way", "ph nh"]
      },
      {
        name: n.YES,
        samples: ["c", "", "c", "ng", "yup", "vng", "chc"]
      },
      {
        name: n.STOP,
        samples: ["dng", "stop"]
      },
      {
        name: n.NEXT,
        samples: ["tip theo", "next"]
      },
      {
        name: n.HELP,
        samples: ["gip ", "gip ti", "ti cn gip "]
      },
      {
        name: n.PAUSE,
        samples: ["tm dng", "pause"]
      },
      {
        name: n.CANCEL,
        samples: ["hy b", "cancel"]
      },
      {
        name: n.RESUME,
        samples: ["tip tc", "resume"]
      },
      {
        name: n.REPEAT,
        samples: ["lp li", "li", "ni li"]
      },
      {
        name: n.PREVIOUS,
        samples: ["trc ", "previous"]
      },
      {
        name: n.START_OVER,
        samples: ["bt u li", "khi u li"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ]
  };
})(zb);
var Su = {};
Object.defineProperty(Su, "__esModule", { value: !0 });
Su.defaultMessages = void 0;
Su.defaultMessages = {
  globalNoReply: "Are you still there?",
  globalNoMatch: "Sorry, I didnt get that. Please try again."
};
var Vb = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.TTSPlatformType = e.ProjectType = e.PlatformType = void 0, function(t) {
    t.ALEXA = "alexa", t.GOOGLE = "google", t.VOICEFLOW = "voiceflow", t.DIALOGFLOW_ES = "df-es", t.DIALOGFLOW_CX = "df-cx", t.RASA = "rasa", t.WATSON = "watson", t.LEX = "lex", t.EINSTEIN = "einstein", t.NUANCE_MIX = "nuance-mix", t.WEBCHAT = "webchat", t.MICROSOFT_TEAMS = "microsoft_teams", t.WHATSAPP = "whatsapp", t.SMS = "sms", t.LUIS = "luis", t.IVR = "ivr", t.CHATBOT = "chatbot", t.DIALOGFLOW_ES_CHAT = "dialogflow_es_chat", t.DIALOGFLOW_ES_VOICE = "dialogflow_es_voice", t.GENERAL = "general", t.MOBILE_APP = "mobile_app";
  }(e.PlatformType || (e.PlatformType = {})), function(t) {
    t.CHAT = "chat", t.VOICE = "voice";
  }(e.ProjectType || (e.ProjectType = {})), function(t) {
    t.ALEXA = "alexa", t.AZURE = "azure", t.GOOGLE = "google";
  }(e.TTSPlatformType || (e.TTSPlatformType = {}));
})(Vb);
var Gb = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SlotTypes = e.SlotType = void 0;
  const t = _u;
  var n;
  (function(f) {
    f.CUSTOM = "VF.CUSTOM", f.AGE = "VF.AGE", f.CURRENCY = "VF.CURRENCY", f.DATETIME = "VF.DATETIME", f.DIMENSION = "VF.DIMENSION", f.EMAIL = "VF.EMAIL", f.GEOGRAPHY = "VF.GEOGRAPHY", f.KEY_PHRASE = "VF.KEY_PHRASE", f.NAME = "VF.NAME", f.NATOAPCO = "VF.NATOAPCO", f.NUMBER = "VF.NUMBER", f.ORDINAL = "VF.ORDINAL", f.PERCENTAGE = "VF.PERCENTAGE", f.PHONENUMBER = "VF.PHONENUMBER", f.TEMPERATURE = "VF.TEMPERATURE", f.URL = "VF.URL";
  })(n = e.SlotType || (e.SlotType = {}));
  const r = {
    name: n.EMAIL,
    label: "Email",
    values: ["user@voiceflow.com", "professor@utoronto.edu", "person_name@gmail.com", "username123.signature@hotmail.com", "researcher@charity.org"],
    regex: "^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$"
  }, a = {
    name: n.PHONENUMBER,
    label: "Phone Number",
    values: ["1 (800) 642-7676", "123-456-7890", "647 126 3928", "360 392-1293", "906-459-2349", "2018073710", "4791945491"]
  }, i = (f) => ({
    name: n.NUMBER,
    label: f,
    values: ["-43", "0", "35.5", "8", "520", "23599", "325", "15", "84730909029", "6947"]
  }), s = (f) => ({
    name: n.PERCENTAGE,
    label: f,
    values: ["3 1/2", "2%", "5 %"]
  }), o = (f) => ({
    name: n.ORDINAL,
    label: f,
    values: ["first", "second", "third", "next", "last", "previous"]
  }), u = (f) => ({
    name: n.URL,
    label: f,
    values: ["https://www.luis.ai", "www.google.ca", "voiceflow.com", "dev.voiceflow.com", "http://www.something.io"]
  }), l = (f) => ({
    name: n.KEY_PHRASE,
    label: f,
    values: ["educational requirements", "development", "food", "wonderful staff", "extravagant"]
  });
  e.SlotTypes = {
    [t.Language.EN]: [
      {
        name: n.NAME,
        label: "Name",
        values: [
          "john",
          "james",
          "robert",
          "michael",
          "william",
          "david",
          "tyler",
          "roy",
          "andrew",
          "richard",
          "thomas",
          "daniel",
          "anthony",
          "mary",
          "jennifer",
          "emily",
          "susan",
          "valerie",
          "amanda",
          "sam"
        ]
      },
      {
        name: n.GEOGRAPHY,
        label: "Geography",
        values: ["the sphinx", "gizah", "egypt", "africa", "texas"]
      },
      r,
      a,
      i("Number"),
      s("Percentage"),
      o("Ordinal"),
      u("URL"),
      l("Key Phrase"),
      {
        name: n.NATOAPCO,
        label: "NATO/APCO",
        values: [],
        list: [
          { canonicalForm: "Alfa", list: ["Adam", "Alpha"] },
          { canonicalForm: "Bravo", list: ["Boy", "Baker"] },
          { canonicalForm: "Charlie", list: ["Charles"] },
          { canonicalForm: "Delta", list: ["David"] },
          { canonicalForm: "Echo", list: ["Edward", "Easy"] },
          { canonicalForm: "Foxtrot", list: ["Frank"] },
          { canonicalForm: "Golf", list: ["George"] },
          { canonicalForm: "Hotel", list: ["Henry"] },
          { canonicalForm: "India", list: ["Ida"] },
          { canonicalForm: "Juliett", list: ["John"] },
          { canonicalForm: "Kilo", list: ["King"] },
          { canonicalForm: "Lima", list: ["Lincoln"] },
          { canonicalForm: "Mike", list: ["Mary"] },
          { canonicalForm: "November", list: ["Nora"] },
          { canonicalForm: "Oscar", list: ["Ocean"] },
          { canonicalForm: "Papa", list: ["Paul"] },
          { canonicalForm: "Quebec", list: ["Queen"] },
          { canonicalForm: "Romeo", list: ["Robert"] },
          { canonicalForm: "Sierra", list: ["Sam"] },
          { canonicalForm: "Tango", list: ["Tom"] },
          { canonicalForm: "Uniform", list: ["Union"] },
          { canonicalForm: "Victor", list: [] },
          { canonicalForm: "Whiskey", list: ["William"] },
          { canonicalForm: "X-ray", list: ["Xray"] },
          { canonicalForm: "Yankee", list: ["Young", "Yellow"] },
          { canonicalForm: "Zulu", list: ["Zebra"] },
          { canonicalForm: "0", list: ["Zero", "Nadazero"] },
          { canonicalForm: "1", list: ["One", "Wun", "Unaone"] },
          { canonicalForm: "2", list: ["Two", "Too", "Bissotwo"] },
          { canonicalForm: "3", list: ["Three", "Tree", "Terrathree"] },
          { canonicalForm: "4", list: ["Four", "Fower", "Kartefour"] },
          { canonicalForm: "5", list: ["Five", "Fife", "Pantafive"] },
          { canonicalForm: "6", list: ["Six", "Soxisix"] },
          { canonicalForm: "7", list: ["Seven", "Setteseven"] },
          { canonicalForm: "8", list: ["Eight", "Oktoeight"] },
          { canonicalForm: "9", list: ["Nine", "Niner", "Novenine"] },
          { canonicalForm: "00", list: ["Hundred"] },
          { canonicalForm: "000", list: ["Thousand"] },
          { canonicalForm: "-", list: ["Dash", "Hyphen"] },
          { canonicalForm: ".", list: ["Decimal", "Point", "Stop"] }
        ]
      },
      {
        name: n.AGE,
        label: "Age",
        values: ["20 days old", "nineteen years old", "4 weeks old", "8 months old", "45 years-old", "one month old"]
      },
      {
        name: n.CURRENCY,
        label: "Currency",
        values: [
          "5 dollars",
          "1 dollar",
          "one dollar",
          "$8",
          "6 canadian dollars",
          "seven pennies",
          "9 pounds",
          "15 pesos",
          "Four para",
          "87 ruples",
          "thirty rupees",
          "12.34",
          "34.2$"
        ]
      },
      {
        name: n.DATETIME,
        label: "Datetime",
        values: ["May 2nd", "May 25th, 2025", "Tuesday to Thursday", "From 6pm to 7pm", "6:30 pm to 7 pm", "8am", "8:30 pm", "9 am", "10:12 am"]
      },
      {
        name: n.DIMENSION,
        label: "Dimension",
        values: ["10 1/2 miles", "10.5 kilometers", "0.3 mm", "5 feet", "6 yards", "10m", "25 m/s"]
      },
      {
        name: n.TEMPERATURE,
        label: "Temperature",
        values: ["30 degrees", "215 kelvin", "56 f", "33f", "22 degrees celsius", "102 degs farenheit"]
      }
    ],
    [t.Language.DE]: [
      r,
      a,
      {
        name: n.AGE,
        label: "Alter",
        values: ["7 Jahre alt", "acht Mondate alt", "3 wochen alt", "neun Tage alt", "einen tag alt", "1 Jahr alt"]
      },
      i("Nummer"),
      s("Prozentsatz"),
      o("Ordinalzahl"),
      u("URL"),
      l("Schlsselsatz"),
      {
        name: n.CURRENCY,
        label: "Whrung",
        values: ["7 $", "23 Dollar", "dreiig USD", "87 yuan", "11 pfund", "55", "5.99", "neunzehn Pesos"]
      },
      {
        name: n.DATETIME,
        label: "Datum (und Uhrzeit",
        values: ["2. Mai", "25. Mai 2025", "Dienstag bis Donnerstag", "Von 18 bis 19 Uhr", "8 Uhr morgens", "20:30 Uhr"]
      },
      {
        name: n.DIMENSION,
        label: "Dimension",
        values: ["10 1/2 Meilen", "10,5 Kilometer", "0,3 mm", "5 Fu", "6 Yards", "6m", "25 m/s"]
      },
      {
        name: n.TEMPERATURE,
        label: "Temperatur",
        values: ["30 Grad", "215 Kelvin", "56 f", "33f", "22 Grad Celsius", "102 Grad Fahrenheit"]
      }
    ],
    [t.Language.FR]: [
      r,
      a,
      {
        name: n.AGE,
        label: "ge",
        values: [
          "3 ans",
          "Trois ans",
          "2 mois d'ge",
          "six mois d'age",
          "8 mois",
          "huit mois",
          "une semaine",
          "1 semaine",
          "3 semaines",
          "sept semaines d'ge",
          "9 semaines d'age",
          "18 jours",
          "quarante jours",
          "un jour"
        ]
      },
      i("Nombre"),
      s("Pourcentage"),
      o("Nombre ordinal"),
      u("URL"),
      l("Phrase cl"),
      {
        name: n.CURRENCY,
        label: "Monnaie",
        values: ["un dollar", "3 dollars", "5$", "12.09", "33 pence", "Sept sou", "6 livres", "douze pesos", "trois francs", "7 dollars canadien"]
      },
      {
        name: n.DATETIME,
        label: "Date et l'Heure",
        values: ["2 mai", "2 mai 2025", "du mardi au jeudi", "De 18h  19h", "8h00", "20h30"]
      },
      {
        name: n.DIMENSION,
        label: "Dimension",
        values: ["10 1/2 miles", "10,5 kilomtres", "0,3 mm", "5 pieds", "6 yards", "6m", "25 m/s"]
      },
      {
        name: n.TEMPERATURE,
        label: "Temprature",
        values: ["30 degrs", "215 kelvin", "56 f", "33f", "22 degrs Celsius", "102 degs farenheit"]
      }
    ],
    [t.Language.PT]: [
      r,
      a,
      {
        name: n.AGE,
        label: "Idade",
        values: [
          "3 anos",
          "3 anos de idade",
          "1 ano",
          "uma ano",
          "6 meses",
          "1 mes",
          "um ms",
          "7 semanas",
          "uma semana",
          "1 semana",
          "quatro dias",
          "15 dias",
          "1 dia"
        ]
      },
      i("Nmero"),
      s("Porcentagem"),
      o("Nmero ordinal"),
      u("URL"),
      l("Frase chave"),
      {
        name: n.CURRENCY,
        label: "Monnaie",
        values: ["1 dlar", "quatro pesos", "6.01", "5", "11.02 francos"]
      },
      {
        name: n.DATETIME,
        label: "Data e Hora",
        values: ["2 de maio", "2 de maio de 2015", "Tera a quinta", "Das 18h s 19h", "8 horas da manh", "20:30"]
      },
      {
        name: n.DIMENSION,
        label: "Dimenso",
        values: ["10 1/2 milhas ", "10,5 quilmetros", "0,3 mm", "5 ps", "6 jardas", "6m", "25 m/s"]
      },
      {
        name: n.TEMPERATURE,
        label: "Temperatura",
        values: ["30 graus", " 215 Kelvin", "56 f", "33  f", "22 graus Celsius", "102 degs farenheit"]
      }
    ],
    [t.Language.ES]: [
      r,
      a,
      {
        name: n.AGE,
        label: "Edad",
        values: [
          "3 aos",
          "1 ao",
          "un ao",
          "6 meses",
          "6 meses de edad",
          "1 mes",
          "um ms",
          "7 semanas",
          "un semana",
          "1 semana",
          "quatro dias",
          "15 das",
          "1 dia de edad",
          "un da"
        ]
      },
      i("Nmero"),
      s("Porcentaje"),
      o("Nmero ordinal"),
      u("URL"),
      l("Frase clave"),
      {
        name: n.CURRENCY,
        label: "Moneda",
        values: ["5 dlares", "1 peso", "3.2 libras", "Tres rublos", "1 peso dominicano", "4.5 dlares canadienses", "3.5", "9", "tres euros"]
      },
      {
        name: n.DATETIME,
        label: "Fecha y Hora",
        values: ["2 de Mayo", "2 de mayo de 2015", "Martes a jueves", "De 18h a 19h", "8:00AM", "8:30 PM"]
      },
      {
        name: n.DIMENSION,
        label: "Dimensin",
        values: ["10 1/2 millas", "10.5 kilmetros", "0,3 mm", "5 pies", "6 yardas", "10 m", "25 m/s"]
      },
      {
        name: n.TEMPERATURE,
        label: "Temperatura",
        values: ["30 grados", "215 kelvin", "56 f", "33f", "22 grados celsius", "102 grados farenheit"]
      }
    ],
    [t.Language.ZH]: [
      r,
      a,
      {
        name: n.AGE,
        label: "",
        values: ["", "3", "5", "7", "9", "8", "21", "1"]
      },
      i(""),
      s(""),
      o(""),
      u(""),
      {
        name: n.CURRENCY,
        label: "",
        values: ["5 ", "1", "9", "", "8 ", "8", "12 "]
      },
      {
        name: n.DATETIME,
        label: "",
        values: ["May 2nd", "2015  5  2 ", "", " 6  7 ", "", " 8:30"]
      },
      {
        name: n.DIMENSION,
        label: "",
        values: ["10 1/2 ", "10.5 ", "0.3 ", "5 ", "6 ", "7"]
      },
      {
        name: n.TEMPERATURE,
        label: "",
        values: ["30 ", "215 ", "56 f", "33f", "22 ", " 102 ", "34.1"]
      }
    ],
    [t.Language.JA]: [
      r,
      a,
      {
        name: n.AGE,
        label: "",
        values: ["1", "", "2", "4", "3", "6", "5", "9", "10"]
      },
      i(""),
      s(""),
      o(""),
      u("URL"),
      l(""),
      {
        name: n.CURRENCY,
        label: "",
        values: ["88", "123", "7", "87", "5", "44"]
      },
      {
        name: n.DIMENSION,
        label: "",
        values: ["101/2", "10.5", "0.3 mm", "5", "6"]
      },
      {
        name: n.TEMPERATURE,
        label: "",
        values: ["30", "215", "56 f", "33f", "22", "102"]
      }
    ],
    [t.Language.NL]: [
      r,
      a,
      {
        name: n.AGE,
        label: "Leeftijd",
        values: [
          "twintig jaar oud",
          "19 dagen old",
          "negentien dagen oud",
          "4 week oud",
          "8 maand oud",
          "1 jaar oud",
          "3 jaar",
          "4 levensjaren",
          "30 jarige leeftijd",
          "45-jarige leeftijd",
          "2-jarige",
          "5 jarige",
          "6 maand oud",
          "twee maanden",
          "vier weken oud",
          "5 week",
          "zeven weken",
          "6 dag oud",
          "7 dag",
          "negen dagen"
        ]
      },
      i("Aantal"),
      s("Percentage"),
      o("Rangtelwoord"),
      u("URL"),
      l("Sleutelwoord"),
      {
        name: n.CURRENCY,
        label: "Valuta",
        values: ["8 euro", "negen cent", "4 japanse yen", "vier pesos", "11 centen", "33 pence", "5 dollar", "0.12 bitcoin", "drientwintig pond"]
      },
      {
        name: n.DIMENSION,
        label: "Afmeting",
        values: ["10 1/2 mijl", "10,5 kilometer", "0,3 mm", "5 voet", "6 yards", "7m", "25 m/s"]
      },
      {
        name: n.TEMPERATURE,
        label: "Temperatuur",
        values: ["30 graden", "215 kelvin", "56 f", "33f", "22 graden Celsius", "102 graden farenheit"]
      }
    ],
    [t.Language.IT]: [
      r,
      a,
      {
        name: n.AGE,
        label: "Et",
        values: [
          "8 anni di et",
          "sette anni",
          "un anno di et",
          "11 anni d'et",
          "1 anno d'et",
          "di nove anni d'et",
          "4 anni",
          "1 anno",
          "8 mesi di et",
          "sette mesi",
          "un mese di et",
          "11 mesi d'et",
          "1 mese d'et",
          "di nove mesi d'et",
          "1 mese",
          "8 settimane di et",
          "sette settimane",
          "un settimana di et",
          "11 settimane d'et",
          "1 settimana d'et",
          "di nove settimane d'et",
          "1 settimana",
          "8 giorni di et",
          "sette giorni",
          "un giorno di et",
          "11 giorni d'et",
          "1 giorno d'et",
          "di nove giorni d'et",
          "1 giorno"
        ]
      },
      i("Numero"),
      s("Percentuale"),
      o("Numero ordinale"),
      u("URL"),
      l("Frase chiave"),
      {
        name: n.CURRENCY,
        label: "Valuta",
        values: ["5 dollari", "9.10 dollari canadesi", "6 sterline", "$4.1", "quattro pence", "24 pesos", "84 ", "99.12"]
      },
      {
        name: n.DIMENSION,
        label: "Dimensione",
        values: ["10 1/2 miglia", "10,5 chilometri", "0,3 mm", "5 piedi", "6 iarde", "8m", "25 m/s"]
      },
      {
        name: n.TEMPERATURE,
        label: "Temperatura",
        values: ["30 gradi", "215 kelvin", "56 f", "33f", "22 gradi Celsius", "102 gradi fanheit"]
      }
    ],
    [t.Language.KO]: [r, a, u("URL"), l(" ")],
    // Mexico Spanish has much less built in entities than Spain Spanish.
    // There is a case in getSlotTypes in realtime-sdk for this
    [t.Locale.ES_MX]: [r, i("Nmero"), u("URL"), l("Frase clave")]
  };
})(Gb);
var Yb = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.BuiltInVariable = void 0, function(t) {
    t.LOCALE = "locale", t.CHANNEL = "channel", t.USER_ID = "user_id", t.SESSIONS = "sessions", t.PLATFORM = "platform", t.TIMESTAMP = "timestamp", t.INTENT_CONFIDENCE = "intent_confidence", t.LAST_UTTERANCE = "last_utterance", t.LAST_RESPONSE = "last_response", t.LAST_EVENT = "last_event";
  }(e.BuiltInVariable || (e.BuiltInVariable = {}));
})(Yb);
(function(e) {
  var t = je && je.__createBinding || (Object.create ? function(r, a, i, s) {
    s === void 0 && (s = i);
    var o = Object.getOwnPropertyDescriptor(a, i);
    (!o || ("get" in o ? !a.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
      return a[i];
    } }), Object.defineProperty(r, s, o);
  } : function(r, a, i, s) {
    s === void 0 && (s = i), r[s] = a[i];
  }), n = je && je.__exportStar || function(r, a) {
    for (var i in r)
      i !== "default" && !Object.prototype.hasOwnProperty.call(a, i) && t(a, r, i);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(Au, e), n(_u, e), n(yu, e), n(zb, e), n(Su, e), n(Vb, e), n(Gb, e), n(Yb, e);
})(jb);
Object.defineProperty(Tu, "__esModule", { value: !0 });
Tu.defaultBaseSettings = void 0;
const ED = jb, vD = ({ locales: e = [ED.Locale.EN_US] } = {}) => ({
  locales: e
});
Tu.defaultBaseSettings = vD;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultChatSettings = e.defaultSharedChatSettings = void 0;
  const t = Hb, n = Tu, r = (i = {}) => Object.assign({}, t.ChatVersion.defaultSettings(i));
  e.defaultSharedChatSettings = r;
  const a = (i = {}) => Object.assign(Object.assign({}, (0, e.defaultSharedChatSettings)(i)), (0, n.defaultBaseSettings)(i));
  e.defaultChatSettings = a;
})(pf);
var Wb = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ChatPosition = e.ChatPersistence = void 0, function(t) {
    t.MEMORY = "memory", t.LOCAL_STORAGE = "localStorage", t.SESSION_STORAGE = "sessionStorage";
  }(e.ChatPersistence || (e.ChatPersistence = {})), function(t) {
    t.LEFT = "left", t.RIGHT = "right";
  }(e.ChatPosition || (e.ChatPosition = {}));
})(Wb);
(function(e) {
  var t = je && je.__createBinding || (Object.create ? function(u, l, f, h) {
    h === void 0 && (h = f);
    var p = Object.getOwnPropertyDescriptor(l, f);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[f];
    } }), Object.defineProperty(u, h, p);
  } : function(u, l, f, h) {
    h === void 0 && (h = f), u[h] = l[f];
  }), n = je && je.__exportStar || function(u, l) {
    for (var f in u)
      f !== "default" && !Object.prototype.hasOwnProperty.call(l, f) && t(l, u, f);
  }, r = je && je.__rest || function(u, l) {
    var f = {};
    for (var h in u)
      Object.prototype.hasOwnProperty.call(u, h) && l.indexOf(h) < 0 && (f[h] = u[h]);
    if (u != null && typeof Object.getOwnPropertySymbols == "function")
      for (var p = 0, h = Object.getOwnPropertySymbols(u); p < h.length; p++)
        l.indexOf(h[p]) < 0 && Object.prototype.propertyIsEnumerable.call(u, h[p]) && (f[h[p]] = u[h[p]]);
    return f;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultChatPlatformData = e.defaultSharedChatPlatformData = void 0;
  const a = Hb, i = pf;
  n(Wb, e), n(pf, e);
  const s = (u) => {
    var { settings: l } = u, f = r(u, ["settings"]);
    return Object.assign(Object.assign({}, a.ChatVersion.defaultPlatformData(f)), { settings: (0, i.defaultSharedChatSettings)(l) });
  };
  e.defaultSharedChatPlatformData = s;
  const o = (u) => {
    var { settings: l } = u, f = r(u, ["settings"]);
    return Object.assign(Object.assign({}, (0, e.defaultSharedChatPlatformData)(f)), { settings: (0, i.defaultChatSettings)(l) });
  };
  e.defaultChatPlatformData = o;
})(Un);
var or = /* @__PURE__ */ ((e) => (e.IDLE = "IDLE", e.ACTIVE = "ACTIVE", e.ENDED = "ENDED", e))(or || {}), hi = /* @__PURE__ */ ((e) => (e.USER = "user", e.SYSTEM = "system", e))(hi || {});
const TD = /^about:[\w#%+.:=@~-]{2,256}\b([\w#%&+./:=?@~-]*)$/, AD = /^bitcoin:[\dA-Za-z]{26,35}([\w#%&+./:=?@~-]*)$/, _D = /^callto:[+\d-\s()]+$/, yD = /^tel:[+\d-\s()]+$/, SD = /^sms:[+\d-\s()]+$/, CD = /^mailto:([^\s?]+)\b([\w#%&+./:=?@~-]*)$/, OD = /^im:([^\s?]+)\b([\w#%&+./:=?@~-]*)$/, ID = /^facetime(-(audio|group))?:([^\s?]+|([+\d-()]+))$/, xD = /^skype:(\S+)\b$/, ND = /^webcal:(\S+)\b$/, RD = [
  TD,
  AD,
  _D,
  yD,
  SD,
  CD,
  OD,
  ID,
  xD,
  ND
], kD = (e) => !!RD.some((t) => e.match(t)), wD = (e) => e.startsWith("//") || e.includes("://") || kD(e) ? e : `//${e}`, DD = (e, t = "noopener=true,noreferrer=true") => {
  var n;
  return (n = window.open(wD(e), "_blank", t)) == null ? void 0 : n.focus();
}, PD = (e) => !!e.payload && typeof e.payload == "object" && Array.isArray(e.payload.actions), LD = (e) => {
  var t;
  PD(e) && ((t = e.payload.actions) == null || t.forEach((n) => {
    ub(n) && n.payload.url && DD(n.payload.url);
  }));
};
var ns = /* @__PURE__ */ ((e) => (e.SAVE_SESSION = "voiceflow:save_session", e.INTERACT = "voiceflow:interact", e.OPEN = "voiceflow:open", e.CLOSE = "voiceflow:close", e))(ns || {});
const Ao = (e) => {
  const t = JSON.stringify(e);
  window.postMessage(t);
}, MD = "voiceflow-session", Uo = (e) => `${MD}-${e}`, $D = (e, t) => {
  try {
    return JSON.parse(e.getItem(Uo(t)));
  } catch {
    return null;
  }
}, gf = (e, t, n) => (e.setItem(Uo(t), JSON.stringify(n)), n), u0 = (e, t, n) => {
  const r = $D(e, t);
  return !r || n && r.userID !== n ? gf(e, t, { userID: n || Es() }) : r;
}, BD = (e, t, n) => {
  switch (e) {
    case Un.ChatPersistence.MEMORY:
      return { userID: n || Es() };
    case Un.ChatPersistence.LOCAL_STORAGE:
      return u0(localStorage, t, n);
    case Un.ChatPersistence.SESSION_STORAGE:
    default:
      return u0(sessionStorage, t, n);
  }
}, l0 = (e, t, n) => {
  Ao({ type: ns.SAVE_SESSION, payload: n }), e === Un.ChatPersistence.LOCAL_STORAGE ? gf(localStorage, t, n) : e === Un.ChatPersistence.SESSION_STORAGE && gf(sessionStorage, t, n), e !== Un.ChatPersistence.LOCAL_STORAGE && localStorage.removeItem(Uo(t)), e !== Un.ChatPersistence.SESSION_STORAGE && sessionStorage.removeItem(Uo(t));
};
var mt;
(function(e) {
  e.assertEqual = (a) => a;
  function t(a) {
  }
  e.assertIs = t;
  function n(a) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (a) => {
    const i = {};
    for (const s of a)
      i[s] = s;
    return i;
  }, e.getValidEnumValues = (a) => {
    const i = e.objectKeys(a).filter((o) => typeof a[a[o]] != "number"), s = {};
    for (const o of i)
      s[o] = a[o];
    return e.objectValues(s);
  }, e.objectValues = (a) => e.objectKeys(a).map(function(i) {
    return a[i];
  }), e.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
    const i = [];
    for (const s in a)
      Object.prototype.hasOwnProperty.call(a, s) && i.push(s);
    return i;
  }, e.find = (a, i) => {
    for (const s of a)
      if (i(s))
        return s;
  }, e.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  function r(a, i = " | ") {
    return a.map((s) => typeof s == "string" ? `'${s}'` : s).join(i);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (a, i) => typeof i == "bigint" ? i.toString() : i;
})(mt || (mt = {}));
var bf;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(bf || (bf = {}));
const _e = mt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), ta = (e) => {
  switch (typeof e) {
    case "undefined":
      return _e.undefined;
    case "string":
      return _e.string;
    case "number":
      return isNaN(e) ? _e.nan : _e.number;
    case "boolean":
      return _e.boolean;
    case "function":
      return _e.function;
    case "bigint":
      return _e.bigint;
    case "symbol":
      return _e.symbol;
    case "object":
      return Array.isArray(e) ? _e.array : e === null ? _e.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? _e.promise : typeof Map < "u" && e instanceof Map ? _e.map : typeof Set < "u" && e instanceof Set ? _e.set : typeof Date < "u" && e instanceof Date ? _e.date : _e.object;
    default:
      return _e.unknown;
  }
}, Ee = mt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), FD = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class lr extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(i) {
      return i.message;
    }, r = { _errors: [] }, a = (i) => {
      for (const s of i.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(a);
        else if (s.code === "invalid_return_type")
          a(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          a(s.argumentsError);
        else if (s.path.length === 0)
          r._errors.push(n(s));
        else {
          let o = r, u = 0;
          for (; u < s.path.length; ) {
            const l = s.path[u];
            u === s.path.length - 1 ? (o[l] = o[l] || { _errors: [] }, o[l]._errors.push(n(s))) : o[l] = o[l] || { _errors: [] }, o = o[l], u++;
          }
        }
    };
    return a(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, mt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const a of this.issues)
      a.path.length > 0 ? (n[a.path[0]] = n[a.path[0]] || [], n[a.path[0]].push(t(a))) : r.push(t(a));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
lr.create = (e) => new lr(e);
const vs = (e, t) => {
  let n;
  switch (e.code) {
    case Ee.invalid_type:
      e.received === _e.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case Ee.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, mt.jsonStringifyReplacer)}`;
      break;
    case Ee.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${mt.joinValues(e.keys, ", ")}`;
      break;
    case Ee.invalid_union:
      n = "Invalid input";
      break;
    case Ee.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${mt.joinValues(e.options)}`;
      break;
    case Ee.invalid_enum_value:
      n = `Invalid enum value. Expected ${mt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case Ee.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case Ee.invalid_return_type:
      n = "Invalid function return type";
      break;
    case Ee.invalid_date:
      n = "Invalid date";
      break;
    case Ee.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : mt.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case Ee.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case Ee.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case Ee.custom:
      n = "Invalid input";
      break;
    case Ee.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case Ee.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case Ee.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, mt.assertNever(e);
  }
  return { message: n };
};
let qb = vs;
function UD(e) {
  qb = e;
}
function Ho() {
  return qb;
}
const jo = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: a } = e, i = [...n, ...a.path || []], s = {
    ...a,
    path: i
  };
  let o = "";
  const u = r.filter((l) => !!l).slice().reverse();
  for (const l of u)
    o = l(s, { data: t, defaultError: o }).message;
  return {
    ...a,
    path: i,
    message: a.message || o
  };
}, HD = [];
function ye(e, t) {
  const n = jo({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Ho(),
      vs
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
class dn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const a of n) {
      if (a.status === "aborted")
        return ze;
      a.status === "dirty" && t.dirty(), r.push(a.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const a of n)
      r.push({
        key: await a.key,
        value: await a.value
      });
    return dn.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const a of n) {
      const { key: i, value: s } = a;
      if (i.status === "aborted" || s.status === "aborted")
        return ze;
      i.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), i.value !== "__proto__" && (typeof s.value < "u" || a.alwaysSet) && (r[i.value] = s.value);
    }
    return { status: t.value, value: r };
  }
}
const ze = Object.freeze({
  status: "aborted"
}), Kb = (e) => ({ status: "dirty", value: e }), yn = (e) => ({ status: "valid", value: e }), Ef = (e) => e.status === "aborted", vf = (e) => e.status === "dirty", Ts = (e) => e.status === "valid", zo = (e) => typeof Promise < "u" && e instanceof Promise;
var xe;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(xe || (xe = {}));
class Cr {
  constructor(t, n, r, a) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = a;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const c0 = (e, t) => {
  if (Ts(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new lr(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function Ve(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: a } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: a } : { errorMap: (s, o) => s.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: r ?? o.defaultError } : { message: n ?? o.defaultError }, description: a };
}
class Ye {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return ta(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: ta(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new dn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: ta(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (zo(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const a = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ta(t)
    }, i = this._parseSync({ data: t, path: a.path, parent: a });
    return c0(a, i);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ta(t)
    }, a = this._parse({ data: t, path: r.path, parent: r }), i = await (zo(a) ? a : Promise.resolve(a));
    return c0(r, i);
  }
  refine(t, n) {
    const r = (a) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(a) : n;
    return this._refinement((a, i) => {
      const s = t(a), o = () => i.addIssue({
        code: Ee.custom,
        ...r(a)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((u) => u ? !0 : (o(), !1)) : s ? !0 : (o(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, a) => t(r) ? !0 : (a.addIssue(typeof n == "function" ? n(r, a) : n), !1));
  }
  _refinement(t) {
    return new dr({
      schema: this,
      typeName: $e.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return $r.create(this, this._def);
  }
  nullable() {
    return wa.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return cr.create(this, this._def);
  }
  promise() {
    return bi.create(this, this._def);
  }
  or(t) {
    return Ss.create([this, t], this._def);
  }
  and(t) {
    return Cs.create(this, t, this._def);
  }
  transform(t) {
    return new dr({
      ...Ve(this._def),
      schema: this,
      typeName: $e.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Rs({
      ...Ve(this._def),
      innerType: this,
      defaultValue: n,
      typeName: $e.ZodDefault
    });
  }
  brand() {
    return new Zb({
      typeName: $e.ZodBranded,
      type: this,
      ...Ve(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Wo({
      ...Ve(this._def),
      innerType: this,
      catchValue: n,
      typeName: $e.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Bs.create(this, t);
  }
  readonly() {
    return Ko.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const jD = /^c[^\s-]{8,}$/i, zD = /^[a-z][a-z0-9]*$/, VD = /^[0-9A-HJKMNP-TV-Z]{26}$/, GD = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, YD = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, WD = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Rl;
const qD = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, KD = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, XD = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function ZD(e, t) {
  return !!((t === "v4" || !t) && qD.test(e) || (t === "v6" || !t) && KD.test(e));
}
class ur extends Ye {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== _e.string) {
      const i = this._getOrReturnCtx(t);
      return ye(
        i,
        {
          code: Ee.invalid_type,
          expected: _e.string,
          received: i.parsedType
        }
        //
      ), ze;
    }
    const r = new dn();
    let a;
    for (const i of this._def.checks)
      if (i.kind === "min")
        t.data.length < i.value && (a = this._getOrReturnCtx(t, a), ye(a, {
          code: Ee.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "max")
        t.data.length > i.value && (a = this._getOrReturnCtx(t, a), ye(a, {
          code: Ee.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "length") {
        const s = t.data.length > i.value, o = t.data.length < i.value;
        (s || o) && (a = this._getOrReturnCtx(t, a), s ? ye(a, {
          code: Ee.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : o && ye(a, {
          code: Ee.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), r.dirty());
      } else if (i.kind === "email")
        YD.test(t.data) || (a = this._getOrReturnCtx(t, a), ye(a, {
          validation: "email",
          code: Ee.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "emoji")
        Rl || (Rl = new RegExp(WD, "u")), Rl.test(t.data) || (a = this._getOrReturnCtx(t, a), ye(a, {
          validation: "emoji",
          code: Ee.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "uuid")
        GD.test(t.data) || (a = this._getOrReturnCtx(t, a), ye(a, {
          validation: "uuid",
          code: Ee.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid")
        jD.test(t.data) || (a = this._getOrReturnCtx(t, a), ye(a, {
          validation: "cuid",
          code: Ee.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid2")
        zD.test(t.data) || (a = this._getOrReturnCtx(t, a), ye(a, {
          validation: "cuid2",
          code: Ee.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "ulid")
        VD.test(t.data) || (a = this._getOrReturnCtx(t, a), ye(a, {
          validation: "ulid",
          code: Ee.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "url")
        try {
          new URL(t.data);
        } catch {
          a = this._getOrReturnCtx(t, a), ye(a, {
            validation: "url",
            code: Ee.invalid_string,
            message: i.message
          }), r.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(t.data) || (a = this._getOrReturnCtx(t, a), ye(a, {
          validation: "regex",
          code: Ee.invalid_string,
          message: i.message
        }), r.dirty())) : i.kind === "trim" ? t.data = t.data.trim() : i.kind === "includes" ? t.data.includes(i.value, i.position) || (a = this._getOrReturnCtx(t, a), ye(a, {
          code: Ee.invalid_string,
          validation: { includes: i.value, position: i.position },
          message: i.message
        }), r.dirty()) : i.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : i.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : i.kind === "startsWith" ? t.data.startsWith(i.value) || (a = this._getOrReturnCtx(t, a), ye(a, {
          code: Ee.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), r.dirty()) : i.kind === "endsWith" ? t.data.endsWith(i.value) || (a = this._getOrReturnCtx(t, a), ye(a, {
          code: Ee.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), r.dirty()) : i.kind === "datetime" ? XD(i).test(t.data) || (a = this._getOrReturnCtx(t, a), ye(a, {
          code: Ee.invalid_string,
          validation: "datetime",
          message: i.message
        }), r.dirty()) : i.kind === "ip" ? ZD(t.data, i.version) || (a = this._getOrReturnCtx(t, a), ye(a, {
          validation: "ip",
          code: Ee.invalid_string,
          message: i.message
        }), r.dirty()) : mt.assertNever(i);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((a) => t.test(a), {
      validation: n,
      code: Ee.invalid_string,
      ...xe.errToObj(r)
    });
  }
  _addCheck(t) {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...xe.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...xe.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...xe.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...xe.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...xe.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...xe.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...xe.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...xe.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      ...xe.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...xe.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...xe.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...xe.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...xe.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...xe.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...xe.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...xe.errToObj(n)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, xe.errToObj(t));
  }
  trim() {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
ur.create = (e) => {
  var t;
  return new ur({
    checks: [],
    typeName: $e.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Ve(e)
  });
};
function QD(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, a = n > r ? n : r, i = parseInt(e.toFixed(a).replace(".", "")), s = parseInt(t.toFixed(a).replace(".", ""));
  return i % s / Math.pow(10, a);
}
class ia extends Ye {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== _e.number) {
      const i = this._getOrReturnCtx(t);
      return ye(i, {
        code: Ee.invalid_type,
        expected: _e.number,
        received: i.parsedType
      }), ze;
    }
    let r;
    const a = new dn();
    for (const i of this._def.checks)
      i.kind === "int" ? mt.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), ye(r, {
        code: Ee.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), a.dirty()) : i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (r = this._getOrReturnCtx(t, r), ye(r, {
        code: Ee.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), a.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (r = this._getOrReturnCtx(t, r), ye(r, {
        code: Ee.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), a.dirty()) : i.kind === "multipleOf" ? QD(t.data, i.value) !== 0 && (r = this._getOrReturnCtx(t, r), ye(r, {
        code: Ee.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), a.dirty()) : i.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), ye(r, {
        code: Ee.not_finite,
        message: i.message
      }), a.dirty()) : mt.assertNever(i);
    return { status: a.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, xe.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, xe.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, xe.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, xe.toString(n));
  }
  setLimit(t, n, r, a) {
    return new ia({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: xe.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new ia({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: xe.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: xe.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: xe.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: xe.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: xe.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: xe.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: xe.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: xe.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: xe.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && mt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
ia.create = (e) => new ia({
  checks: [],
  typeName: $e.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Ve(e)
});
class sa extends Ye {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== _e.bigint) {
      const i = this._getOrReturnCtx(t);
      return ye(i, {
        code: Ee.invalid_type,
        expected: _e.bigint,
        received: i.parsedType
      }), ze;
    }
    let r;
    const a = new dn();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (r = this._getOrReturnCtx(t, r), ye(r, {
        code: Ee.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), a.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (r = this._getOrReturnCtx(t, r), ye(r, {
        code: Ee.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), a.dirty()) : i.kind === "multipleOf" ? t.data % i.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), ye(r, {
        code: Ee.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), a.dirty()) : mt.assertNever(i);
    return { status: a.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, xe.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, xe.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, xe.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, xe.toString(n));
  }
  setLimit(t, n, r, a) {
    return new sa({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: xe.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new sa({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: xe.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: xe.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: xe.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: xe.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: xe.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
sa.create = (e) => {
  var t;
  return new sa({
    checks: [],
    typeName: $e.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Ve(e)
  });
};
class As extends Ye {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== _e.boolean) {
      const r = this._getOrReturnCtx(t);
      return ye(r, {
        code: Ee.invalid_type,
        expected: _e.boolean,
        received: r.parsedType
      }), ze;
    }
    return yn(t.data);
  }
}
As.create = (e) => new As({
  typeName: $e.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Ve(e)
});
class Ra extends Ye {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== _e.date) {
      const i = this._getOrReturnCtx(t);
      return ye(i, {
        code: Ee.invalid_type,
        expected: _e.date,
        received: i.parsedType
      }), ze;
    }
    if (isNaN(t.data.getTime())) {
      const i = this._getOrReturnCtx(t);
      return ye(i, {
        code: Ee.invalid_date
      }), ze;
    }
    const r = new dn();
    let a;
    for (const i of this._def.checks)
      i.kind === "min" ? t.data.getTime() < i.value && (a = this._getOrReturnCtx(t, a), ye(a, {
        code: Ee.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? t.data.getTime() > i.value && (a = this._getOrReturnCtx(t, a), ye(a, {
        code: Ee.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : mt.assertNever(i);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Ra({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: xe.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: xe.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
Ra.create = (e) => new Ra({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: $e.ZodDate,
  ...Ve(e)
});
class Vo extends Ye {
  _parse(t) {
    if (this._getType(t) !== _e.symbol) {
      const r = this._getOrReturnCtx(t);
      return ye(r, {
        code: Ee.invalid_type,
        expected: _e.symbol,
        received: r.parsedType
      }), ze;
    }
    return yn(t.data);
  }
}
Vo.create = (e) => new Vo({
  typeName: $e.ZodSymbol,
  ...Ve(e)
});
class _s extends Ye {
  _parse(t) {
    if (this._getType(t) !== _e.undefined) {
      const r = this._getOrReturnCtx(t);
      return ye(r, {
        code: Ee.invalid_type,
        expected: _e.undefined,
        received: r.parsedType
      }), ze;
    }
    return yn(t.data);
  }
}
_s.create = (e) => new _s({
  typeName: $e.ZodUndefined,
  ...Ve(e)
});
class ys extends Ye {
  _parse(t) {
    if (this._getType(t) !== _e.null) {
      const r = this._getOrReturnCtx(t);
      return ye(r, {
        code: Ee.invalid_type,
        expected: _e.null,
        received: r.parsedType
      }), ze;
    }
    return yn(t.data);
  }
}
ys.create = (e) => new ys({
  typeName: $e.ZodNull,
  ...Ve(e)
});
class gi extends Ye {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return yn(t.data);
  }
}
gi.create = (e) => new gi({
  typeName: $e.ZodAny,
  ...Ve(e)
});
class Ia extends Ye {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return yn(t.data);
  }
}
Ia.create = (e) => new Ia({
  typeName: $e.ZodUnknown,
  ...Ve(e)
});
class Fr extends Ye {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return ye(n, {
      code: Ee.invalid_type,
      expected: _e.never,
      received: n.parsedType
    }), ze;
  }
}
Fr.create = (e) => new Fr({
  typeName: $e.ZodNever,
  ...Ve(e)
});
class Go extends Ye {
  _parse(t) {
    if (this._getType(t) !== _e.undefined) {
      const r = this._getOrReturnCtx(t);
      return ye(r, {
        code: Ee.invalid_type,
        expected: _e.void,
        received: r.parsedType
      }), ze;
    }
    return yn(t.data);
  }
}
Go.create = (e) => new Go({
  typeName: $e.ZodVoid,
  ...Ve(e)
});
class cr extends Ye {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), a = this._def;
    if (n.parsedType !== _e.array)
      return ye(n, {
        code: Ee.invalid_type,
        expected: _e.array,
        received: n.parsedType
      }), ze;
    if (a.exactLength !== null) {
      const s = n.data.length > a.exactLength.value, o = n.data.length < a.exactLength.value;
      (s || o) && (ye(n, {
        code: s ? Ee.too_big : Ee.too_small,
        minimum: o ? a.exactLength.value : void 0,
        maximum: s ? a.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: a.exactLength.message
      }), r.dirty());
    }
    if (a.minLength !== null && n.data.length < a.minLength.value && (ye(n, {
      code: Ee.too_small,
      minimum: a.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.minLength.message
    }), r.dirty()), a.maxLength !== null && n.data.length > a.maxLength.value && (ye(n, {
      code: Ee.too_big,
      maximum: a.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((s, o) => a.type._parseAsync(new Cr(n, s, n.path, o)))).then((s) => dn.mergeArray(r, s));
    const i = [...n.data].map((s, o) => a.type._parseSync(new Cr(n, s, n.path, o)));
    return dn.mergeArray(r, i);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new cr({
      ...this._def,
      minLength: { value: t, message: xe.toString(n) }
    });
  }
  max(t, n) {
    return new cr({
      ...this._def,
      maxLength: { value: t, message: xe.toString(n) }
    });
  }
  length(t, n) {
    return new cr({
      ...this._def,
      exactLength: { value: t, message: xe.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
cr.create = (e, t) => new cr({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: $e.ZodArray,
  ...Ve(t)
});
function oi(e) {
  if (e instanceof Bt) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = $r.create(oi(r));
    }
    return new Bt({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof cr ? new cr({
      ...e._def,
      type: oi(e.element)
    }) : e instanceof $r ? $r.create(oi(e.unwrap())) : e instanceof wa ? wa.create(oi(e.unwrap())) : e instanceof Or ? Or.create(e.items.map((t) => oi(t))) : e;
}
class Bt extends Ye {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = mt.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== _e.object) {
      const l = this._getOrReturnCtx(t);
      return ye(l, {
        code: Ee.invalid_type,
        expected: _e.object,
        received: l.parsedType
      }), ze;
    }
    const { status: r, ctx: a } = this._processInputParams(t), { shape: i, keys: s } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Fr && this._def.unknownKeys === "strip"))
      for (const l in a.data)
        s.includes(l) || o.push(l);
    const u = [];
    for (const l of s) {
      const f = i[l], h = a.data[l];
      u.push({
        key: { status: "valid", value: l },
        value: f._parse(new Cr(a, h, a.path, l)),
        alwaysSet: l in a.data
      });
    }
    if (this._def.catchall instanceof Fr) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const f of o)
          u.push({
            key: { status: "valid", value: f },
            value: { status: "valid", value: a.data[f] }
          });
      else if (l === "strict")
        o.length > 0 && (ye(a, {
          code: Ee.unrecognized_keys,
          keys: o
        }), r.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const f of o) {
        const h = a.data[f];
        u.push({
          key: { status: "valid", value: f },
          value: l._parse(
            new Cr(a, h, a.path, f)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: f in a.data
        });
      }
    }
    return a.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const f of u) {
        const h = await f.key;
        l.push({
          key: h,
          value: await f.value,
          alwaysSet: f.alwaysSet
        });
      }
      return l;
    }).then((l) => dn.mergeObjectSync(r, l)) : dn.mergeObjectSync(r, u);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return xe.errToObj, new Bt({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var a, i, s, o;
          const u = (s = (i = (a = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(a, n, r).message) !== null && s !== void 0 ? s : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (o = xe.errToObj(t).message) !== null && o !== void 0 ? o : u
          } : {
            message: u
          };
        }
      } : {}
    });
  }
  strip() {
    return new Bt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Bt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Bt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Bt({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: $e.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Bt({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return mt.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new Bt({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return mt.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new Bt({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return oi(this);
  }
  partial(t) {
    const n = {};
    return mt.objectKeys(this.shape).forEach((r) => {
      const a = this.shape[r];
      t && !t[r] ? n[r] = a : n[r] = a.optional();
    }), new Bt({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return mt.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let i = this.shape[r];
        for (; i instanceof $r; )
          i = i._def.innerType;
        n[r] = i;
      }
    }), new Bt({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return Xb(mt.objectKeys(this.shape));
  }
}
Bt.create = (e, t) => new Bt({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Fr.create(),
  typeName: $e.ZodObject,
  ...Ve(t)
});
Bt.strictCreate = (e, t) => new Bt({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Fr.create(),
  typeName: $e.ZodObject,
  ...Ve(t)
});
Bt.lazycreate = (e, t) => new Bt({
  shape: e,
  unknownKeys: "strip",
  catchall: Fr.create(),
  typeName: $e.ZodObject,
  ...Ve(t)
});
class Ss extends Ye {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function a(i) {
      for (const o of i)
        if (o.result.status === "valid")
          return o.result;
      for (const o of i)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const s = i.map((o) => new lr(o.ctx.common.issues));
      return ye(n, {
        code: Ee.invalid_union,
        unionErrors: s
      }), ze;
    }
    if (n.common.async)
      return Promise.all(r.map(async (i) => {
        const s = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: s
          }),
          ctx: s
        };
      })).then(a);
    {
      let i;
      const s = [];
      for (const u of r) {
        const l = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, f = u._parseSync({
          data: n.data,
          path: n.path,
          parent: l
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !i && (i = { result: f, ctx: l }), l.common.issues.length && s.push(l.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const o = s.map((u) => new lr(u));
      return ye(n, {
        code: Ee.invalid_union,
        unionErrors: o
      }), ze;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ss.create = (e, t) => new Ss({
  options: e,
  typeName: $e.ZodUnion,
  ...Ve(t)
});
const _o = (e) => e instanceof Is ? _o(e.schema) : e instanceof dr ? _o(e.innerType()) : e instanceof xs ? [e.value] : e instanceof oa ? e.options : e instanceof Ns ? Object.keys(e.enum) : e instanceof Rs ? _o(e._def.innerType) : e instanceof _s ? [void 0] : e instanceof ys ? [null] : null;
class Cu extends Ye {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== _e.object)
      return ye(n, {
        code: Ee.invalid_type,
        expected: _e.object,
        received: n.parsedType
      }), ze;
    const r = this.discriminator, a = n.data[r], i = this.optionsMap.get(a);
    return i ? n.common.async ? i._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : i._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (ye(n, {
      code: Ee.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), ze);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const a = /* @__PURE__ */ new Map();
    for (const i of n) {
      const s = _o(i.shape[t]);
      if (!s)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const o of s) {
        if (a.has(o))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(o)}`);
        a.set(o, i);
      }
    }
    return new Cu({
      typeName: $e.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: a,
      ...Ve(r)
    });
  }
}
function Tf(e, t) {
  const n = ta(e), r = ta(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === _e.object && r === _e.object) {
    const a = mt.objectKeys(t), i = mt.objectKeys(e).filter((o) => a.indexOf(o) !== -1), s = { ...e, ...t };
    for (const o of i) {
      const u = Tf(e[o], t[o]);
      if (!u.valid)
        return { valid: !1 };
      s[o] = u.data;
    }
    return { valid: !0, data: s };
  } else if (n === _e.array && r === _e.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const a = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i], o = t[i], u = Tf(s, o);
      if (!u.valid)
        return { valid: !1 };
      a.push(u.data);
    }
    return { valid: !0, data: a };
  } else
    return n === _e.date && r === _e.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class Cs extends Ye {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), a = (i, s) => {
      if (Ef(i) || Ef(s))
        return ze;
      const o = Tf(i.value, s.value);
      return o.valid ? ((vf(i) || vf(s)) && n.dirty(), { status: n.value, value: o.data }) : (ye(r, {
        code: Ee.invalid_intersection_types
      }), ze);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([i, s]) => a(i, s)) : a(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Cs.create = (e, t, n) => new Cs({
  left: e,
  right: t,
  typeName: $e.ZodIntersection,
  ...Ve(n)
});
class Or extends Ye {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== _e.array)
      return ye(r, {
        code: Ee.invalid_type,
        expected: _e.array,
        received: r.parsedType
      }), ze;
    if (r.data.length < this._def.items.length)
      return ye(r, {
        code: Ee.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), ze;
    !this._def.rest && r.data.length > this._def.items.length && (ye(r, {
      code: Ee.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const i = [...r.data].map((s, o) => {
      const u = this._def.items[o] || this._def.rest;
      return u ? u._parse(new Cr(r, s, r.path, o)) : null;
    }).filter((s) => !!s);
    return r.common.async ? Promise.all(i).then((s) => dn.mergeArray(n, s)) : dn.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Or({
      ...this._def,
      rest: t
    });
  }
}
Or.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Or({
    items: e,
    typeName: $e.ZodTuple,
    rest: null,
    ...Ve(t)
  });
};
class Os extends Ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== _e.object)
      return ye(r, {
        code: Ee.invalid_type,
        expected: _e.object,
        received: r.parsedType
      }), ze;
    const a = [], i = this._def.keyType, s = this._def.valueType;
    for (const o in r.data)
      a.push({
        key: i._parse(new Cr(r, o, r.path, o)),
        value: s._parse(new Cr(r, r.data[o], r.path, o))
      });
    return r.common.async ? dn.mergeObjectAsync(n, a) : dn.mergeObjectSync(n, a);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof Ye ? new Os({
      keyType: t,
      valueType: n,
      typeName: $e.ZodRecord,
      ...Ve(r)
    }) : new Os({
      keyType: ur.create(),
      valueType: t,
      typeName: $e.ZodRecord,
      ...Ve(n)
    });
  }
}
class Yo extends Ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== _e.map)
      return ye(r, {
        code: Ee.invalid_type,
        expected: _e.map,
        received: r.parsedType
      }), ze;
    const a = this._def.keyType, i = this._def.valueType, s = [...r.data.entries()].map(([o, u], l) => ({
      key: a._parse(new Cr(r, o, r.path, [l, "key"])),
      value: i._parse(new Cr(r, u, r.path, [l, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const u of s) {
          const l = await u.key, f = await u.value;
          if (l.status === "aborted" || f.status === "aborted")
            return ze;
          (l.status === "dirty" || f.status === "dirty") && n.dirty(), o.set(l.value, f.value);
        }
        return { status: n.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const u of s) {
        const l = u.key, f = u.value;
        if (l.status === "aborted" || f.status === "aborted")
          return ze;
        (l.status === "dirty" || f.status === "dirty") && n.dirty(), o.set(l.value, f.value);
      }
      return { status: n.value, value: o };
    }
  }
}
Yo.create = (e, t, n) => new Yo({
  valueType: t,
  keyType: e,
  typeName: $e.ZodMap,
  ...Ve(n)
});
class ka extends Ye {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== _e.set)
      return ye(r, {
        code: Ee.invalid_type,
        expected: _e.set,
        received: r.parsedType
      }), ze;
    const a = this._def;
    a.minSize !== null && r.data.size < a.minSize.value && (ye(r, {
      code: Ee.too_small,
      minimum: a.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.minSize.message
    }), n.dirty()), a.maxSize !== null && r.data.size > a.maxSize.value && (ye(r, {
      code: Ee.too_big,
      maximum: a.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function s(u) {
      const l = /* @__PURE__ */ new Set();
      for (const f of u) {
        if (f.status === "aborted")
          return ze;
        f.status === "dirty" && n.dirty(), l.add(f.value);
      }
      return { status: n.value, value: l };
    }
    const o = [...r.data.values()].map((u, l) => i._parse(new Cr(r, u, r.path, l)));
    return r.common.async ? Promise.all(o).then((u) => s(u)) : s(o);
  }
  min(t, n) {
    return new ka({
      ...this._def,
      minSize: { value: t, message: xe.toString(n) }
    });
  }
  max(t, n) {
    return new ka({
      ...this._def,
      maxSize: { value: t, message: xe.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
ka.create = (e, t) => new ka({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: $e.ZodSet,
  ...Ve(t)
});
class mi extends Ye {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== _e.function)
      return ye(n, {
        code: Ee.invalid_type,
        expected: _e.function,
        received: n.parsedType
      }), ze;
    function r(o, u) {
      return jo({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Ho(),
          vs
        ].filter((l) => !!l),
        issueData: {
          code: Ee.invalid_arguments,
          argumentsError: u
        }
      });
    }
    function a(o, u) {
      return jo({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Ho(),
          vs
        ].filter((l) => !!l),
        issueData: {
          code: Ee.invalid_return_type,
          returnTypeError: u
        }
      });
    }
    const i = { errorMap: n.common.contextualErrorMap }, s = n.data;
    if (this._def.returns instanceof bi) {
      const o = this;
      return yn(async function(...u) {
        const l = new lr([]), f = await o._def.args.parseAsync(u, i).catch((b) => {
          throw l.addIssue(r(u, b)), l;
        }), h = await Reflect.apply(s, this, f);
        return await o._def.returns._def.type.parseAsync(h, i).catch((b) => {
          throw l.addIssue(a(h, b)), l;
        });
      });
    } else {
      const o = this;
      return yn(function(...u) {
        const l = o._def.args.safeParse(u, i);
        if (!l.success)
          throw new lr([r(u, l.error)]);
        const f = Reflect.apply(s, this, l.data), h = o._def.returns.safeParse(f, i);
        if (!h.success)
          throw new lr([a(f, h.error)]);
        return h.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new mi({
      ...this._def,
      args: Or.create(t).rest(Ia.create())
    });
  }
  returns(t) {
    return new mi({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new mi({
      args: t || Or.create([]).rest(Ia.create()),
      returns: n || Ia.create(),
      typeName: $e.ZodFunction,
      ...Ve(r)
    });
  }
}
class Is extends Ye {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
Is.create = (e, t) => new Is({
  getter: e,
  typeName: $e.ZodLazy,
  ...Ve(t)
});
class xs extends Ye {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return ye(n, {
        received: n.data,
        code: Ee.invalid_literal,
        expected: this._def.value
      }), ze;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
xs.create = (e, t) => new xs({
  value: e,
  typeName: $e.ZodLiteral,
  ...Ve(t)
});
function Xb(e, t) {
  return new oa({
    values: e,
    typeName: $e.ZodEnum,
    ...Ve(t)
  });
}
class oa extends Ye {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return ye(n, {
        expected: mt.joinValues(r),
        received: n.parsedType,
        code: Ee.invalid_type
      }), ze;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return ye(n, {
        received: n.data,
        code: Ee.invalid_enum_value,
        options: r
      }), ze;
    }
    return yn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t) {
    return oa.create(t);
  }
  exclude(t) {
    return oa.create(this.options.filter((n) => !t.includes(n)));
  }
}
oa.create = Xb;
class Ns extends Ye {
  _parse(t) {
    const n = mt.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== _e.string && r.parsedType !== _e.number) {
      const a = mt.objectValues(n);
      return ye(r, {
        expected: mt.joinValues(a),
        received: r.parsedType,
        code: Ee.invalid_type
      }), ze;
    }
    if (n.indexOf(t.data) === -1) {
      const a = mt.objectValues(n);
      return ye(r, {
        received: r.data,
        code: Ee.invalid_enum_value,
        options: a
      }), ze;
    }
    return yn(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Ns.create = (e, t) => new Ns({
  values: e,
  typeName: $e.ZodNativeEnum,
  ...Ve(t)
});
class bi extends Ye {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== _e.promise && n.common.async === !1)
      return ye(n, {
        code: Ee.invalid_type,
        expected: _e.promise,
        received: n.parsedType
      }), ze;
    const r = n.parsedType === _e.promise ? n.data : Promise.resolve(n.data);
    return yn(r.then((a) => this._def.type.parseAsync(a, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
bi.create = (e, t) => new bi({
  type: e,
  typeName: $e.ZodPromise,
  ...Ve(t)
});
class dr extends Ye {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === $e.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), a = this._def.effect || null, i = {
      addIssue: (s) => {
        ye(r, s), s.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), a.type === "preprocess") {
      const s = a.transform(r.data, i);
      return r.common.issues.length ? {
        status: "dirty",
        value: r.data
      } : r.common.async ? Promise.resolve(s).then((o) => this._def.schema._parseAsync({
        data: o,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: s,
        path: r.path,
        parent: r
      });
    }
    if (a.type === "refinement") {
      const s = (o) => {
        const u = a.refinement(o, i);
        if (r.common.async)
          return Promise.resolve(u);
        if (u instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? ze : (o.status === "dirty" && n.dirty(), s(o.value), { status: n.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? ze : (o.status === "dirty" && n.dirty(), s(o.value).then(() => ({ status: n.value, value: o.value }))));
    }
    if (a.type === "transform")
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Ts(s))
          return s;
        const o = a.transform(s.value, i);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => Ts(s) ? Promise.resolve(a.transform(s.value, i)).then((o) => ({ status: n.value, value: o })) : s);
    mt.assertNever(a);
  }
}
dr.create = (e, t, n) => new dr({
  schema: e,
  typeName: $e.ZodEffects,
  effect: t,
  ...Ve(n)
});
dr.createWithPreprocess = (e, t, n) => new dr({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: $e.ZodEffects,
  ...Ve(n)
});
class $r extends Ye {
  _parse(t) {
    return this._getType(t) === _e.undefined ? yn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
$r.create = (e, t) => new $r({
  innerType: e,
  typeName: $e.ZodOptional,
  ...Ve(t)
});
class wa extends Ye {
  _parse(t) {
    return this._getType(t) === _e.null ? yn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
wa.create = (e, t) => new wa({
  innerType: e,
  typeName: $e.ZodNullable,
  ...Ve(t)
});
class Rs extends Ye {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === _e.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Rs.create = (e, t) => new Rs({
  innerType: e,
  typeName: $e.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...Ve(t)
});
class Wo extends Ye {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, a = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return zo(a) ? a.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new lr(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new lr(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Wo.create = (e, t) => new Wo({
  innerType: e,
  typeName: $e.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...Ve(t)
});
class qo extends Ye {
  _parse(t) {
    if (this._getType(t) !== _e.nan) {
      const r = this._getOrReturnCtx(t);
      return ye(r, {
        code: Ee.invalid_type,
        expected: _e.nan,
        received: r.parsedType
      }), ze;
    }
    return { status: "valid", value: t.data };
  }
}
qo.create = (e) => new qo({
  typeName: $e.ZodNaN,
  ...Ve(e)
});
const JD = Symbol("zod_brand");
class Zb extends Ye {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Bs extends Ye {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? ze : i.status === "dirty" ? (n.dirty(), Kb(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const a = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return a.status === "aborted" ? ze : a.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: a.value
      }) : this._def.out._parseSync({
        data: a.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new Bs({
      in: t,
      out: n,
      typeName: $e.ZodPipeline
    });
  }
}
class Ko extends Ye {
  _parse(t) {
    const n = this._def.innerType._parse(t);
    return Ts(n) && (n.value = Object.freeze(n.value)), n;
  }
}
Ko.create = (e, t) => new Ko({
  innerType: e,
  typeName: $e.ZodReadonly,
  ...Ve(t)
});
const Qb = (e, t = {}, n) => e ? gi.create().superRefine((r, a) => {
  var i, s;
  if (!e(r)) {
    const o = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, u = (s = (i = o.fatal) !== null && i !== void 0 ? i : n) !== null && s !== void 0 ? s : !0, l = typeof o == "string" ? { message: o } : o;
    a.addIssue({ code: "custom", ...l, fatal: u });
  }
}) : gi.create(), eP = {
  object: Bt.lazycreate
};
var $e;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})($e || ($e = {}));
const tP = (e, t = {
  message: `Input not instance of ${e.name}`
}) => Qb((n) => n instanceof e, t), Jb = ur.create, eE = ia.create, nP = qo.create, rP = sa.create, tE = As.create, aP = Ra.create, iP = Vo.create, sP = _s.create, oP = ys.create, uP = gi.create, lP = Ia.create, cP = Fr.create, fP = Go.create, dP = cr.create, hP = Bt.create, mP = Bt.strictCreate, pP = Ss.create, gP = Cu.create, bP = Cs.create, EP = Or.create, vP = Os.create, TP = Yo.create, AP = ka.create, _P = mi.create, yP = Is.create, SP = xs.create, CP = oa.create, OP = Ns.create, IP = bi.create, f0 = dr.create, xP = $r.create, NP = wa.create, RP = dr.createWithPreprocess, kP = Bs.create, wP = () => Jb().optional(), DP = () => eE().optional(), PP = () => tE().optional(), LP = {
  string: (e) => ur.create({ ...e, coerce: !0 }),
  number: (e) => ia.create({ ...e, coerce: !0 }),
  boolean: (e) => As.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => sa.create({ ...e, coerce: !0 }),
  date: (e) => Ra.create({ ...e, coerce: !0 })
}, MP = ze;
var d = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: vs,
  setErrorMap: UD,
  getErrorMap: Ho,
  makeIssue: jo,
  EMPTY_PATH: HD,
  addIssueToContext: ye,
  ParseStatus: dn,
  INVALID: ze,
  DIRTY: Kb,
  OK: yn,
  isAborted: Ef,
  isDirty: vf,
  isValid: Ts,
  isAsync: zo,
  get util() {
    return mt;
  },
  get objectUtil() {
    return bf;
  },
  ZodParsedType: _e,
  getParsedType: ta,
  ZodType: Ye,
  ZodString: ur,
  ZodNumber: ia,
  ZodBigInt: sa,
  ZodBoolean: As,
  ZodDate: Ra,
  ZodSymbol: Vo,
  ZodUndefined: _s,
  ZodNull: ys,
  ZodAny: gi,
  ZodUnknown: Ia,
  ZodNever: Fr,
  ZodVoid: Go,
  ZodArray: cr,
  ZodObject: Bt,
  ZodUnion: Ss,
  ZodDiscriminatedUnion: Cu,
  ZodIntersection: Cs,
  ZodTuple: Or,
  ZodRecord: Os,
  ZodMap: Yo,
  ZodSet: ka,
  ZodFunction: mi,
  ZodLazy: Is,
  ZodLiteral: xs,
  ZodEnum: oa,
  ZodNativeEnum: Ns,
  ZodPromise: bi,
  ZodEffects: dr,
  ZodTransformer: dr,
  ZodOptional: $r,
  ZodNullable: wa,
  ZodDefault: Rs,
  ZodCatch: Wo,
  ZodNaN: qo,
  BRAND: JD,
  ZodBranded: Zb,
  ZodPipeline: Bs,
  ZodReadonly: Ko,
  custom: Qb,
  Schema: Ye,
  ZodSchema: Ye,
  late: eP,
  get ZodFirstPartyTypeKind() {
    return $e;
  },
  coerce: LP,
  any: uP,
  array: dP,
  bigint: rP,
  boolean: tE,
  date: aP,
  discriminatedUnion: gP,
  effect: f0,
  enum: CP,
  function: _P,
  instanceof: tP,
  intersection: bP,
  lazy: yP,
  literal: SP,
  map: TP,
  nan: nP,
  nativeEnum: OP,
  never: cP,
  null: oP,
  nullable: NP,
  number: eE,
  object: hP,
  oboolean: PP,
  onumber: DP,
  optional: xP,
  ostring: wP,
  pipeline: kP,
  preprocess: RP,
  promise: IP,
  record: vP,
  set: AP,
  strictObject: mP,
  string: Jb,
  symbol: iP,
  transformer: f0,
  tuple: EP,
  undefined: sP,
  union: pP,
  unknown: lP,
  void: fP,
  NEVER: MP,
  ZodIssueCode: Ee,
  quotelessJson: FD,
  ZodError: lr
}), md = /* @__PURE__ */ ((e) => (e.EFFECT = "effect", e.RESPONSE = "response", e))(md || {});
const nE = (e) => d.object({
  name: d.string(),
  type: d.literal(e),
  match: d.function().transform((t) => t)
}), $P = nE(
  "effect"
  /* EFFECT */
).extend({
  effect: d.function().transform((e) => e).optional()
}), BP = nE(
  "response"
  /* RESPONSE */
).extend({
  render: d.function().transform((e) => e).optional()
}), FP = d.discriminatedUnion("type", [$P, BP]), UP = (e) => e.filter((t) => t.type === md.EFFECT).map((t) => ({
  canHandle: (n) => t.match({ trace: n }),
  handle: ({ context: n }, r) => ((async () => {
    var a;
    try {
      await ((a = t.effect) == null ? void 0 : a.call(t, { trace: r }));
    } catch (i) {
      console.error(`Extension '${t.name}' threw an error: ${i}`);
    }
  })(), n)
}));
var d0;
(function(e) {
  e.INTENT = "INTENT";
})(d0 || (d0 = {}));
var h0;
(function(e) {
  e.STACKED = "stacked", e.CAROUSEL = "carousel";
})(h0 || (h0 = {}));
const HP = "VF.";
var Xo;
(function(e) {
  e.Workspace = "WS", e.DialogManager = "DM";
})(Xo || (Xo = {}));
const rE = (e) => (t) => typeof t == "string" && t.startsWith(`${HP}${e}.`);
rE(Xo.Workspace);
rE(Xo.DialogManager);
var m0;
(function(e) {
  e.LUIS = "LUIS";
})(m0 || (m0 = {}));
var p0;
(function(e) {
  e.CURVED = "CURVED", e.STRAIGHT = "STRAIGHT";
})(p0 || (p0 = {}));
var g0;
(function(e) {
  e.BLOCK = "block", e.ACTIONS = "actions";
})(g0 || (g0 = {}));
var b0;
(function(e) {
  e.INTENT = "INTENT";
})(b0 || (b0 = {}));
var E0;
(function(e) {
  e.FAIL = "fail", e.NEXT = "next", e.PAUSE = "pause", e.NO_REPLY = "no-reply", e.NO_MATCH = "else", e.PREVIOUS = "previous";
})(E0 || (E0 = {}));
var v0;
(function(e) {
  e.TOPIC = "TOPIC", e.GROUP = "GROUP", e.COMPONENT = "COMPONENT", e.TEMPLATE = "TEMPLATE";
})(v0 || (v0 = {}));
var T0;
(function(e) {
  e.NODE = "NODE", e.DIAGRAM = "DIAGRAM";
})(T0 || (T0 = {}));
var A0;
(function(e) {
  e.PDF = "pdf", e.TEXT = "text", e.URL = "url", e.DOCX = "docx";
})(A0 || (A0 = {}));
var _0;
(function(e) {
  e.ERROR = "ERROR", e.SUCCESS = "SUCCESS", e.PENDING = "PENDING", e.INITIALIZED = "INITIALIZED";
})(_0 || (_0 = {}));
var y0;
(function(e) {
  e.RECURSIVE_TEXT_SPLITTER = "recursive_text_splitter";
})(y0 || (y0 = {}));
var S0;
(function(e) {
  e.PUBLIC = "public", e.PRIVATE = "private";
})(S0 || (S0 = {}));
var C0;
(function(e) {
  e.DESIGN = "DESIGN", e.REVIEW = "REVIEW", e.COMPLETE = "COMPLETE";
})(C0 || (C0 = {}));
var O0;
(function(e) {
  e.CONVERSATION = "conversation", e.PROTOTYPE = "prototype", e.NLU_DATASOURCE_IMPORT = "nluDatasourceImport";
})(O0 || (O0 = {}));
var I0;
(function(e) {
  e.FOLDER = "FOLDER", e.DIAGRAM = "DIAGRAM";
})(I0 || (I0 = {}));
var x0;
(function(e) {
  e.FORM_DATA = "formData", e.RAW_INPUT = "rawInput", e.URL_ENCODED = "urlEncoded";
})(x0 || (x0 = {}));
var N0;
(function(e) {
  e.GET = "GET", e.PUT = "PUT", e.POST = "POST", e.PATCH = "PATCH", e.DELETE = "DELETE";
})(N0 || (N0 = {}));
var R0;
(function(e) {
  e.GET = "Make a GET Request", e.PUT = "Make a PUT Request", e.POST = "Make a POST Request", e.PATCH = "Make a PATCH Request", e.DELETE = "Make a DELETE Request";
})(R0 || (R0 = {}));
var k0;
(function(e) {
  e.URL = "URL", e.PATH = "PATH", e.INTENT = "INTENT";
})(k0 || (k0 = {}));
var w0;
(function(e) {
  e.INTENT = "intent", e.QUERY = "query";
})(w0 || (w0 = {}));
var D0;
(function(e) {
  e.SIMPLE = "Simple", e.STANDARD = "Standard";
})(D0 || (D0 = {}));
var P0;
(function(e) {
  e.CAROUSEL = "Carousel", e.LIST = "List";
})(P0 || (P0 = {}));
var se;
(function(e) {
  e.TEXT = "text", e.SPEAK = "speak", e.START = "start", e.CARD = "card", e.CARD_V2 = "cardV2", e.CAROUSEL = "carousel", e.BUTTONS = "buttons", e.INTERACTION = "interaction", e.AI_RESPONSE = "generative", e.AI_SET = "ai_set", e.SET = "set", e.SET_V2 = "setV2", e.IF = "if", e.IF_V2 = "ifV2", e.RANDOM = "random", e.RANDOM_V2 = "randomV2", e.CAPTURE = "capture", e.CAPTURE_V2 = "captureV2", e.GOTO = "goTo", e.GOTO_NODE = "goToNode", e.GOTO_DOMAIN = "goToDomain", e.API = "api", e.ZAPIER = "zapier", e.INTEGRATIONS = "integrations", e.GOOGLE_SHEETS = "google_sheets", e.INTENT = "intent", e.FLOW = "flow", e.COMPONENT = "component", e.CODE = "code", e.EXIT = "exit", e.PROMPT = "prompt", e.COMMAND = "command", e.TRACE = "trace", e.CHANNEL_ACTION = "channel_action", e.CUSTOM_BLOCK_POINTER = "custom_block_pointer", e.URL = "url", e.STREAM = "stream", e.VISUAL = "visual", e.GENERAL = "general", e.DIRECTIVE = "directive", e.DEPRECATED = "deprecated";
})(se || (se = {}));
se.GOTO;
var L0;
(function(e) {
  e.CREATE_DATA = "Create Data", e.UPDATE_DATA = "Update Data", e.DELETE_DATA = "Delete Data", e.RETRIEVE_DATA = "Retrieve Data";
})(L0 || (L0 = {}));
var M0;
(function(e) {
  e.PATH = "path", e.NONE = "none";
})(M0 || (M0 = {}));
var $0;
(function(e) {
  e.PATH = "PATH", e.GO_TO = "GO_TO";
})($0 || ($0 = {}));
var B0;
(function(e) {
  e.LOCAL = "LOCAL", e.GLOBAL = "GLOBAL";
})(B0 || (B0 = {}));
var F0;
(function(e) {
  e[e.DEFAULT = 1] = "DEFAULT", e[e.DO_DUPLICATES = 2] = "DO_DUPLICATES";
})(F0 || (F0 = {}));
var U0;
(function(e) {
  e[e.DEFAULT = 1] = "DEFAULT", e[e.DO_DUPLICATES = 2] = "DO_DUPLICATES";
})(U0 || (U0 = {}));
var H0;
(function(e) {
  e.AUDIO = "audio", e.MESSAGE = "message";
})(H0 || (H0 = {}));
var j0;
(function(e) {
  e.LOOP = "LOOP", e.PLAY = "PLAY", e.PAUSE = "PAUSE", e.END = "END";
})(j0 || (j0 = {}));
var z0;
(function(e) {
  e.PREVIEW = "preview", e.ALL_VARIANTS = "all-variants";
})(z0 || (z0 = {}));
var V0;
(function(e) {
  e.JUMP = "jump", e.PUSH = "push";
})(V0 || (V0 = {}));
var Af;
(function(e) {
  e.INTENT = "intent", e.ALEXA = "alexa";
})(Af || (Af = {}));
Object.values(Af);
var G0;
(function(e) {
  e.EQUALS = "equals", e.GREATER = "greater", e.LESS = "less", e.AND = "and", e.OR = "or", e.VALUE = "value", e.VARIABLE = "variable", e.ADVANCE = "advance", e.PLUS = "plus", e.MINUS = "minus", e.TIMES = "times", e.DIVIDE = "divide", e.NOT = "not";
})(G0 || (G0 = {}));
var Y0;
(function(e) {
  e.EQUALS = "equals", e.GREATER = "greater", e.LESS = "less", e.AND = "and", e.OR = "or", e.VALUE = "value", e.VARIABLE = "variable", e.ADVANCE = "advance", e.NOT_EQUAL = "not_equal", e.GREATER_OR_EQUAL = "greater_or_equal", e.LESS_OR_EQUAL = "less_or_equal", e.CONTAINS = "contains", e.NOT_CONTAIN = "not_contain", e.STARTS_WITH = "starts_with", e.ENDS_WITH = "ends_with", e.HAS_VALUE = "has_value", e.IS_EMPTY = "is_empty";
})(Y0 || (Y0 = {}));
var W0;
(function(e) {
  e.VARIABLE = "variable", e.VALUE = "value", e.LOGIC_GROUP = "logic_group", e.EXPRESSION = "expression";
})(W0 || (W0 = {}));
var q0;
(function(e) {
  e.ZAPIER = "Zapier", e.CUSTOM_API = "Custom API", e.GOOGLE_SHEETS = "Google Sheets";
})(q0 || (q0 = {}));
var K0;
(function(e) {
  e.ZAPIER = "Zapier", e.GOOGLE_SHEETS = "Google Sheets";
})(K0 || (K0 = {}));
var X0;
(function(e) {
  e.NODE = "NODE", e.GLOBAL = "GLOBAL";
})(X0 || (X0 = {}));
var Z0;
(function(e) {
  e.PATH = "path", e.REPROMPT = "reprompt", e.BOTH = "both";
})(Z0 || (Z0 = {}));
var Q0;
(function(e) {
  e.PATH = "path", e.REPROMPT = "reprompt";
})(Q0 || (Q0 = {}));
var hr;
(function(e) {
  e.LOG = "log", e.END = "end", e.TEXT = "text", e.PATH = "path", e.FLOW = "flow", e.GOTO = "goto", e.SPEAK = "speak", e.BLOCK = "block", e.DEBUG = "debug", e.CHOICE = "choice", e.STREAM = "stream", e.VISUAL = "visual", e.CARD_V2 = "cardV2", e.CAROUSEL = "carousel", e.NO_REPLY = "no-reply", e.ENTITY_FILLING = "entity-filling", e.CHANNEL_ACTION = "channel-action";
})(hr || (hr = {}));
var J0;
(function(e) {
  e.MOBILE = "mobile", e.TABLET = "tablet", e.DESKTOP = "desktop", e.SMART_WATCH = "smart_watch", e.TELEVISION = "television", e.IN_CAR_DISPLAY = "in_car_display", e.ECHO_SPOT = "echo_spot", e.ECHO_SHOW_8 = "echo_show_8", e.ECHO_SHOW_10 = "echo_show_10", e.FIRE_HD_8 = "fire_hd_8", e.FIRE_HD_10 = "fire_hd_10", e.FIRE_TV_CUBE = "fire_tv_cube", e.GOOGLE_NEST_HUB = "google_nest_hub";
})(J0 || (J0 = {}));
var ep;
(function(e) {
  e.FULL = "full", e.HIDDEN = "hidden", e.CROPPED = "cropped";
})(ep || (ep = {}));
var tp;
(function(e) {
  e.JSON = "JSON", e.SPLASH = "SPLASH";
})(tp || (tp = {}));
var np;
(function(e) {
  e.APL = "apl", e.IMAGE = "image";
})(np || (np = {}));
var rp;
(function(e) {
  e.AUTO = "AUTO", e.DEVICE = "DEVICE", e.CUSTOM_SIZE = "CUSTOM_SIZE";
})(rp || (rp = {}));
var ap;
(function(e) {
  e.START_A_ZAP = "Start a Zap";
})(ap || (ap = {}));
var ip;
(function(e) {
  e.OPEN_URL = "open_url";
})(ip || (ip = {}));
var Zo;
(function(e) {
  e.TEXT = "text", e.ACTION = "action", e.INTENT = "intent", e.LAUNCH = "launch", e.NO_REPLY = "no-reply";
})(Zo || (Zo = {}));
Object.values(Zo);
var Ht;
(function(e) {
  e.TEXT = "text", e.SPEAK = "speak", e.AUDIO = "audio", e.VISUALS = "visuals", e.CARD = "card", e.CAROUSEL = "carousel", e.BUTTONS = "buttons", e.CHOICE = "choice", e.CAPTURE = "capture", e.PROMPT = "prompt", e.INTENT = "intent", e.CONDITION = "condition", e.SET = "set", e.RANDOM = "random", e.FLOW = "flow", e.EXIT = "exit", e.API = "api", e.GOOGLE_SHEETS = "google_sheets", e.CUSTOM_CODE = "custom_code", e.CUSTOM_ACTION = "custom_action", e.START = "start";
})(Ht || (Ht = {}));
var sp;
(function(e) {
  e.CONVERSATION_START = "conversation_start", e.NLU_INTENT_RESOLVED = "nlu.intent_resolved";
})(sp || (sp = {}));
se.TEXT + "", Ht.TEXT, se.SPEAK + "", Ht.SPEAK, se.START + "", Ht.START, se.CARD + "", Ht.CARD, se.CAROUSEL + "", Ht.CAROUSEL, se.BUTTONS + "", Ht.BUTTONS, se.SET + "", Ht.SET, se.SET_V2 + "", Ht.SET, se.IF + "", Ht.CONDITION, se.IF_V2 + "", Ht.CONDITION, se.RANDOM + "", Ht.RANDOM, se.CAPTURE + "", Ht.CAPTURE, se.CAPTURE_V2 + "", Ht.CAPTURE, se.API + "", Ht.API, se.GOOGLE_SHEETS + "", Ht.GOOGLE_SHEETS, se.INTENT + "", Ht.INTENT, se.CODE + "", Ht.CUSTOM_CODE, se.EXIT + "", Ht.EXIT, se.PROMPT + "", Ht.PROMPT, se.VISUAL + "", Ht.VISUALS;
var Mr;
(function(e) {
  e.OFF = "off", e.ERROR = "error", e.WARN = "warn", e.INFO = "info", e.VERBOSE = "verbose";
})(Mr || (Mr = {}));
Mr.OFF + "", Mr.ERROR + "", Mr.WARN + "", Mr.INFO + "", Mr.VERBOSE + "";
new Set(Object.values(Mr));
Mr.INFO;
var op;
(function(e) {
  e.BACKGROUND_COLOR = "backgroundColor", e.COLOR = "color", e.ITALIC = "italic", e.UNDERLINE = "underline", e.FONT_WEIGHT = "fontWeight", e.FONT_FAMILY = "fontFamily", e.STRIKE_THROUGH = "strikeThrough";
})(op || (op = {}));
var up;
(function(e) {
  e.LINK = "link", e.VARIABLE = "variable";
})(up || (up = {}));
var lp;
(function(e) {
  e.TEXT_ALIGN = "textAlign";
})(lp || (lp = {}));
var Qo;
(function(e) {
  e.DaVinci_003 = "text-davinci-003", e.GPT_3_5_turbo = "gpt-3.5-turbo", e.GPT_4 = "gpt-4", e.CLAUDE_V1 = "claude-v1", e.CLAUDE_INSTANT_V1 = "claude-instant-v1";
})(Qo || (Qo = {}));
Qo.GPT_3_5_turbo, Qo.GPT_4;
var cp;
(function(e) {
  e.PROMPT = "prompt", e.MEMORY = "memory", e.MEMORY_PROMPT = "memory_prompt";
})(cp || (cp = {}));
var fp;
(function(e) {
  e.KNOWLEDGE_BASE = "knowledge_base", e.DEFAULT = "default";
})(fp || (fp = {}));
var dp;
(function(e) {
  e.SYSTEM = "system", e.ASSISTANT = "assistant", e.USER = "user";
})(dp || (dp = {}));
var hp;
(function(e) {
  e.PRODUCTION = "production", e.DEVELOPMENT = "development", e.LOCAL = "local", e.E2E = "e2e", e.TEST = "test", e.STAGING = "staging";
})(hp || (hp = {}));
Array.from({ length: 26 }).map((e, t) => String.fromCharCode(97 + t));
Cb();
var aE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    var n = 1e3, r = 6e4, a = 36e5, i = "millisecond", s = "second", o = "minute", u = "hour", l = "day", f = "week", h = "month", p = "quarter", b = "year", v = "date", E = "Invalid Date", y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, N = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, A = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, I = function(H, D, R) {
      var Y = String(H);
      return !Y || Y.length >= D ? H : "" + Array(D + 1 - Y.length).join(R) + H;
    }, j = { s: I, z: function(H) {
      var D = -H.utcOffset(), R = Math.abs(D), Y = Math.floor(R / 60), P = R % 60;
      return (D <= 0 ? "+" : "-") + I(Y, 2, "0") + ":" + I(P, 2, "0");
    }, m: function H(D, R) {
      if (D.date() < R.date())
        return -H(R, D);
      var Y = 12 * (R.year() - D.year()) + (R.month() - D.month()), P = D.clone().add(Y, h), Z = R - P < 0, W = D.clone().add(Y + (Z ? -1 : 1), h);
      return +(-(Y + (R - P) / (Z ? P - W : W - P)) || 0);
    }, a: function(H) {
      return H < 0 ? Math.ceil(H) || 0 : Math.floor(H);
    }, p: function(H) {
      return { M: h, y: b, w: f, d: l, D: v, h: u, m: o, s, ms: i, Q: p }[H] || String(H || "").toLowerCase().replace(/s$/, "");
    }, u: function(H) {
      return H === void 0;
    } }, $ = "en", _ = {};
    _[$] = A;
    var M = function(H) {
      return H instanceof Q;
    }, V = function(H, D, R) {
      var Y;
      if (!H)
        return $;
      if (typeof H == "string")
        _[H] && (Y = H), D && (_[H] = D, Y = H);
      else {
        var P = H.name;
        _[P] = H, Y = P;
      }
      return !R && Y && ($ = Y), Y || !R && $;
    }, G = function(H, D) {
      if (M(H))
        return H.clone();
      var R = typeof D == "object" ? D : {};
      return R.date = H, R.args = arguments, new Q(R);
    }, O = j;
    O.l = V, O.i = M, O.w = function(H, D) {
      return G(H, { locale: D.$L, utc: D.$u, x: D.$x, $offset: D.$offset });
    };
    var Q = function() {
      function H(R) {
        this.$L = V(R.locale, null, !0), this.parse(R);
      }
      var D = H.prototype;
      return D.parse = function(R) {
        this.$d = function(Y) {
          var P = Y.date, Z = Y.utc;
          if (P === null)
            return /* @__PURE__ */ new Date(NaN);
          if (O.u(P))
            return /* @__PURE__ */ new Date();
          if (P instanceof Date)
            return new Date(P);
          if (typeof P == "string" && !/Z$/i.test(P)) {
            var W = P.match(y);
            if (W) {
              var C = W[2] - 1 || 0, pe = (W[7] || "0").substring(0, 3);
              return Z ? new Date(Date.UTC(W[1], C, W[3] || 1, W[4] || 0, W[5] || 0, W[6] || 0, pe)) : new Date(W[1], C, W[3] || 1, W[4] || 0, W[5] || 0, W[6] || 0, pe);
            }
          }
          return new Date(P);
        }(R), this.$x = R.x || {}, this.init();
      }, D.init = function() {
        var R = this.$d;
        this.$y = R.getFullYear(), this.$M = R.getMonth(), this.$D = R.getDate(), this.$W = R.getDay(), this.$H = R.getHours(), this.$m = R.getMinutes(), this.$s = R.getSeconds(), this.$ms = R.getMilliseconds();
      }, D.$utils = function() {
        return O;
      }, D.isValid = function() {
        return this.$d.toString() !== E;
      }, D.isSame = function(R, Y) {
        var P = G(R);
        return this.startOf(Y) <= P && P <= this.endOf(Y);
      }, D.isAfter = function(R, Y) {
        return G(R) < this.startOf(Y);
      }, D.isBefore = function(R, Y) {
        return this.endOf(Y) < G(R);
      }, D.$g = function(R, Y, P) {
        return O.u(R) ? this[Y] : this.set(P, R);
      }, D.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, D.valueOf = function() {
        return this.$d.getTime();
      }, D.startOf = function(R, Y) {
        var P = this, Z = !!O.u(Y) || Y, W = O.p(R), C = function(Ue, Ae) {
          var Me = O.w(P.$u ? Date.UTC(P.$y, Ae, Ue) : new Date(P.$y, Ae, Ue), P);
          return Z ? Me : Me.endOf(l);
        }, pe = function(Ue, Ae) {
          return O.w(P.toDate()[Ue].apply(P.toDate("s"), (Z ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Ae)), P);
        }, me = this.$W, w = this.$M, Ne = this.$D, Re = "set" + (this.$u ? "UTC" : "");
        switch (W) {
          case b:
            return Z ? C(1, 0) : C(31, 11);
          case h:
            return Z ? C(1, w) : C(0, w + 1);
          case f:
            var De = this.$locale().weekStart || 0, Qe = (me < De ? me + 7 : me) - De;
            return C(Z ? Ne - Qe : Ne + (6 - Qe), w);
          case l:
          case v:
            return pe(Re + "Hours", 0);
          case u:
            return pe(Re + "Minutes", 1);
          case o:
            return pe(Re + "Seconds", 2);
          case s:
            return pe(Re + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, D.endOf = function(R) {
        return this.startOf(R, !1);
      }, D.$set = function(R, Y) {
        var P, Z = O.p(R), W = "set" + (this.$u ? "UTC" : ""), C = (P = {}, P[l] = W + "Date", P[v] = W + "Date", P[h] = W + "Month", P[b] = W + "FullYear", P[u] = W + "Hours", P[o] = W + "Minutes", P[s] = W + "Seconds", P[i] = W + "Milliseconds", P)[Z], pe = Z === l ? this.$D + (Y - this.$W) : Y;
        if (Z === h || Z === b) {
          var me = this.clone().set(v, 1);
          me.$d[C](pe), me.init(), this.$d = me.set(v, Math.min(this.$D, me.daysInMonth())).$d;
        } else
          C && this.$d[C](pe);
        return this.init(), this;
      }, D.set = function(R, Y) {
        return this.clone().$set(R, Y);
      }, D.get = function(R) {
        return this[O.p(R)]();
      }, D.add = function(R, Y) {
        var P, Z = this;
        R = Number(R);
        var W = O.p(Y), C = function(w) {
          var Ne = G(Z);
          return O.w(Ne.date(Ne.date() + Math.round(w * R)), Z);
        };
        if (W === h)
          return this.set(h, this.$M + R);
        if (W === b)
          return this.set(b, this.$y + R);
        if (W === l)
          return C(1);
        if (W === f)
          return C(7);
        var pe = (P = {}, P[o] = r, P[u] = a, P[s] = n, P)[W] || 1, me = this.$d.getTime() + R * pe;
        return O.w(me, this);
      }, D.subtract = function(R, Y) {
        return this.add(-1 * R, Y);
      }, D.format = function(R) {
        var Y = this, P = this.$locale();
        if (!this.isValid())
          return P.invalidDate || E;
        var Z = R || "YYYY-MM-DDTHH:mm:ssZ", W = O.z(this), C = this.$H, pe = this.$m, me = this.$M, w = P.weekdays, Ne = P.months, Re = function(Ae, Me, it, pt) {
          return Ae && (Ae[Me] || Ae(Y, Z)) || it[Me].substr(0, pt);
        }, De = function(Ae) {
          return O.s(C % 12 || 12, Ae, "0");
        }, Qe = P.meridiem || function(Ae, Me, it) {
          var pt = Ae < 12 ? "AM" : "PM";
          return it ? pt.toLowerCase() : pt;
        }, Ue = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: me + 1, MM: O.s(me + 1, 2, "0"), MMM: Re(P.monthsShort, me, Ne, 3), MMMM: Re(Ne, me), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: Re(P.weekdaysMin, this.$W, w, 2), ddd: Re(P.weekdaysShort, this.$W, w, 3), dddd: w[this.$W], H: String(C), HH: O.s(C, 2, "0"), h: De(1), hh: De(2), a: Qe(C, pe, !0), A: Qe(C, pe, !1), m: String(pe), mm: O.s(pe, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: W };
        return Z.replace(N, function(Ae, Me) {
          return Me || Ue[Ae] || W.replace(":", "");
        });
      }, D.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, D.diff = function(R, Y, P) {
        var Z, W = O.p(Y), C = G(R), pe = (C.utcOffset() - this.utcOffset()) * r, me = this - C, w = O.m(this, C);
        return w = (Z = {}, Z[b] = w / 12, Z[h] = w, Z[p] = w / 3, Z[f] = (me - pe) / 6048e5, Z[l] = (me - pe) / 864e5, Z[u] = me / a, Z[o] = me / r, Z[s] = me / n, Z)[W] || me, P ? w : O.a(w);
      }, D.daysInMonth = function() {
        return this.endOf(h).$D;
      }, D.$locale = function() {
        return _[this.$L];
      }, D.locale = function(R, Y) {
        if (!R)
          return this.$L;
        var P = this.clone(), Z = V(R, Y, !0);
        return Z && (P.$L = Z), P;
      }, D.clone = function() {
        return O.w(this.$d, this);
      }, D.toDate = function() {
        return new Date(this.valueOf());
      }, D.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, D.toISOString = function() {
        return this.$d.toISOString();
      }, D.toString = function() {
        return this.$d.toUTCString();
      }, H;
    }(), ee = Q.prototype;
    return G.prototype = ee, [["$ms", i], ["$s", s], ["$m", o], ["$H", u], ["$W", l], ["$M", h], ["$y", b], ["$D", v]].forEach(function(H) {
      ee[H[1]] = function(D) {
        return this.$g(D, H[0], H[1]);
      };
    }), G.extend = function(H, D) {
      return H.$i || (H(D, Q, G), H.$i = !0), G;
    }, G.locale = V, G.isDayjs = M, G.unix = function(H) {
      return G(1e3 * H);
    }, G.en = _[$], G.Ls = _, G.p = {}, G;
  });
})(aE);
var jP = aE.exports;
const ca = /* @__PURE__ */ Ft(jP);
var iE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    return function(n, r, a) {
      var i = r.prototype, s = i.format;
      a.en.ordinal = function(o) {
        var u = ["th", "st", "nd", "rd"], l = o % 100;
        return "[" + o + (u[(l - 20) % 10] || u[l] || u[0]) + "]";
      }, i.format = function(o) {
        var u = this, l = this.$locale();
        if (!this.isValid())
          return s.bind(this)(o);
        var f = this.$utils(), h = (o || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(p) {
          switch (p) {
            case "Q":
              return Math.ceil((u.$M + 1) / 3);
            case "Do":
              return l.ordinal(u.$D);
            case "gggg":
              return u.weekYear();
            case "GGGG":
              return u.isoWeekYear();
            case "wo":
              return l.ordinal(u.week(), "W");
            case "w":
            case "ww":
              return f.s(u.week(), p === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return f.s(u.isoWeek(), p === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return f.s(String(u.$H === 0 ? 24 : u.$H), p === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(u.$d.getTime() / 1e3);
            case "x":
              return u.$d.getTime();
            case "z":
              return "[" + u.offsetName() + "]";
            case "zzz":
              return "[" + u.offsetName("long") + "]";
            default:
              return p;
          }
        });
        return s.bind(this)(h);
      };
    };
  });
})(iE);
var zP = iE.exports;
const VP = /* @__PURE__ */ Ft(zP);
var sE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, r = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, a = /\d\d/, i = /\d\d?/, s = /\d*[^\s\d-_:/()]+/, o = {}, u = function(E) {
      return (E = +E) + (E > 68 ? 1900 : 2e3);
    }, l = function(E) {
      return function(y) {
        this[E] = +y;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(E) {
      (this.zone || (this.zone = {})).offset = function(y) {
        if (!y || y === "Z")
          return 0;
        var N = y.match(/([+-]|\d\d)/g), A = 60 * N[1] + (+N[2] || 0);
        return A === 0 ? 0 : N[0] === "+" ? -A : A;
      }(E);
    }], h = function(E) {
      var y = o[E];
      return y && (y.indexOf ? y : y.s.concat(y.f));
    }, p = function(E, y) {
      var N, A = o.meridiem;
      if (A) {
        for (var I = 1; I <= 24; I += 1)
          if (E.indexOf(A(I, 0, y)) > -1) {
            N = I > 12;
            break;
          }
      } else
        N = E === (y ? "pm" : "PM");
      return N;
    }, b = { A: [s, function(E) {
      this.afternoon = p(E, !1);
    }], a: [s, function(E) {
      this.afternoon = p(E, !0);
    }], S: [/\d/, function(E) {
      this.milliseconds = 100 * +E;
    }], SS: [a, function(E) {
      this.milliseconds = 10 * +E;
    }], SSS: [/\d{3}/, function(E) {
      this.milliseconds = +E;
    }], s: [i, l("seconds")], ss: [i, l("seconds")], m: [i, l("minutes")], mm: [i, l("minutes")], H: [i, l("hours")], h: [i, l("hours")], HH: [i, l("hours")], hh: [i, l("hours")], D: [i, l("day")], DD: [a, l("day")], Do: [s, function(E) {
      var y = o.ordinal, N = E.match(/\d+/);
      if (this.day = N[0], y)
        for (var A = 1; A <= 31; A += 1)
          y(A).replace(/\[|\]/g, "") === E && (this.day = A);
    }], M: [i, l("month")], MM: [a, l("month")], MMM: [s, function(E) {
      var y = h("months"), N = (h("monthsShort") || y.map(function(A) {
        return A.substr(0, 3);
      })).indexOf(E) + 1;
      if (N < 1)
        throw new Error();
      this.month = N % 12 || N;
    }], MMMM: [s, function(E) {
      var y = h("months").indexOf(E) + 1;
      if (y < 1)
        throw new Error();
      this.month = y % 12 || y;
    }], Y: [/[+-]?\d+/, l("year")], YY: [a, function(E) {
      this.year = u(E);
    }], YYYY: [/\d{4}/, l("year")], Z: f, ZZ: f };
    function v(E) {
      var y, N;
      y = E, N = o && o.formats;
      for (var A = (E = y.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(G, O, Q) {
        var ee = Q && Q.toUpperCase();
        return O || N[Q] || n[Q] || N[ee].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(H, D, R) {
          return D || R.slice(1);
        });
      })).match(r), I = A.length, j = 0; j < I; j += 1) {
        var $ = A[j], _ = b[$], M = _ && _[0], V = _ && _[1];
        A[j] = V ? { regex: M, parser: V } : $.replace(/^\[|\]$/g, "");
      }
      return function(G) {
        for (var O = {}, Q = 0, ee = 0; Q < I; Q += 1) {
          var H = A[Q];
          if (typeof H == "string")
            ee += H.length;
          else {
            var D = H.regex, R = H.parser, Y = G.substr(ee), P = D.exec(Y)[0];
            R.call(O, P), G = G.replace(P, "");
          }
        }
        return function(Z) {
          var W = Z.afternoon;
          if (W !== void 0) {
            var C = Z.hours;
            W ? C < 12 && (Z.hours += 12) : C === 12 && (Z.hours = 0), delete Z.afternoon;
          }
        }(O), O;
      };
    }
    return function(E, y, N) {
      N.p.customParseFormat = !0, E && E.parseTwoDigitYear && (u = E.parseTwoDigitYear);
      var A = y.prototype, I = A.parse;
      A.parse = function(j) {
        var $ = j.date, _ = j.utc, M = j.args;
        this.$u = _;
        var V = M[1];
        if (typeof V == "string") {
          var G = M[2] === !0, O = M[3] === !0, Q = G || O, ee = M[2];
          O && (ee = M[2]), o = this.$locale(), !G && ee && (o = N.Ls[ee]), this.$d = function(Y, P, Z) {
            try {
              if (["x", "X"].indexOf(P) > -1)
                return new Date((P === "X" ? 1e3 : 1) * Y);
              var W = v(P)(Y), C = W.year, pe = W.month, me = W.day, w = W.hours, Ne = W.minutes, Re = W.seconds, De = W.milliseconds, Qe = W.zone, Ue = /* @__PURE__ */ new Date(), Ae = me || (C || pe ? 1 : Ue.getDate()), Me = C || Ue.getFullYear(), it = 0;
              C && !pe || (it = pe > 0 ? pe - 1 : Ue.getMonth());
              var pt = w || 0, Kt = Ne || 0, Xt = Re || 0, un = De || 0;
              return Qe ? new Date(Date.UTC(Me, it, Ae, pt, Kt, Xt, un + 60 * Qe.offset * 1e3)) : Z ? new Date(Date.UTC(Me, it, Ae, pt, Kt, Xt, un)) : new Date(Me, it, Ae, pt, Kt, Xt, un);
            } catch {
              return /* @__PURE__ */ new Date("");
            }
          }($, V, _), this.init(), ee && ee !== !0 && (this.$L = this.locale(ee).$L), Q && $ != this.format(V) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
        } else if (V instanceof Array)
          for (var H = V.length, D = 1; D <= H; D += 1) {
            M[1] = V[D - 1];
            var R = N.apply(this, M);
            if (R.isValid()) {
              this.$d = R.$d, this.$L = R.$L, this.init();
              break;
            }
            D === H && (this.$d = /* @__PURE__ */ new Date(""));
          }
        else
          I.call(this, j);
      };
    };
  });
})(sE);
var GP = sE.exports;
const YP = /* @__PURE__ */ Ft(GP);
var oE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    var n, r, a = 1e3, i = 6e4, s = 36e5, o = 864e5, u = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, l = 31536e6, f = 2592e6, h = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, p = { years: l, months: f, days: o, hours: s, minutes: i, seconds: a, milliseconds: 1, weeks: 6048e5 }, b = function($) {
      return $ instanceof j;
    }, v = function($, _, M) {
      return new j($, M, _.$l);
    }, E = function($) {
      return r.p($) + "s";
    }, y = function($) {
      return $ < 0;
    }, N = function($) {
      return y($) ? Math.ceil($) : Math.floor($);
    }, A = function($) {
      return Math.abs($);
    }, I = function($, _) {
      return $ ? y($) ? { negative: !0, format: "" + A($) + _ } : { negative: !1, format: "" + $ + _ } : { negative: !1, format: "" };
    }, j = function() {
      function $(M, V, G) {
        var O = this;
        if (this.$d = {}, this.$l = G, M === void 0 && (this.$ms = 0, this.parseFromMilliseconds()), V)
          return v(M * p[E(V)], this);
        if (typeof M == "number")
          return this.$ms = M, this.parseFromMilliseconds(), this;
        if (typeof M == "object")
          return Object.keys(M).forEach(function(H) {
            O.$d[E(H)] = M[H];
          }), this.calMilliseconds(), this;
        if (typeof M == "string") {
          var Q = M.match(h);
          if (Q) {
            var ee = Q.slice(2).map(function(H) {
              return H != null ? Number(H) : 0;
            });
            return this.$d.years = ee[0], this.$d.months = ee[1], this.$d.weeks = ee[2], this.$d.days = ee[3], this.$d.hours = ee[4], this.$d.minutes = ee[5], this.$d.seconds = ee[6], this.calMilliseconds(), this;
          }
        }
        return this;
      }
      var _ = $.prototype;
      return _.calMilliseconds = function() {
        var M = this;
        this.$ms = Object.keys(this.$d).reduce(function(V, G) {
          return V + (M.$d[G] || 0) * p[G];
        }, 0);
      }, _.parseFromMilliseconds = function() {
        var M = this.$ms;
        this.$d.years = N(M / l), M %= l, this.$d.months = N(M / f), M %= f, this.$d.days = N(M / o), M %= o, this.$d.hours = N(M / s), M %= s, this.$d.minutes = N(M / i), M %= i, this.$d.seconds = N(M / a), M %= a, this.$d.milliseconds = M;
      }, _.toISOString = function() {
        var M = I(this.$d.years, "Y"), V = I(this.$d.months, "M"), G = +this.$d.days || 0;
        this.$d.weeks && (G += 7 * this.$d.weeks);
        var O = I(G, "D"), Q = I(this.$d.hours, "H"), ee = I(this.$d.minutes, "M"), H = this.$d.seconds || 0;
        this.$d.milliseconds && (H += this.$d.milliseconds / 1e3);
        var D = I(H, "S"), R = M.negative || V.negative || O.negative || Q.negative || ee.negative || D.negative, Y = Q.format || ee.format || D.format ? "T" : "", P = (R ? "-" : "") + "P" + M.format + V.format + O.format + Y + Q.format + ee.format + D.format;
        return P === "P" || P === "-P" ? "P0D" : P;
      }, _.toJSON = function() {
        return this.toISOString();
      }, _.format = function(M) {
        var V = M || "YYYY-MM-DDTHH:mm:ss", G = { Y: this.$d.years, YY: r.s(this.$d.years, 2, "0"), YYYY: r.s(this.$d.years, 4, "0"), M: this.$d.months, MM: r.s(this.$d.months, 2, "0"), D: this.$d.days, DD: r.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: r.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: r.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: r.s(this.$d.seconds, 2, "0"), SSS: r.s(this.$d.milliseconds, 3, "0") };
        return V.replace(u, function(O, Q) {
          return Q || String(G[O]);
        });
      }, _.as = function(M) {
        return this.$ms / p[E(M)];
      }, _.get = function(M) {
        var V = this.$ms, G = E(M);
        return G === "milliseconds" ? V %= 1e3 : V = G === "weeks" ? N(V / p[G]) : this.$d[G], V === 0 ? 0 : V;
      }, _.add = function(M, V, G) {
        var O;
        return O = V ? M * p[E(V)] : b(M) ? M.$ms : v(M, this).$ms, v(this.$ms + O * (G ? -1 : 1), this);
      }, _.subtract = function(M, V) {
        return this.add(M, V, !0);
      }, _.locale = function(M) {
        var V = this.clone();
        return V.$l = M, V;
      }, _.clone = function() {
        return v(this.$ms, this);
      }, _.humanize = function(M) {
        return n().add(this.$ms, "ms").locale(this.$l).fromNow(!M);
      }, _.milliseconds = function() {
        return this.get("milliseconds");
      }, _.asMilliseconds = function() {
        return this.as("milliseconds");
      }, _.seconds = function() {
        return this.get("seconds");
      }, _.asSeconds = function() {
        return this.as("seconds");
      }, _.minutes = function() {
        return this.get("minutes");
      }, _.asMinutes = function() {
        return this.as("minutes");
      }, _.hours = function() {
        return this.get("hours");
      }, _.asHours = function() {
        return this.as("hours");
      }, _.days = function() {
        return this.get("days");
      }, _.asDays = function() {
        return this.as("days");
      }, _.weeks = function() {
        return this.get("weeks");
      }, _.asWeeks = function() {
        return this.as("weeks");
      }, _.months = function() {
        return this.get("months");
      }, _.asMonths = function() {
        return this.as("months");
      }, _.years = function() {
        return this.get("years");
      }, _.asYears = function() {
        return this.as("years");
      }, $;
    }();
    return function($, _, M) {
      n = M, r = M().$utils(), M.duration = function(O, Q) {
        var ee = M.locale();
        return v(O, { $l: ee }, Q);
      }, M.isDuration = b;
      var V = _.prototype.add, G = _.prototype.subtract;
      _.prototype.add = function(O, Q) {
        return b(O) && (O = O.asMilliseconds()), V.bind(this)(O, Q);
      }, _.prototype.subtract = function(O, Q) {
        return b(O) && (O = O.asMilliseconds()), G.bind(this)(O, Q);
      };
    };
  });
})(oE);
var WP = oE.exports;
const qP = /* @__PURE__ */ Ft(WP);
var uE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    return function(n, r, a) {
      var i = function(s, o) {
        if (!o || !o.length || !o[0] || o.length === 1 && !o[0].length)
          return null;
        var u;
        o.length === 1 && o[0].length > 0 && (o = o[0]), u = o[0];
        for (var l = 1; l < o.length; l += 1)
          o[l].isValid() && !o[l][s](u) || (u = o[l]);
        return u;
      };
      a.max = function() {
        var s = [].slice.call(arguments, 0);
        return i("isAfter", s);
      }, a.min = function() {
        var s = [].slice.call(arguments, 0);
        return i("isBefore", s);
      };
    };
  });
})(uE);
var KP = uE.exports;
const XP = /* @__PURE__ */ Ft(KP);
var lE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    return function(n, r, a) {
      n = n || {};
      var i = r.prototype, s = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function o(l, f, h, p) {
        return i.fromToBase(l, f, h, p);
      }
      a.en.relativeTime = s, i.fromToBase = function(l, f, h, p, b) {
        for (var v, E, y, N = h.$locale().relativeTime || s, A = n.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], I = A.length, j = 0; j < I; j += 1) {
          var $ = A[j];
          $.d && (v = p ? a(l).diff(h, $.d, !0) : h.diff(l, $.d, !0));
          var _ = (n.rounding || Math.round)(Math.abs(v));
          if (y = v > 0, _ <= $.r || !$.r) {
            _ <= 1 && j > 0 && ($ = A[j - 1]);
            var M = N[$.l];
            b && (_ = b("" + _)), E = typeof M == "string" ? M.replace("%d", _) : M(_, f, $.l, y);
            break;
          }
        }
        if (f)
          return E;
        var V = y ? N.future : N.past;
        return typeof V == "function" ? V(E) : V.replace("%s", E);
      }, i.to = function(l, f) {
        return o(l, f, this, !0);
      }, i.from = function(l, f) {
        return o(l, f, this);
      };
      var u = function(l) {
        return l.$u ? a.utc() : a();
      };
      i.toNow = function(l) {
        return this.to(u(this), l);
      }, i.fromNow = function(l) {
        return this.from(u(this), l);
      };
    };
  });
})(lE);
var ZP = lE.exports;
const QP = /* @__PURE__ */ Ft(ZP);
var cE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    return function(n, r, a) {
      a.updateLocale = function(i, s) {
        var o = a.Ls[i];
        if (o)
          return (s ? Object.keys(s) : []).forEach(function(u) {
            o[u] = s[u];
          }), o;
      };
    };
  });
})(cE);
var JP = cE.exports;
const e6 = /* @__PURE__ */ Ft(JP);
var fE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    var n = "minute", r = /[+-]\d\d(?::?\d\d)?/g, a = /([+-]|\d\d)/g;
    return function(i, s, o) {
      var u = s.prototype;
      o.utc = function(E) {
        var y = { date: E, utc: !0, args: arguments };
        return new s(y);
      }, u.utc = function(E) {
        var y = o(this.toDate(), { locale: this.$L, utc: !0 });
        return E ? y.add(this.utcOffset(), n) : y;
      }, u.local = function() {
        return o(this.toDate(), { locale: this.$L, utc: !1 });
      };
      var l = u.parse;
      u.parse = function(E) {
        E.utc && (this.$u = !0), this.$utils().u(E.$offset) || (this.$offset = E.$offset), l.call(this, E);
      };
      var f = u.init;
      u.init = function() {
        if (this.$u) {
          var E = this.$d;
          this.$y = E.getUTCFullYear(), this.$M = E.getUTCMonth(), this.$D = E.getUTCDate(), this.$W = E.getUTCDay(), this.$H = E.getUTCHours(), this.$m = E.getUTCMinutes(), this.$s = E.getUTCSeconds(), this.$ms = E.getUTCMilliseconds();
        } else
          f.call(this);
      };
      var h = u.utcOffset;
      u.utcOffset = function(E, y) {
        var N = this.$utils().u;
        if (N(E))
          return this.$u ? 0 : N(this.$offset) ? h.call(this) : this.$offset;
        if (typeof E == "string" && (E = function($) {
          $ === void 0 && ($ = "");
          var _ = $.match(r);
          if (!_)
            return null;
          var M = ("" + _[0]).match(a) || ["-", 0, 0], V = M[0], G = 60 * +M[1] + +M[2];
          return G === 0 ? 0 : V === "+" ? G : -G;
        }(E)) === null)
          return this;
        var A = Math.abs(E) <= 16 ? 60 * E : E, I = this;
        if (y)
          return I.$offset = A, I.$u = E === 0, I;
        if (E !== 0) {
          var j = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (I = this.local().add(A + j, n)).$offset = A, I.$x.$localOffset = j;
        } else
          I = this.utc();
        return I;
      };
      var p = u.format;
      u.format = function(E) {
        var y = E || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return p.call(this, y);
      }, u.valueOf = function() {
        var E = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || (/* @__PURE__ */ new Date()).getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * E;
      }, u.isUTC = function() {
        return !!this.$u;
      }, u.toISOString = function() {
        return this.toDate().toISOString();
      }, u.toString = function() {
        return this.toDate().toUTCString();
      };
      var b = u.toDate;
      u.toDate = function(E) {
        return E === "s" && this.$offset ? o(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : b.call(this);
      };
      var v = u.diff;
      u.diff = function(E, y, N) {
        if (E && this.$u === E.$u)
          return v.call(this, E, y, N);
        var A = this.local(), I = o(E).local();
        return v.call(A, I, y, N);
      };
    };
  });
})(fE);
var t6 = fE.exports;
const n6 = /* @__PURE__ */ Ft(t6);
ca.extend(n6);
ca.extend(qP);
ca.extend(QP);
ca.extend(YP);
ca.extend(XP);
ca.extend(VP);
ca.extend(e6);
ca.updateLocale("en", {
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
  }
});
const r6 = [
  {
    group: "US (Common)",
    zones: [
      {
        value: "US/Puerto_Rico",
        name: "Puerto Rico (Atlantic)"
      },
      {
        value: "US/New_York",
        name: "New York (Eastern)"
      },
      {
        value: "US/Chicago",
        name: "Chicago (Central)"
      },
      {
        value: "US/Denver",
        name: "Denver (Mountain)"
      },
      {
        value: "US/Phoenix",
        name: "Phoenix (MST)"
      },
      {
        value: "US/Los_Angeles",
        name: "Los Angeles (Pacific)"
      },
      {
        value: "US/Anchorage",
        name: "Anchorage (Alaska)"
      },
      {
        value: "America Pacific/Honolulu",
        name: "Honolulu (Hawaii)"
      }
    ]
  },
  {
    group: "America",
    zones: [
      {
        value: "America/Adak",
        name: "Adak"
      },
      {
        value: "America/Anchorage",
        name: "Anchorage"
      },
      {
        value: "America/Anguilla",
        name: "Anguilla"
      },
      {
        value: "America/Antigua",
        name: "Antigua"
      },
      {
        value: "America/Araguaina",
        name: "Araguaina"
      },
      {
        value: "America/Argentina/Buenos_Aires",
        name: "Argentina - Buenos Aires"
      },
      {
        value: "America/Argentina/Catamarca",
        name: "Argentina - Catamarca"
      },
      {
        value: "America/Argentina/ComodRivadavia",
        name: "Argentina - ComodRivadavia"
      },
      {
        value: "America/Argentina/Cordoba",
        name: "Argentina - Cordoba"
      },
      {
        value: "America/Argentina/Jujuy",
        name: "Argentina - Jujuy"
      },
      {
        value: "America/Argentina/La_Rioja",
        name: "Argentina - La Rioja"
      },
      {
        value: "America/Argentina/Mendoza",
        name: "Argentina - Mendoza"
      },
      {
        value: "America/Argentina/Rio_Gallegos",
        name: "Argentina - Rio Gallegos"
      },
      {
        value: "America/Argentina/Salta",
        name: "Argentina - Salta"
      },
      {
        value: "America/Argentina/San_Juan",
        name: "Argentina - San Juan"
      },
      {
        value: "America/Argentina/San_Luis",
        name: "Argentina - San Luis"
      },
      {
        value: "America/Argentina/Tucuman",
        name: "Argentina - Tucuman"
      },
      {
        value: "America/Argentina/Ushuaia",
        name: "Argentina - Ushuaia"
      },
      {
        value: "America/Aruba",
        name: "Aruba"
      },
      {
        value: "America/Asuncion",
        name: "Asuncion"
      },
      {
        value: "America/Atikokan",
        name: "Atikokan"
      },
      {
        value: "America/Atka",
        name: "Atka"
      },
      {
        value: "America/Bahia",
        name: "Bahia"
      },
      {
        value: "America/Barbados",
        name: "Barbados"
      },
      {
        value: "America/Belem",
        name: "Belem"
      },
      {
        value: "America/Belize",
        name: "Belize"
      },
      {
        value: "America/Blanc-Sablon",
        name: "Blanc-Sablon"
      },
      {
        value: "America/Boa_Vista",
        name: "Boa Vista"
      },
      {
        value: "America/Bogota",
        name: "Bogota"
      },
      {
        value: "America/Boise",
        name: "Boise"
      },
      {
        value: "America/Buenos_Aires",
        name: "Buenos Aires"
      },
      {
        value: "America/Cambridge_Bay",
        name: "Cambridge Bay"
      },
      {
        value: "America/Campo_Grande",
        name: "Campo Grande"
      },
      {
        value: "America/Cancun",
        name: "Cancun"
      },
      {
        value: "America/Caracas",
        name: "Caracas"
      },
      {
        value: "America/Catamarca",
        name: "Catamarca"
      },
      {
        value: "America/Cayenne",
        name: "Cayenne"
      },
      {
        value: "America/Cayman",
        name: "Cayman"
      },
      {
        value: "America/Chicago",
        name: "Chicago"
      },
      {
        value: "America/Chihuahua",
        name: "Chihuahua"
      },
      {
        value: "America/Coral_Harbour",
        name: "Coral Harbour"
      },
      {
        value: "America/Cordoba",
        name: "Cordoba"
      },
      {
        value: "America/Costa_Rica",
        name: "Costa Rica"
      },
      {
        value: "America/Cuiaba",
        name: "Cuiaba"
      },
      {
        value: "America/Curacao",
        name: "Curacao"
      },
      {
        value: "America/Danmarkshavn",
        name: "Danmarkshavn"
      },
      {
        value: "America/Dawson",
        name: "Dawson"
      },
      {
        value: "America/Dawson_Creek",
        name: "Dawson Creek"
      },
      {
        value: "America/Denver",
        name: "Denver"
      },
      {
        value: "America/Detroit",
        name: "Detroit"
      },
      {
        value: "America/Dominica",
        name: "Dominica"
      },
      {
        value: "America/Edmonton",
        name: "Edmonton"
      },
      {
        value: "America/Eirunepe",
        name: "Eirunepe"
      },
      {
        value: "America/El_Salvador",
        name: "El Salvador"
      },
      {
        value: "America/Ensenada",
        name: "Ensenada"
      },
      {
        value: "America/Fortaleza",
        name: "Fortaleza"
      },
      {
        value: "America/Fort_Wayne",
        name: "Fort Wayne"
      },
      {
        value: "America/Glace_Bay",
        name: "Glace Bay"
      },
      {
        value: "America/Godthab",
        name: "Godthab"
      },
      {
        value: "America/Goose_Bay",
        name: "Goose Bay"
      },
      {
        value: "America/Grand_Turk",
        name: "Grand Turk"
      },
      {
        value: "America/Grenada",
        name: "Grenada"
      },
      {
        value: "America/Guadeloupe",
        name: "Guadeloupe"
      },
      {
        value: "America/Guatemala",
        name: "Guatemala"
      },
      {
        value: "America/Guayaquil",
        name: "Guayaquil"
      },
      {
        value: "America/Guyana",
        name: "Guyana"
      },
      {
        value: "America/Halifax",
        name: "Halifax"
      },
      {
        value: "America/Havana",
        name: "Havana"
      },
      {
        value: "America/Hermosillo",
        name: "Hermosillo"
      },
      {
        value: "America/Indiana/Indianapolis",
        name: "Indiana - Indianapolis"
      },
      {
        value: "America/Indiana/Knox",
        name: "Indiana - Knox"
      },
      {
        value: "America/Indiana/Marengo",
        name: "Indiana - Marengo"
      },
      {
        value: "America/Indiana/Petersburg",
        name: "Indiana - Petersburg"
      },
      {
        value: "America/Indiana/Tell_City",
        name: "Indiana - Tell City"
      },
      {
        value: "America/Indiana/Vevay",
        name: "Indiana - Vevay"
      },
      {
        value: "America/Indiana/Vincennes",
        name: "Indiana - Vincennes"
      },
      {
        value: "America/Indiana/Winamac",
        name: "Indiana - Winamac"
      },
      {
        value: "America/Indianapolis",
        name: "Indianapolis"
      },
      {
        value: "America/Inuvik",
        name: "Inuvik"
      },
      {
        value: "America/Iqaluit",
        name: "Iqaluit"
      },
      {
        value: "America/Jamaica",
        name: "Jamaica"
      },
      {
        value: "America/Jujuy",
        name: "Jujuy"
      },
      {
        value: "America/Juneau",
        name: "Juneau"
      },
      {
        value: "America/Kentucky/Louisville",
        name: "Kentucky - Louisville"
      },
      {
        value: "America/Kentucky/Monticello",
        name: "Kentucky - Monticello"
      },
      {
        value: "America/Knox_IN",
        name: "Knox IN"
      },
      {
        value: "America/La_Paz",
        name: "La Paz"
      },
      {
        value: "America/Lima",
        name: "Lima"
      },
      {
        value: "America/Los_Angeles",
        name: "Los Angeles"
      },
      {
        value: "America/Louisville",
        name: "Louisville"
      },
      {
        value: "America/Maceio",
        name: "Maceio"
      },
      {
        value: "America/Managua",
        name: "Managua"
      },
      {
        value: "America/Manaus",
        name: "Manaus"
      },
      {
        value: "America/Marigot",
        name: "Marigot"
      },
      {
        value: "America/Martinique",
        name: "Martinique"
      },
      {
        value: "America/Matamoros",
        name: "Matamoros"
      },
      {
        value: "America/Mazatlan",
        name: "Mazatlan"
      },
      {
        value: "America/Mendoza",
        name: "Mendoza"
      },
      {
        value: "America/Menominee",
        name: "Menominee"
      },
      {
        value: "America/Merida",
        name: "Merida"
      },
      {
        value: "America/Mexico_City",
        name: "Mexico City"
      },
      {
        value: "America/Miquelon",
        name: "Miquelon"
      },
      {
        value: "America/Moncton",
        name: "Moncton"
      },
      {
        value: "America/Monterrey",
        name: "Monterrey"
      },
      {
        value: "America/Montevideo",
        name: "Montevideo"
      },
      {
        value: "America/Montreal",
        name: "Montreal"
      },
      {
        value: "America/Montserrat",
        name: "Montserrat"
      },
      {
        value: "America/Nassau",
        name: "Nassau"
      },
      {
        value: "America/New_York",
        name: "New York"
      },
      {
        value: "America/Nipigon",
        name: "Nipigon"
      },
      {
        value: "America/Nome",
        name: "Nome"
      },
      {
        value: "America/Noronha",
        name: "Noronha"
      },
      {
        value: "America/North_Dakota/Center",
        name: "North Dakota - Center"
      },
      {
        value: "America/North_Dakota/New_Salem",
        name: "North Dakota - New Salem"
      },
      {
        value: "America/Ojinaga",
        name: "Ojinaga"
      },
      {
        value: "America/Panama",
        name: "Panama"
      },
      {
        value: "America/Pangnirtung",
        name: "Pangnirtung"
      },
      {
        value: "America/Paramaribo",
        name: "Paramaribo"
      },
      {
        value: "America/Phoenix",
        name: "Phoenix"
      },
      {
        value: "America/Port-au-Prince",
        name: "Port-au-Prince"
      },
      {
        value: "America/Porto_Acre",
        name: "Porto Acre"
      },
      {
        value: "America/Port_of_Spain",
        name: "Port of Spain"
      },
      {
        value: "America/Porto_Velho",
        name: "Porto Velho"
      },
      {
        value: "America/Puerto_Rico",
        name: "Puerto Rico"
      },
      {
        value: "America/Rainy_River",
        name: "Rainy River"
      },
      {
        value: "America/Rankin_Inlet",
        name: "Rankin Inlet"
      },
      {
        value: "America/Recife",
        name: "Recife"
      },
      {
        value: "America/Regina",
        name: "Regina"
      },
      {
        value: "America/Resolute",
        name: "Resolute"
      },
      {
        value: "America/Rio_Branco",
        name: "Rio Branco"
      },
      {
        value: "America/Rosario",
        name: "Rosario"
      },
      {
        value: "America/Santa_Isabel",
        name: "Santa Isabel"
      },
      {
        value: "America/Santarem",
        name: "Santarem"
      },
      {
        value: "America/Santiago",
        name: "Santiago"
      },
      {
        value: "America/Santo_Domingo",
        name: "Santo Domingo"
      },
      {
        value: "America/Sao_Paulo",
        name: "Sao Paulo"
      },
      {
        value: "America/Scoresbysund",
        name: "Scoresbysund"
      },
      {
        value: "America/Shiprock",
        name: "Shiprock"
      },
      {
        value: "America/St_Barthelemy",
        name: "St Barthelemy"
      },
      {
        value: "America/St_Johns",
        name: "St Johns"
      },
      {
        value: "America/St_Kitts",
        name: "St Kitts"
      },
      {
        value: "America/St_Lucia",
        name: "St Lucia"
      },
      {
        value: "America/St_Thomas",
        name: "St Thomas"
      },
      {
        value: "America/St_Vincent",
        name: "St Vincent"
      },
      {
        value: "America/Swift_Current",
        name: "Swift Current"
      },
      {
        value: "America/Tegucigalpa",
        name: "Tegucigalpa"
      },
      {
        value: "America/Thule",
        name: "Thule"
      },
      {
        value: "America/Thunder_Bay",
        name: "Thunder Bay"
      },
      {
        value: "America/Tijuana",
        name: "Tijuana"
      },
      {
        value: "America/Toronto",
        name: "Toronto"
      },
      {
        value: "America/Tortola",
        name: "Tortola"
      },
      {
        value: "America/Vancouver",
        name: "Vancouver"
      },
      {
        value: "America/Virgin",
        name: "Virgin"
      },
      {
        value: "America/Whitehorse",
        name: "Whitehorse"
      },
      {
        value: "America/Winnipeg",
        name: "Winnipeg"
      },
      {
        value: "America/Yakutat",
        name: "Yakutat"
      },
      {
        value: "America/Yellowknife",
        name: "Yellowknife"
      }
    ]
  },
  {
    group: "Europe",
    zones: [
      {
        value: "Europe/Amsterdam",
        name: "Amsterdam"
      },
      {
        value: "Europe/Andorra",
        name: "Andorra"
      },
      {
        value: "Europe/Athens",
        name: "Athens"
      },
      {
        value: "Europe/Belfast",
        name: "Belfast"
      },
      {
        value: "Europe/Belgrade",
        name: "Belgrade"
      },
      {
        value: "Europe/Berlin",
        name: "Berlin"
      },
      {
        value: "Europe/Bratislava",
        name: "Bratislava"
      },
      {
        value: "Europe/Brussels",
        name: "Brussels"
      },
      {
        value: "Europe/Bucharest",
        name: "Bucharest"
      },
      {
        value: "Europe/Budapest",
        name: "Budapest"
      },
      {
        value: "Europe/Chisinau",
        name: "Chisinau"
      },
      {
        value: "Europe/Copenhagen",
        name: "Copenhagen"
      },
      {
        value: "Europe/Dublin",
        name: "Dublin"
      },
      {
        value: "Europe/Gibraltar",
        name: "Gibraltar"
      },
      {
        value: "Europe/Guernsey",
        name: "Guernsey"
      },
      {
        value: "Europe/Helsinki",
        name: "Helsinki"
      },
      {
        value: "Europe/Isle_of_Man",
        name: "Isle of Man"
      },
      {
        value: "Europe/Istanbul",
        name: "Istanbul"
      },
      {
        value: "Europe/Jersey",
        name: "Jersey"
      },
      {
        value: "Europe/Kaliningrad",
        name: "Kaliningrad"
      },
      {
        value: "Europe/Kiev",
        name: "Kiev"
      },
      {
        value: "Europe/Lisbon",
        name: "Lisbon"
      },
      {
        value: "Europe/Ljubljana",
        name: "Ljubljana"
      },
      {
        value: "Europe/London",
        name: "London"
      },
      {
        value: "Europe/Luxembourg",
        name: "Luxembourg"
      },
      {
        value: "Europe/Madrid",
        name: "Madrid"
      },
      {
        value: "Europe/Malta",
        name: "Malta"
      },
      {
        value: "Europe/Mariehamn",
        name: "Mariehamn"
      },
      {
        value: "Europe/Minsk",
        name: "Minsk"
      },
      {
        value: "Europe/Monaco",
        name: "Monaco"
      },
      {
        value: "Europe/Moscow",
        name: "Moscow"
      },
      {
        value: "Europe/Nicosia",
        name: "Nicosia"
      },
      {
        value: "Europe/Oslo",
        name: "Oslo"
      },
      {
        value: "Europe/Paris",
        name: "Paris"
      },
      {
        value: "Europe/Podgorica",
        name: "Podgorica"
      },
      {
        value: "Europe/Prague",
        name: "Prague"
      },
      {
        value: "Europe/Riga",
        name: "Riga"
      },
      {
        value: "Europe/Rome",
        name: "Rome"
      },
      {
        value: "Europe/Samara",
        name: "Samara"
      },
      {
        value: "Europe/San_Marino",
        name: "San Marino"
      },
      {
        value: "Europe/Sarajevo",
        name: "Sarajevo"
      },
      {
        value: "Europe/Simferopol",
        name: "Simferopol"
      },
      {
        value: "Europe/Skopje",
        name: "Skopje"
      },
      {
        value: "Europe/Sofia",
        name: "Sofia"
      },
      {
        value: "Europe/Stockholm",
        name: "Stockholm"
      },
      {
        value: "Europe/Tallinn",
        name: "Tallinn"
      },
      {
        value: "Europe/Tirane",
        name: "Tirane"
      },
      {
        value: "Europe/Tiraspol",
        name: "Tiraspol"
      },
      {
        value: "Europe/Uzhgorod",
        name: "Uzhgorod"
      },
      {
        value: "Europe/Vaduz",
        name: "Vaduz"
      },
      {
        value: "Europe/Vatican",
        name: "Vatican"
      },
      {
        value: "Europe/Vienna",
        name: "Vienna"
      },
      {
        value: "Europe/Vilnius",
        name: "Vilnius"
      },
      {
        value: "Europe/Volgograd",
        name: "Volgograd"
      },
      {
        value: "Europe/Warsaw",
        name: "Warsaw"
      },
      {
        value: "Europe/Zagreb",
        name: "Zagreb"
      },
      {
        value: "Europe/Zaporozhye",
        name: "Zaporozhye"
      },
      {
        value: "Europe/Zurich",
        name: "Zurich"
      }
    ]
  },
  {
    group: "Asia",
    zones: [
      {
        value: "Asia/Aden",
        name: "Aden"
      },
      {
        value: "Asia/Almaty",
        name: "Almaty"
      },
      {
        value: "Asia/Amman",
        name: "Amman"
      },
      {
        value: "Asia/Anadyr",
        name: "Anadyr"
      },
      {
        value: "Asia/Aqtau",
        name: "Aqtau"
      },
      {
        value: "Asia/Aqtobe",
        name: "Aqtobe"
      },
      {
        value: "Asia/Ashgabat",
        name: "Ashgabat"
      },
      {
        value: "Asia/Ashkhabad",
        name: "Ashkhabad"
      },
      {
        value: "Asia/Baghdad",
        name: "Baghdad"
      },
      {
        value: "Asia/Bahrain",
        name: "Bahrain"
      },
      {
        value: "Asia/Baku",
        name: "Baku"
      },
      {
        value: "Asia/Bangkok",
        name: "Bangkok"
      },
      {
        value: "Asia/Beirut",
        name: "Beirut"
      },
      {
        value: "Asia/Bishkek",
        name: "Bishkek"
      },
      {
        value: "Asia/Brunei",
        name: "Brunei"
      },
      {
        value: "Asia/Calcutta",
        name: "Calcutta"
      },
      {
        value: "Asia/Choibalsan",
        name: "Choibalsan"
      },
      {
        value: "Asia/Chongqing",
        name: "Chongqing"
      },
      {
        value: "Asia/Chungking",
        name: "Chungking"
      },
      {
        value: "Asia/Colombo",
        name: "Colombo"
      },
      {
        value: "Asia/Dacca",
        name: "Dacca"
      },
      {
        value: "Asia/Damascus",
        name: "Damascus"
      },
      {
        value: "Asia/Dhaka",
        name: "Dhaka"
      },
      {
        value: "Asia/Dili",
        name: "Dili"
      },
      {
        value: "Asia/Dubai",
        name: "Dubai"
      },
      {
        value: "Asia/Dushanbe",
        name: "Dushanbe"
      },
      {
        value: "Asia/Gaza",
        name: "Gaza"
      },
      {
        value: "Asia/Harbin",
        name: "Harbin"
      },
      {
        value: "Asia/Ho_Chi_Minh",
        name: "Ho Chi Minh"
      },
      {
        value: "Asia/Hong_Kong",
        name: "Hong Kong"
      },
      {
        value: "Asia/Hovd",
        name: "Hovd"
      },
      {
        value: "Asia/Irkutsk",
        name: "Irkutsk"
      },
      {
        value: "Asia/Istanbul",
        name: "Istanbul"
      },
      {
        value: "Asia/Jakarta",
        name: "Jakarta"
      },
      {
        value: "Asia/Jayapura",
        name: "Jayapura"
      },
      {
        value: "Asia/Jerusalem",
        name: "Jerusalem"
      },
      {
        value: "Asia/Kabul",
        name: "Kabul"
      },
      {
        value: "Asia/Kamchatka",
        name: "Kamchatka"
      },
      {
        value: "Asia/Karachi",
        name: "Karachi"
      },
      {
        value: "Asia/Kashgar",
        name: "Kashgar"
      },
      {
        value: "Asia/Kathmandu",
        name: "Kathmandu"
      },
      {
        value: "Asia/Katmandu",
        name: "Katmandu"
      },
      {
        value: "Asia/Kolkata",
        name: "Kolkata"
      },
      {
        value: "Asia/Krasnoyarsk",
        name: "Krasnoyarsk"
      },
      {
        value: "Asia/Kuala_Lumpur",
        name: "Kuala Lumpur"
      },
      {
        value: "Asia/Kuching",
        name: "Kuching"
      },
      {
        value: "Asia/Kuwait",
        name: "Kuwait"
      },
      {
        value: "Asia/Macao",
        name: "Macao"
      },
      {
        value: "Asia/Macau",
        name: "Macau"
      },
      {
        value: "Asia/Magadan",
        name: "Magadan"
      },
      {
        value: "Asia/Makassar",
        name: "Makassar"
      },
      {
        value: "Asia/Manila",
        name: "Manila"
      },
      {
        value: "Asia/Muscat",
        name: "Muscat"
      },
      {
        value: "Asia/Nicosia",
        name: "Nicosia"
      },
      {
        value: "Asia/Novokuznetsk",
        name: "Novokuznetsk"
      },
      {
        value: "Asia/Novosibirsk",
        name: "Novosibirsk"
      },
      {
        value: "Asia/Omsk",
        name: "Omsk"
      },
      {
        value: "Asia/Oral",
        name: "Oral"
      },
      {
        value: "Asia/Phnom_Penh",
        name: "Phnom Penh"
      },
      {
        value: "Asia/Pontianak",
        name: "Pontianak"
      },
      {
        value: "Asia/Pyongyang",
        name: "Pyongyang"
      },
      {
        value: "Asia/Qatar",
        name: "Qatar"
      },
      {
        value: "Asia/Qyzylorda",
        name: "Qyzylorda"
      },
      {
        value: "Asia/Rangoon",
        name: "Rangoon"
      },
      {
        value: "Asia/Riyadh",
        name: "Riyadh"
      },
      {
        value: "Asia/Saigon",
        name: "Saigon"
      },
      {
        value: "Asia/Sakhalin",
        name: "Sakhalin"
      },
      {
        value: "Asia/Samarkand",
        name: "Samarkand"
      },
      {
        value: "Asia/Seoul",
        name: "Seoul"
      },
      {
        value: "Asia/Shanghai",
        name: "Shanghai"
      },
      {
        value: "Asia/Singapore",
        name: "Singapore"
      },
      {
        value: "Asia/Taipei",
        name: "Taipei"
      },
      {
        value: "Asia/Tashkent",
        name: "Tashkent"
      },
      {
        value: "Asia/Tbilisi",
        name: "Tbilisi"
      },
      {
        value: "Asia/Tehran",
        name: "Tehran"
      },
      {
        value: "Asia/Tel_Aviv",
        name: "Tel Aviv"
      },
      {
        value: "Asia/Thimbu",
        name: "Thimbu"
      },
      {
        value: "Asia/Thimphu",
        name: "Thimphu"
      },
      {
        value: "Asia/Tokyo",
        name: "Tokyo"
      },
      {
        value: "Asia/Ujung_Pandang",
        name: "Ujung Pandang"
      },
      {
        value: "Asia/Ulaanbaatar",
        name: "Ulaanbaatar"
      },
      {
        value: "Asia/Ulan_Bator",
        name: "Ulan Bator"
      },
      {
        value: "Asia/Urumqi",
        name: "Urumqi"
      },
      {
        value: "Asia/Vientiane",
        name: "Vientiane"
      },
      {
        value: "Asia/Vladivostok",
        name: "Vladivostok"
      },
      {
        value: "Asia/Yakutsk",
        name: "Yakutsk"
      },
      {
        value: "Asia/Yekaterinburg",
        name: "Yekaterinburg"
      },
      {
        value: "Asia/Yerevan",
        name: "Yerevan"
      }
    ]
  },
  {
    group: "Africa",
    zones: [
      {
        value: "Africa/Abidjan",
        name: "Abidjan"
      },
      {
        value: "Africa/Accra",
        name: "Accra"
      },
      {
        value: "Africa/Addis_Ababa",
        name: "Addis Ababa"
      },
      {
        value: "Africa/Algiers",
        name: "Algiers"
      },
      {
        value: "Africa/Asmara",
        name: "Asmara"
      },
      {
        value: "Africa/Asmera",
        name: "Asmera"
      },
      {
        value: "Africa/Bamako",
        name: "Bamako"
      },
      {
        value: "Africa/Bangui",
        name: "Bangui"
      },
      {
        value: "Africa/Banjul",
        name: "Banjul"
      },
      {
        value: "Africa/Bissau",
        name: "Bissau"
      },
      {
        value: "Africa/Blantyre",
        name: "Blantyre"
      },
      {
        value: "Africa/Brazzaville",
        name: "Brazzaville"
      },
      {
        value: "Africa/Bujumbura",
        name: "Bujumbura"
      },
      {
        value: "Africa/Cairo",
        name: "Cairo"
      },
      {
        value: "Africa/Casablanca",
        name: "Casablanca"
      },
      {
        value: "Africa/Ceuta",
        name: "Ceuta"
      },
      {
        value: "Africa/Conakry",
        name: "Conakry"
      },
      {
        value: "Africa/Dakar",
        name: "Dakar"
      },
      {
        value: "Africa/Dar_es_Salaam",
        name: "Dar es Salaam"
      },
      {
        value: "Africa/Djibouti",
        name: "Djibouti"
      },
      {
        value: "Africa/Douala",
        name: "Douala"
      },
      {
        value: "Africa/El_Aaiun",
        name: "El Aaiun"
      },
      {
        value: "Africa/Freetown",
        name: "Freetown"
      },
      {
        value: "Africa/Gaborone",
        name: "Gaborone"
      },
      {
        value: "Africa/Harare",
        name: "Harare"
      },
      {
        value: "Africa/Johannesburg",
        name: "Johannesburg"
      },
      {
        value: "Africa/Kampala",
        name: "Kampala"
      },
      {
        value: "Africa/Khartoum",
        name: "Khartoum"
      },
      {
        value: "Africa/Kigali",
        name: "Kigali"
      },
      {
        value: "Africa/Kinshasa",
        name: "Kinshasa"
      },
      {
        value: "Africa/Lagos",
        name: "Lagos"
      },
      {
        value: "Africa/Libreville",
        name: "Libreville"
      },
      {
        value: "Africa/Lome",
        name: "Lome"
      },
      {
        value: "Africa/Luanda",
        name: "Luanda"
      },
      {
        value: "Africa/Lubumbashi",
        name: "Lubumbashi"
      },
      {
        value: "Africa/Lusaka",
        name: "Lusaka"
      },
      {
        value: "Africa/Malabo",
        name: "Malabo"
      },
      {
        value: "Africa/Maputo",
        name: "Maputo"
      },
      {
        value: "Africa/Maseru",
        name: "Maseru"
      },
      {
        value: "Africa/Mbabane",
        name: "Mbabane"
      },
      {
        value: "Africa/Mogadishu",
        name: "Mogadishu"
      },
      {
        value: "Africa/Monrovia",
        name: "Monrovia"
      },
      {
        value: "Africa/Nairobi",
        name: "Nairobi"
      },
      {
        value: "Africa/Ndjamena",
        name: "Ndjamena"
      },
      {
        value: "Africa/Niamey",
        name: "Niamey"
      },
      {
        value: "Africa/Nouakchott",
        name: "Nouakchott"
      },
      {
        value: "Africa/Ouagadougou",
        name: "Ouagadougou"
      },
      {
        value: "Africa/Porto-Novo",
        name: "Porto-Novo"
      },
      {
        value: "Africa/Sao_Tome",
        name: "Sao Tome"
      },
      {
        value: "Africa/Timbuktu",
        name: "Timbuktu"
      },
      {
        value: "Africa/Tripoli",
        name: "Tripoli"
      },
      {
        value: "Africa/Tunis",
        name: "Tunis"
      },
      {
        value: "Africa/Windhoek",
        name: "Windhoek"
      }
    ]
  },
  {
    group: "Australia",
    zones: [
      {
        value: "Australia/ACT",
        name: "ACT"
      },
      {
        value: "Australia/Adelaide",
        name: "Adelaide"
      },
      {
        value: "Australia/Brisbane",
        name: "Brisbane"
      },
      {
        value: "Australia/Broken_Hill",
        name: "Broken Hill"
      },
      {
        value: "Australia/Canberra",
        name: "Canberra"
      },
      {
        value: "Australia/Currie",
        name: "Currie"
      },
      {
        value: "Australia/Darwin",
        name: "Darwin"
      },
      {
        value: "Australia/Eucla",
        name: "Eucla"
      },
      {
        value: "Australia/Hobart",
        name: "Hobart"
      },
      {
        value: "Australia/LHI",
        name: "LHI"
      },
      {
        value: "Australia/Lindeman",
        name: "Lindeman"
      },
      {
        value: "Australia/Lord_Howe",
        name: "Lord Howe"
      },
      {
        value: "Australia/Melbourne",
        name: "Melbourne"
      },
      {
        value: "Australia/North",
        name: "North"
      },
      {
        value: "Australia/NSW",
        name: "NSW"
      },
      {
        value: "Australia/Perth",
        name: "Perth"
      },
      {
        value: "Australia/Queensland",
        name: "Queensland"
      },
      {
        value: "Australia/South",
        name: "South"
      },
      {
        value: "Australia/Sydney",
        name: "Sydney"
      },
      {
        value: "Australia/Tasmania",
        name: "Tasmania"
      },
      {
        value: "Australia/Victoria",
        name: "Victoria"
      },
      {
        value: "Australia/West",
        name: "West"
      },
      {
        value: "Australia/Yancowinna",
        name: "Yancowinna"
      }
    ]
  },
  {
    group: "Indian",
    zones: [
      {
        value: "Indian/Antananarivo",
        name: "Antananarivo"
      },
      {
        value: "Indian/Chagos",
        name: "Chagos"
      },
      {
        value: "Indian/Christmas",
        name: "Christmas"
      },
      {
        value: "Indian/Cocos",
        name: "Cocos"
      },
      {
        value: "Indian/Comoro",
        name: "Comoro"
      },
      {
        value: "Indian/Kerguelen",
        name: "Kerguelen"
      },
      {
        value: "Indian/Mahe",
        name: "Mahe"
      },
      {
        value: "Indian/Maldives",
        name: "Maldives"
      },
      {
        value: "Indian/Mauritius",
        name: "Mauritius"
      },
      {
        value: "Indian/Mayotte",
        name: "Mayotte"
      },
      {
        value: "Indian/Reunion",
        name: "Reunion"
      }
    ]
  },
  {
    group: "Atlantic",
    zones: [
      {
        value: "Atlantic/Azores",
        name: "Azores"
      },
      {
        value: "Atlantic/Bermuda",
        name: "Bermuda"
      },
      {
        value: "Atlantic/Canary",
        name: "Canary"
      },
      {
        value: "Atlantic/Cape_Verde",
        name: "Cape Verde"
      },
      {
        value: "Atlantic/Faeroe",
        name: "Faeroe"
      },
      {
        value: "Atlantic/Faroe",
        name: "Faroe"
      },
      {
        value: "Atlantic/Jan_Mayen",
        name: "Jan Mayen"
      },
      {
        value: "Atlantic/Madeira",
        name: "Madeira"
      },
      {
        value: "Atlantic/Reykjavik",
        name: "Reykjavik"
      },
      {
        value: "Atlantic/South_Georgia",
        name: "South Georgia"
      },
      {
        value: "Atlantic/Stanley",
        name: "Stanley"
      },
      {
        value: "Atlantic/St_Helena",
        name: "St Helena"
      }
    ]
  },
  {
    group: "Pacific",
    zones: [
      {
        value: "Pacific/Apia",
        name: "Apia"
      },
      {
        value: "Pacific/Auckland",
        name: "Auckland"
      },
      {
        value: "Pacific/Chatham",
        name: "Chatham"
      },
      {
        value: "Pacific/Easter",
        name: "Easter"
      },
      {
        value: "Pacific/Efate",
        name: "Efate"
      },
      {
        value: "Pacific/Enderbury",
        name: "Enderbury"
      },
      {
        value: "Pacific/Fakaofo",
        name: "Fakaofo"
      },
      {
        value: "Pacific/Fiji",
        name: "Fiji"
      },
      {
        value: "Pacific/Funafuti",
        name: "Funafuti"
      },
      {
        value: "Pacific/Galapagos",
        name: "Galapagos"
      },
      {
        value: "Pacific/Gambier",
        name: "Gambier"
      },
      {
        value: "Pacific/Guadalcanal",
        name: "Guadalcanal"
      },
      {
        value: "Pacific/Guam",
        name: "Guam"
      },
      {
        value: "Pacific/Honolulu",
        name: "Honolulu"
      },
      {
        value: "Pacific/Johnston",
        name: "Johnston"
      },
      {
        value: "Pacific/Kiritimati",
        name: "Kiritimati"
      },
      {
        value: "Pacific/Kosrae",
        name: "Kosrae"
      },
      {
        value: "Pacific/Kwajalein",
        name: "Kwajalein"
      },
      {
        value: "Pacific/Majuro",
        name: "Majuro"
      },
      {
        value: "Pacific/Marquesas",
        name: "Marquesas"
      },
      {
        value: "Pacific/Midway",
        name: "Midway"
      },
      {
        value: "Pacific/Nauru",
        name: "Nauru"
      },
      {
        value: "Pacific/Niue",
        name: "Niue"
      },
      {
        value: "Pacific/Norfolk",
        name: "Norfolk"
      },
      {
        value: "Pacific/Noumea",
        name: "Noumea"
      },
      {
        value: "Pacific/Pago_Pago",
        name: "Pago Pago"
      },
      {
        value: "Pacific/Palau",
        name: "Palau"
      },
      {
        value: "Pacific/Pitcairn",
        name: "Pitcairn"
      },
      {
        value: "Pacific/Ponape",
        name: "Ponape"
      },
      {
        value: "Pacific/Port_Moresby",
        name: "Port Moresby"
      },
      {
        value: "Pacific/Rarotonga",
        name: "Rarotonga"
      },
      {
        value: "Pacific/Saipan",
        name: "Saipan"
      },
      {
        value: "Pacific/Samoa",
        name: "Samoa"
      },
      {
        value: "Pacific/Tahiti",
        name: "Tahiti"
      },
      {
        value: "Pacific/Tarawa",
        name: "Tarawa"
      },
      {
        value: "Pacific/Tongatapu",
        name: "Tongatapu"
      },
      {
        value: "Pacific/Truk",
        name: "Truk"
      },
      {
        value: "Pacific/Wake",
        name: "Wake"
      },
      {
        value: "Pacific/Wallis",
        name: "Wallis"
      },
      {
        value: "Pacific/Yap",
        name: "Yap"
      }
    ]
  },
  {
    group: "Antarctica",
    zones: [
      {
        value: "Antarctica/Casey",
        name: "Casey"
      },
      {
        value: "Antarctica/Davis",
        name: "Davis"
      },
      {
        value: "Antarctica/DumontDUrville",
        name: "DumontDUrville"
      },
      {
        value: "Antarctica/Macquarie",
        name: "Macquarie"
      },
      {
        value: "Antarctica/Mawson",
        name: "Mawson"
      },
      {
        value: "Antarctica/McMurdo",
        name: "McMurdo"
      },
      {
        value: "Antarctica/Palmer",
        name: "Palmer"
      },
      {
        value: "Antarctica/Rothera",
        name: "Rothera"
      },
      {
        value: "Antarctica/South_Pole",
        name: "South Pole"
      },
      {
        value: "Antarctica/Syowa",
        name: "Syowa"
      },
      {
        value: "Antarctica/Vostok",
        name: "Vostok"
      }
    ]
  },
  {
    group: "Arctic",
    zones: [
      {
        value: "Arctic/Longyearbyen",
        name: "Longyearbyen"
      }
    ]
  },
  {
    group: "UTC",
    zones: [
      {
        value: "UTC",
        name: "UTC"
      }
    ]
  },
  {
    group: "Manual Offsets",
    zones: [
      {
        value: "UTC-12",
        name: "UTC-12"
      },
      {
        value: "UTC-11",
        name: "UTC-11"
      },
      {
        value: "UTC-10",
        name: "UTC-10"
      },
      {
        value: "UTC-9",
        name: "UTC-9"
      },
      {
        value: "UTC-8",
        name: "UTC-8"
      },
      {
        value: "UTC-7",
        name: "UTC-7"
      },
      {
        value: "UTC-6",
        name: "UTC-6"
      },
      {
        value: "UTC-5",
        name: "UTC-5"
      },
      {
        value: "UTC-4",
        name: "UTC-4"
      },
      {
        value: "UTC-3",
        name: "UTC-3"
      },
      {
        value: "UTC-2",
        name: "UTC-2"
      },
      {
        value: "UTC-1",
        name: "UTC-1"
      },
      {
        value: "UTC+0",
        name: "UTC+0"
      },
      {
        value: "UTC+1",
        name: "UTC+1"
      },
      {
        value: "UTC+2",
        name: "UTC+2"
      },
      {
        value: "UTC+3",
        name: "UTC+3"
      },
      {
        value: "UTC+4",
        name: "UTC+4"
      },
      {
        value: "UTC+5",
        name: "UTC+5"
      },
      {
        value: "UTC+6",
        name: "UTC+6"
      },
      {
        value: "UTC+7",
        name: "UTC+7"
      },
      {
        value: "UTC+8",
        name: "UTC+8"
      },
      {
        value: "UTC+9",
        name: "UTC+9"
      },
      {
        value: "UTC+10",
        name: "UTC+10"
      },
      {
        value: "UTC+11",
        name: "UTC+11"
      },
      {
        value: "UTC+12",
        name: "UTC+12"
      },
      {
        value: "UTC+13",
        name: "UTC+13"
      },
      {
        value: "UTC+14",
        name: "UTC+14"
      }
    ]
  }
], a6 = () => r6.flatMap((e) => e.zones.map((t) => t.value));
a6();
const i6 = () => (e) => (t) => !!t && (Array.isArray(e) ? e.includes(t) : e === t), dE = () => (e) => (t) => Array.isArray(e) ? e.includes(t.type) : t.type === e, Nt = dE();
Nt(se.IF);
Nt(se.URL);
Nt(se.SET);
Nt(se.TEXT);
Nt(se.GOTO);
Nt(se.CARD);
Nt(se.IF_V2);
Nt(se.FLOW);
Nt(se.CODE);
Nt(se.EXIT);
Nt(se.SPEAK);
Nt(se.START);
Nt(se.SET_V2);
Nt(se.VISUAL);
Nt(se.STREAM);
Nt(se.RANDOM);
Nt(se.CARD_V2);
Nt(se.CAPTURE);
Nt(se.GENERAL);
Nt(se.CAROUSEL);
Nt(se.RANDOM_V2);
Nt(se.GOTO_NODE);
Nt(se.DIRECTIVE);
Nt(se.CAPTURE_V2);
Nt(se.INTERACTION);
Nt(se.INTEGRATIONS);
const ut = i6();
ut(se.IF);
ut(se.URL);
ut(se.SET);
ut(se.API);
ut(se.GOTO);
ut(se.TEXT);
ut(se.CARD);
ut(se.IF_V2);
ut(se.FLOW);
ut(se.CODE);
ut(se.EXIT);
ut(se.SPEAK);
ut(se.START);
ut(se.SET_V2);
ut(se.CAROUSEL);
ut(se.PROMPT);
ut(se.VISUAL);
ut(se.INTENT);
ut(se.STREAM);
ut(se.ZAPIER);
ut(se.RANDOM);
ut(se.RANDOM_V2);
ut(se.COMMAND);
ut(se.BUTTONS);
ut(se.CAPTURE);
ut(se.GENERAL);
ut(se.GOTO_NODE);
ut(se.DIRECTIVE);
ut(se.COMPONENT);
ut(se.CAPTURE_V2);
ut(se.GOTO_DOMAIN);
ut(se.DEPRECATED);
ut(se.INTERACTION);
ut(se.INTEGRATIONS);
ut(se.GOOGLE_SHEETS);
const lt = dE();
lt(se.IF);
lt(se.URL);
lt(se.SET);
lt(se.API);
lt(se.TEXT);
lt(se.CARD);
lt(se.CARD_V2);
lt(se.IF_V2);
lt(se.FLOW);
lt(se.GOTO);
lt(se.CODE);
lt(se.EXIT);
lt(se.SPEAK);
lt(se.START);
lt(se.SET_V2);
lt(se.PROMPT);
lt(se.CAROUSEL);
lt(se.VISUAL);
lt(se.INTENT);
lt(se.STREAM);
lt(se.ZAPIER);
lt(se.RANDOM);
lt(se.RANDOM_V2);
lt(se.COMMAND);
lt(se.BUTTONS);
lt(se.CAPTURE);
lt(se.GENERAL);
lt(se.GOTO_NODE);
lt(se.DIRECTIVE);
lt(se.COMPONENT);
lt(se.CAPTURE_V2);
lt(se.GOTO_DOMAIN);
lt(se.DEPRECATED);
lt(se.INTERACTION);
lt(se.GOOGLE_SHEETS);
var mp;
(function(e) {
  e.OFF = "OFF", e.ALL = "ALL", e.DIALOG = "DIALOG";
})(mp || (mp = {}));
var pp;
(function(e) {
  e.RESUME = "resume", e.RESTART = "restart";
})(pp || (pp = {}));
var gp;
(function(e) {
  e.STATIC = "static", e.GENERATIVE = "generative";
})(gp || (gp = {}));
var bp;
(function(e) {
  e.PRODUCTION = "production", e.DEVELOPMENT = "development";
})(bp || (bp = {}));
const s6 = (e) => {
  var t;
  return !!((t = e == null ? void 0 : e.verify) != null && t.authorization);
}, o6 = (e) => {
  var t;
  return typeof ((t = e == null ? void 0 : e.verify) == null ? void 0 : t.projectID) == "string";
}, u6 = Zo;
var hE = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var l6 = c6;
function c6(e) {
  if (!e)
    throw new TypeError("argument namespace is required");
  function t(n) {
  }
  return t._file = void 0, t._ignored = !0, t._namespace = e, t._traced = !1, t._warned = /* @__PURE__ */ Object.create(null), t.function = f6, t.property = d6, t;
}
function f6(e, t) {
  if (typeof e != "function")
    throw new TypeError("argument fn must be a function");
  return e;
}
function d6(e, t, n) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new TypeError("argument obj must be object");
  var r = Object.getOwnPropertyDescriptor(e, t);
  if (!r)
    throw new TypeError("must call property on owner object");
  if (!r.configurable)
    throw new TypeError("property must be configurable");
}
var h6 = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? m6 : p6);
function m6(e, t) {
  return e.__proto__ = t, e;
}
function p6(e, t) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(e, n) || (e[n] = t[n]);
  return e;
}
const g6 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a Teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Too Early",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var pd = g6, b6 = mr;
mr.message = pd;
mr.code = E6(pd);
mr.codes = v6(pd);
mr.redirect = {
  300: !0,
  301: !0,
  302: !0,
  303: !0,
  305: !0,
  307: !0,
  308: !0
};
mr.empty = {
  204: !0,
  205: !0,
  304: !0
};
mr.retry = {
  502: !0,
  503: !0,
  504: !0
};
function E6(e) {
  var t = {};
  return Object.keys(e).forEach(function(r) {
    var a = e[r], i = Number(r);
    t[a.toLowerCase()] = i;
  }), t;
}
function v6(e) {
  return Object.keys(e).map(function(n) {
    return Number(n);
  });
}
function T6(e) {
  var t = e.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(mr.code, t))
    throw new Error('invalid status message: "' + e + '"');
  return mr.code[t];
}
function Ep(e) {
  if (!Object.prototype.hasOwnProperty.call(mr.message, e))
    throw new Error("invalid status code: " + e);
  return mr.message[e];
}
function mr(e) {
  if (typeof e == "number")
    return Ep(e);
  if (typeof e != "string")
    throw new TypeError("code must be a number or string");
  var t = parseInt(e, 10);
  return isNaN(t) ? T6(e) : Ep(t);
}
var _f = { exports: {} };
typeof Object.create == "function" ? _f.exports = function(t, n) {
  n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : _f.exports = function(t, n) {
  if (n) {
    t.super_ = n;
    var r = function() {
    };
    r.prototype = n.prototype, t.prototype = new r(), t.prototype.constructor = t;
  }
};
var A6 = _f.exports;
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var _6 = y6;
function y6(e) {
  return e.split(" ").map(function(t) {
    return t.slice(0, 1).toUpperCase() + t.slice(1);
  }).join("").replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(e) {
  l6("http-errors");
  var t = h6, n = b6, r = A6, a = _6;
  e.exports = s, e.exports.HttpError = o(), e.exports.isHttpError = l(e.exports.HttpError), p(e.exports, n.codes, e.exports.HttpError);
  function i(v) {
    return +(String(v).charAt(0) + "00");
  }
  function s() {
    for (var v, E, y = 500, N = {}, A = 0; A < arguments.length; A++) {
      var I = arguments[A], j = typeof I;
      if (j === "object" && I instanceof Error)
        v = I, y = v.status || v.statusCode || y;
      else if (j === "number" && A === 0)
        y = I;
      else if (j === "string")
        E = I;
      else if (j === "object")
        N = I;
      else
        throw new TypeError("argument #" + (A + 1) + " unsupported type " + j);
    }
    (typeof y != "number" || !n.message[y] && (y < 400 || y >= 600)) && (y = 500);
    var $ = s[y] || s[i(y)];
    v || (v = $ ? new $(E) : new Error(E || n.message[y]), Error.captureStackTrace(v, s)), (!$ || !(v instanceof $) || v.status !== y) && (v.expose = y < 500, v.status = v.statusCode = y);
    for (var _ in N)
      _ !== "status" && _ !== "statusCode" && (v[_] = N[_]);
    return v;
  }
  function o() {
    function v() {
      throw new TypeError("cannot construct abstract class");
    }
    return r(v, Error), v;
  }
  function u(v, E, y) {
    var N = b(E);
    function A(I) {
      var j = I ?? n.message[y], $ = new Error(j);
      return Error.captureStackTrace($, A), t($, A.prototype), Object.defineProperty($, "message", {
        enumerable: !0,
        configurable: !0,
        value: j,
        writable: !0
      }), Object.defineProperty($, "name", {
        enumerable: !1,
        configurable: !0,
        value: N,
        writable: !0
      }), $;
    }
    return r(A, v), h(A, N), A.prototype.status = y, A.prototype.statusCode = y, A.prototype.expose = !0, A;
  }
  function l(v) {
    return function(y) {
      return !y || typeof y != "object" ? !1 : y instanceof v ? !0 : y instanceof Error && typeof y.expose == "boolean" && typeof y.statusCode == "number" && y.status === y.statusCode;
    };
  }
  function f(v, E, y) {
    var N = b(E);
    function A(I) {
      var j = I ?? n.message[y], $ = new Error(j);
      return Error.captureStackTrace($, A), t($, A.prototype), Object.defineProperty($, "message", {
        enumerable: !0,
        configurable: !0,
        value: j,
        writable: !0
      }), Object.defineProperty($, "name", {
        enumerable: !1,
        configurable: !0,
        value: N,
        writable: !0
      }), $;
    }
    return r(A, v), h(A, N), A.prototype.status = y, A.prototype.statusCode = y, A.prototype.expose = !1, A;
  }
  function h(v, E) {
    var y = Object.getOwnPropertyDescriptor(v, "name");
    y && y.configurable && (y.value = E, Object.defineProperty(v, "name", y));
  }
  function p(v, E, y) {
    E.forEach(function(A) {
      var I, j = a(n.message[A]);
      switch (i(A)) {
        case 400:
          I = u(y, j, A);
          break;
        case 500:
          I = f(y, j, A);
          break;
      }
      I && (v[A] = I, v[j] = I);
    });
  }
  function b(v) {
    return v.substr(-5) !== "Error" ? v + "Error" : v;
  }
})(hE);
var S6 = hE.exports;
const C6 = /* @__PURE__ */ Ft(S6);
class mE {
  constructor(t) {
    var n;
    if (this.options = t, this.fetch = t.fetchPonyfill ?? ((n = globalThis.fetch) == null ? void 0 : n.bind(globalThis)), !this.fetch)
      throw new TypeError("fetch implementation was not provided and a global fetch was not available");
  }
  async send(t, n = {}) {
    const r = new URL(t, this.options.url);
    n.params && (r.search = n.params.toString());
    const a = await this.fetch(r, {
      method: n.method ?? "GET",
      body: n.body ? JSON.stringify(n.body) : void 0,
      headers: {
        "content-type": "application/json",
        ...n.headers ?? {}
      }
    }), i = await a.json().catch(() => null);
    if (!a.ok)
      throw C6(a.status, a.statusText, i);
    return i;
  }
}
class O6 extends mE {
  constructor(t) {
    super(t), this.authorization = t.verify.authorization;
  }
  async interact(t) {
    const { action: n, config: r, sessionID: a, versionID: i } = t;
    return this.send(`state/user/${a}/interact`, {
      method: "POST",
      body: { action: n, config: r },
      headers: {
        authorization: this.authorization,
        sessionID: a,
        ...i ? { versionID: i } : {}
      },
      params: new URLSearchParams({ verbose: "true" })
    });
  }
  async feedback() {
    return Promise.reject(new Error("not implemented"));
  }
  // TODO: expose authenticated publishing
  getPublishing() {
    return Promise.reject(new Error("not implemented"));
  }
  // TODO: expose authenticated createTranscript
  createTranscript() {
    return Promise.reject(new Error("not implemented"));
  }
}
class I6 extends mE {
  constructor(t) {
    super(t), this.projectID = t.verify.projectID;
  }
  async interact(t) {
    const { action: n, config: r, sessionID: a, versionID: i } = t;
    return this.send(`public/${this.projectID}/state/user/${a}/interact`, {
      method: "POST",
      body: { action: n, config: r },
      headers: {
        sessionID: a,
        ...i && { versionID: i }
      }
    });
  }
  async feedback(t) {
    const { versionID: n, sessionID: r, ...a } = t;
    await this.send(`feedback/${this.projectID}/user/${r}`, {
      method: "POST",
      body: a,
      headers: {
        sessionID: r,
        ...n && { versionID: n }
      }
    });
  }
  async getPublishing(t) {
    const { versionID: n } = t;
    return this.send(`public/${this.projectID}/publishing`, {
      method: "GET",
      headers: {
        ...n ? { versionID: n } : {}
      }
    });
  }
  async createTranscript(t, n) {
    return this.send(`public/${this.projectID}/transcripts`, {
      method: "POST",
      body: { ...n, sessionID: t }
    });
  }
}
class x6 {
  constructor(t = {}) {
    this.traces = [], this.registerTraces(t.traces ?? []);
  }
  registerTrace(t) {
    return this.traces.push(t), this;
  }
  registerTraces(t) {
    return t.forEach((n) => this.registerTrace(n)), this;
  }
  async processTrace(t, n) {
    const r = { context: t };
    for (const a of n.trace) {
      const i = this.traces.find((s) => s.canHandle(a));
      i && (r.context = await i.handle(r, a));
    }
    return r.context;
  }
}
class N6 {
  constructor(t) {
    if (this.trace = new x6(t), s6(t))
      this.runtime = new O6(t);
    else if (o6(t))
      this.runtime = new I6(t);
    else
      throw new Error("invalid runtime options");
  }
  registerStep(t) {
    return this.trace.registerTrace(t), this;
  }
  async interact(t, n) {
    const r = await this.runtime.interact(n);
    return this.trace.processTrace(t, r);
  }
  async feedback(t) {
    return this.runtime.feedback(t);
  }
  async getPublishing(...t) {
    return this.runtime.getPublishing(...t);
  }
  async createTranscript(...t) {
    return this.runtime.createTranscript(...t);
  }
}
const Ba = (e) => (t) => typeof t == "function" ? {
  canHandle: (n) => n.type === e,
  handle: t
} : t, R6 = Ba(hr.CARD_V2), k6 = Ba(hr.CHOICE);
Ba(hr.END);
Ba(hr.SPEAK);
Ba(hr.STREAM);
const w6 = Ba(hr.TEXT), D6 = Ba(hr.VISUAL);
var vn = /* @__PURE__ */ ((e) => (e.TEXT = "text", e.IMAGE = "image", e.CARD = "card", e.CAROUSEL = "carousel", e.END = "END", e.EXTENSION = "EXTENSION", e))(vn || {});
const Jo = 1e3, P6 = (e) => ({
  canHandle: ({ type: t }) => t === u6.NO_REPLY,
  handle: ({ context: t }, n) => {
    var r;
    if ((r = n.payload) != null && r.timeout) {
      const a = t.messages.reduce(
        (s, o) => s + (o.delay ?? 1e3) + Jo,
        0
      ), i = n.payload.timeout * 1e3 + a;
      e(i);
    }
    return t;
  }
}), L6 = (e) => e.filter((t) => t.type === md.RESPONSE).map((t) => ({
  canHandle: (n) => t.match({ trace: n }),
  handle: ({ context: n }, r) => (n.messages.push({ type: vn.EXTENSION, payload: { trace: r, extension: t } }), n)
})), M6 = (e) => {
  const t = Xn(null), n = ra(() => {
    t.current && (clearTimeout(t.current), t.current = null);
  }, []);
  return { setNoReplyTimeout: ra((a) => {
    n(), t.current = setTimeout(() => {
      e().isStatus(or.ACTIVE) && e().interact({ type: Qn.NO_REPLY, payload: null });
    }, a);
  }, []), clearNoReplyTimeout: n };
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function vp(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function cn(e) {
  var t, n;
  return vp(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(vp(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Ei = {};
function sn(e) {
  for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  if (Ei.NODE_ENV !== "production") {
    var a = V6[e], i = a ? typeof a == "function" ? a.apply(null, n) : a : "unknown error nr: " + e;
    throw Error("[Immer] " + i);
  }
  throw Error("[Immer] minified error nr: " + e + (n.length ? " " + n.map(function(s) {
    return "'" + s + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function Da(e) {
  return !!e && !!e[zn];
}
function Pa(e) {
  return !!e && (function(t) {
    if (!t || typeof t != "object")
      return !1;
    var n = Object.getPrototypeOf(t);
    if (n === null)
      return !0;
    var r = Object.hasOwnProperty.call(n, "constructor") && n.constructor;
    return r === Object || typeof r == "function" && Function.toString.call(r) === G6;
  }(e) || Array.isArray(e) || !!e[Ip] || !!e.constructor[Ip] || gd(e) || bd(e));
}
function ks(e, t, n) {
  n === void 0 && (n = !1), Ii(e) === 0 ? (n ? Object.keys : _d)(e).forEach(function(r) {
    n && typeof r == "symbol" || t(r, e[r], e);
  }) : e.forEach(function(r, a) {
    return t(a, r, e);
  });
}
function Ii(e) {
  var t = e[zn];
  return t ? t.i > 3 ? t.i - 4 : t.i : Array.isArray(e) ? 1 : gd(e) ? 2 : bd(e) ? 3 : 0;
}
function yf(e, t) {
  return Ii(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function $6(e, t) {
  return Ii(e) === 2 ? e.get(t) : e[t];
}
function pE(e, t, n) {
  var r = Ii(e);
  r === 2 ? e.set(t, n) : r === 3 ? (e.delete(t), e.add(n)) : e[t] = n;
}
function B6(e, t) {
  return e === t ? e !== 0 || 1 / e == 1 / t : e != e && t != t;
}
function gd(e) {
  return j6 && e instanceof Map;
}
function bd(e) {
  return z6 && e instanceof Set;
}
function va(e) {
  return e.o || e.t;
}
function Ed(e) {
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  var t = Y6(e);
  delete t[zn];
  for (var n = _d(t), r = 0; r < n.length; r++) {
    var a = n[r], i = t[a];
    i.writable === !1 && (i.writable = !0, i.configurable = !0), (i.get || i.set) && (t[a] = { configurable: !0, writable: !0, enumerable: i.enumerable, value: e[a] });
  }
  return Object.create(Object.getPrototypeOf(e), t);
}
function vd(e, t) {
  return t === void 0 && (t = !1), Td(e) || Da(e) || !Pa(e) || (Ii(e) > 1 && (e.set = e.add = e.clear = e.delete = F6), Object.freeze(e), t && ks(e, function(n, r) {
    return vd(r, !0);
  }, !0)), e;
}
function F6() {
  sn(2);
}
function Td(e) {
  return e == null || typeof e != "object" || Object.isFrozen(e);
}
function yr(e) {
  var t = W6[e];
  return t || sn(18, e), t;
}
function Tp() {
  return Ei.NODE_ENV === "production" || vi || sn(0), vi;
}
function kl(e, t) {
  t && (yr("Patches"), e.u = [], e.s = [], e.v = t);
}
function eu(e) {
  Sf(e), e.p.forEach(U6), e.p = null;
}
function Sf(e) {
  e === vi && (vi = e.l);
}
function Ap(e) {
  return vi = { p: [], l: vi, h: e, m: !0, _: 0 };
}
function U6(e) {
  var t = e[zn];
  t.i === 0 || t.i === 1 ? t.j() : t.O = !0;
}
function wl(e, t) {
  t._ = t.p.length;
  var n = t.p[0], r = e !== void 0 && e !== n;
  return t.h.g || yr("ES5").S(t, e, r), r ? (n[zn].P && (eu(t), sn(4)), Pa(e) && (e = tu(t, e), t.l || nu(t, e)), t.u && yr("Patches").M(n[zn].t, e, t.u, t.s)) : e = tu(t, n, []), eu(t), t.u && t.v(t.u, t.s), e !== gE ? e : void 0;
}
function tu(e, t, n) {
  if (Td(t))
    return t;
  var r = t[zn];
  if (!r)
    return ks(t, function(i, s) {
      return _p(e, r, t, i, s, n);
    }, !0), t;
  if (r.A !== e)
    return t;
  if (!r.P)
    return nu(e, r.t, !0), r.t;
  if (!r.I) {
    r.I = !0, r.A._--;
    var a = r.i === 4 || r.i === 5 ? r.o = Ed(r.k) : r.o;
    ks(r.i === 3 ? new Set(a) : a, function(i, s) {
      return _p(e, r, a, i, s, n);
    }), nu(e, a, !1), n && e.u && yr("Patches").R(r, n, e.u, e.s);
  }
  return r.o;
}
function _p(e, t, n, r, a, i) {
  if (Ei.NODE_ENV !== "production" && a === n && sn(5), Da(a)) {
    var s = tu(e, a, i && t && t.i !== 3 && !yf(t.D, r) ? i.concat(r) : void 0);
    if (pE(n, r, s), !Da(s))
      return;
    e.m = !1;
  }
  if (Pa(a) && !Td(a)) {
    if (!e.h.F && e._ < 1)
      return;
    tu(e, a), t && t.A.l || nu(e, a);
  }
}
function nu(e, t, n) {
  n === void 0 && (n = !1), e.h.F && e.m && vd(t, n);
}
function Dl(e, t) {
  var n = e[zn];
  return (n ? va(n) : e)[t];
}
function yp(e, t) {
  if (t in e)
    for (var n = Object.getPrototypeOf(e); n; ) {
      var r = Object.getOwnPropertyDescriptor(n, t);
      if (r)
        return r;
      n = Object.getPrototypeOf(n);
    }
}
function Cf(e) {
  e.P || (e.P = !0, e.l && Cf(e.l));
}
function Pl(e) {
  e.o || (e.o = Ed(e.t));
}
function Of(e, t, n) {
  var r = gd(t) ? yr("MapSet").N(t, n) : bd(t) ? yr("MapSet").T(t, n) : e.g ? function(a, i) {
    var s = Array.isArray(a), o = { i: s ? 1 : 0, A: i ? i.A : Tp(), P: !1, I: !1, D: {}, l: i, t: a, k: null, o: null, j: null, C: !1 }, u = o, l = If;
    s && (u = [o], l = Qi);
    var f = Proxy.revocable(u, l), h = f.revoke, p = f.proxy;
    return o.k = p, o.j = h, p;
  }(t, n) : yr("ES5").J(t, n);
  return (n ? n.A : Tp()).p.push(r), r;
}
function H6(e) {
  return Da(e) || sn(22, e), function t(n) {
    if (!Pa(n))
      return n;
    var r, a = n[zn], i = Ii(n);
    if (a) {
      if (!a.P && (a.i < 4 || !yr("ES5").K(a)))
        return a.t;
      a.I = !0, r = Sp(n, i), a.I = !1;
    } else
      r = Sp(n, i);
    return ks(r, function(s, o) {
      a && $6(a.t, s) === o || pE(r, s, t(o));
    }), i === 3 ? new Set(r) : r;
  }(e);
}
function Sp(e, t) {
  switch (t) {
    case 2:
      return new Map(e);
    case 3:
      return Array.from(e);
  }
  return Ed(e);
}
var Cp, vi, Ad = typeof Symbol < "u" && typeof Symbol("x") == "symbol", j6 = typeof Map < "u", z6 = typeof Set < "u", Op = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", gE = Ad ? Symbol.for("immer-nothing") : ((Cp = {})["immer-nothing"] = !0, Cp), Ip = Ad ? Symbol.for("immer-draftable") : "__$immer_draftable", zn = Ad ? Symbol.for("immer-state") : "__$immer_state", V6 = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(e) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(e) {
  return "Cannot apply patch, path doesn't resolve: " + e;
}, 16: 'Sets cannot have "replace" patches.', 17: function(e) {
  return "Unsupported patch operation: " + e;
}, 18: function(e) {
  return "The plugin for '" + e + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + e + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(e) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + e + "'";
}, 22: function(e) {
  return "'current' expects a draft, got: " + e;
}, 23: function(e) {
  return "'original' expects a draft, got: " + e;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" }, G6 = "" + Object.prototype.constructor, _d = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Object.getOwnPropertyNames, Y6 = Object.getOwnPropertyDescriptors || function(e) {
  var t = {};
  return _d(e).forEach(function(n) {
    t[n] = Object.getOwnPropertyDescriptor(e, n);
  }), t;
}, W6 = {}, If = { get: function(e, t) {
  if (t === zn)
    return e;
  var n = va(e);
  if (!yf(n, t))
    return function(a, i, s) {
      var o, u = yp(i, s);
      return u ? "value" in u ? u.value : (o = u.get) === null || o === void 0 ? void 0 : o.call(a.k) : void 0;
    }(e, n, t);
  var r = n[t];
  return e.I || !Pa(r) ? r : r === Dl(e.t, t) ? (Pl(e), e.o[t] = Of(e.A.h, r, e)) : r;
}, has: function(e, t) {
  return t in va(e);
}, ownKeys: function(e) {
  return Reflect.ownKeys(va(e));
}, set: function(e, t, n) {
  var r = yp(va(e), t);
  if (r != null && r.set)
    return r.set.call(e.k, n), !0;
  if (!e.P) {
    var a = Dl(va(e), t), i = a == null ? void 0 : a[zn];
    if (i && i.t === n)
      return e.o[t] = n, e.D[t] = !1, !0;
    if (B6(n, a) && (n !== void 0 || yf(e.t, t)))
      return !0;
    Pl(e), Cf(e);
  }
  return e.o[t] === n && typeof n != "number" && (n !== void 0 || t in e.o) || (e.o[t] = n, e.D[t] = !0, !0);
}, deleteProperty: function(e, t) {
  return Dl(e.t, t) !== void 0 || t in e.t ? (e.D[t] = !1, Pl(e), Cf(e)) : delete e.D[t], e.o && delete e.o[t], !0;
}, getOwnPropertyDescriptor: function(e, t) {
  var n = va(e), r = Reflect.getOwnPropertyDescriptor(n, t);
  return r && { writable: !0, configurable: e.i !== 1 || t !== "length", enumerable: r.enumerable, value: n[t] };
}, defineProperty: function() {
  sn(11);
}, getPrototypeOf: function(e) {
  return Object.getPrototypeOf(e.t);
}, setPrototypeOf: function() {
  sn(12);
} }, Qi = {};
ks(If, function(e, t) {
  Qi[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
}), Qi.deleteProperty = function(e, t) {
  return Ei.NODE_ENV !== "production" && isNaN(parseInt(t)) && sn(13), Qi.set.call(this, e, t, void 0);
}, Qi.set = function(e, t, n) {
  return Ei.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && sn(14), If.set.call(this, e[0], t, n, e[0]);
};
var q6 = function() {
  function e(n) {
    var r = this;
    this.g = Op, this.F = !0, this.produce = function(a, i, s) {
      if (typeof a == "function" && typeof i != "function") {
        var o = i;
        i = a;
        var u = r;
        return function(E) {
          var y = this;
          E === void 0 && (E = o);
          for (var N = arguments.length, A = Array(N > 1 ? N - 1 : 0), I = 1; I < N; I++)
            A[I - 1] = arguments[I];
          return u.produce(E, function(j) {
            var $;
            return ($ = i).call.apply($, [y, j].concat(A));
          });
        };
      }
      var l;
      if (typeof i != "function" && sn(6), s !== void 0 && typeof s != "function" && sn(7), Pa(a)) {
        var f = Ap(r), h = Of(r, a, void 0), p = !0;
        try {
          l = i(h), p = !1;
        } finally {
          p ? eu(f) : Sf(f);
        }
        return typeof Promise < "u" && l instanceof Promise ? l.then(function(E) {
          return kl(f, s), wl(E, f);
        }, function(E) {
          throw eu(f), E;
        }) : (kl(f, s), wl(l, f));
      }
      if (!a || typeof a != "object") {
        if ((l = i(a)) === void 0 && (l = a), l === gE && (l = void 0), r.F && vd(l, !0), s) {
          var b = [], v = [];
          yr("Patches").M(a, l, b, v), s(b, v);
        }
        return l;
      }
      sn(21, a);
    }, this.produceWithPatches = function(a, i) {
      if (typeof a == "function")
        return function(l) {
          for (var f = arguments.length, h = Array(f > 1 ? f - 1 : 0), p = 1; p < f; p++)
            h[p - 1] = arguments[p];
          return r.produceWithPatches(l, function(b) {
            return a.apply(void 0, [b].concat(h));
          });
        };
      var s, o, u = r.produce(a, i, function(l, f) {
        s = l, o = f;
      });
      return typeof Promise < "u" && u instanceof Promise ? u.then(function(l) {
        return [l, s, o];
      }) : [u, s, o];
    }, typeof (n == null ? void 0 : n.useProxies) == "boolean" && this.setUseProxies(n.useProxies), typeof (n == null ? void 0 : n.autoFreeze) == "boolean" && this.setAutoFreeze(n.autoFreeze);
  }
  var t = e.prototype;
  return t.createDraft = function(n) {
    Pa(n) || sn(8), Da(n) && (n = H6(n));
    var r = Ap(this), a = Of(this, n, void 0);
    return a[zn].C = !0, Sf(r), a;
  }, t.finishDraft = function(n, r) {
    var a = n && n[zn];
    Ei.NODE_ENV !== "production" && (a && a.C || sn(9), a.I && sn(10));
    var i = a.A;
    return kl(i, r), wl(void 0, i);
  }, t.setAutoFreeze = function(n) {
    this.F = n;
  }, t.setUseProxies = function(n) {
    n && !Op && sn(20), this.g = n;
  }, t.applyPatches = function(n, r) {
    var a;
    for (a = r.length - 1; a >= 0; a--) {
      var i = r[a];
      if (i.path.length === 0 && i.op === "replace") {
        n = i.value;
        break;
      }
    }
    a > -1 && (r = r.slice(a + 1));
    var s = yr("Patches").$;
    return Da(n) ? s(n, r) : this.produce(n, function(o) {
      return s(o, r);
    });
  }, e;
}(), Vn = new q6(), yd = Vn.produce;
Vn.produceWithPatches.bind(Vn);
Vn.setAutoFreeze.bind(Vn);
Vn.setUseProxies.bind(Vn);
Vn.applyPatches.bind(Vn);
var xp = Vn.createDraft.bind(Vn), Np = Vn.finishDraft.bind(Vn), he = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = he.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var a = e[r], i = t[r];
      if (a !== i)
        break;
      n.push(a);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r])
        return -1;
      if (e[r] > t[r])
        return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), a = t.slice(0, n), i = e[n], s = t[n];
    return he.equals(r, a) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), a = t.slice(0, n);
    return he.equals(r, a);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), a = t.slice(0, n), i = e[n], s = t[n];
    return he.equals(r, a) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return he.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && he.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return he.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && he.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && he.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && he.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && he.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), a = e[e.length - 1], i = t[t.length - 1];
    return a !== i && he.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], a = 0; a <= e.length; a++)
      r.push(e.slice(0, a));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!he.isAncestor(t, e) && !he.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e)
      return null;
    var r = [...e], {
      affinity: a = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (he.equals(i, r) || he.endsBefore(i, r) || he.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (he.equals(s, r) || he.isAncestor(s, r))
          return null;
        he.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: o,
          position: u
        } = t;
        he.equals(o, r) || he.endsBefore(o, r) ? r[o.length - 1] -= 1 : he.isAncestor(o, r) && (r[o.length - 1] -= 1, r[o.length] += u);
        break;
      }
      case "split_node": {
        var {
          path: l,
          position: f
        } = t;
        if (he.equals(l, r)) {
          if (a === "forward")
            r[r.length - 1] += 1;
          else if (a !== "backward")
            return null;
        } else
          he.endsBefore(l, r) ? r[l.length - 1] += 1 : he.isAncestor(l, r) && e[l.length] >= f && (r[l.length - 1] += 1, r[l.length] -= f);
        break;
      }
      case "move_node": {
        var {
          path: h,
          newPath: p
        } = t;
        if (he.equals(h, p))
          return r;
        if (he.isAncestor(h, r) || he.equals(h, r)) {
          var b = p.slice();
          return he.endsBefore(h, p) && h.length < p.length && (b[h.length - 1] -= 1), b.concat(r.slice(h.length));
        } else
          he.isSibling(h, p) && (he.isAncestor(p, r) || he.equals(p, r)) ? he.endsBefore(h, r) ? r[h.length - 1] -= 1 : r[h.length - 1] += 1 : he.endsBefore(p, r) || he.equals(p, r) || he.isAncestor(p, r) ? (he.endsBefore(h, r) && (r[h.length - 1] -= 1), r[p.length - 1] += 1) : he.endsBefore(h, r) && (he.equals(p, r) && (r[p.length - 1] += 1), r[h.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function xi(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Rp(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rp(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rp(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K6 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: a
      } = n, i = He.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, a), t)
        for (var [o, u] of ot.points(t))
          t[u] = kt.transform(o, n);
      break;
    }
    case "insert_text": {
      var {
        path: l,
        offset: f,
        text: h
      } = n;
      if (h.length === 0)
        break;
      var p = He.leaf(e, l), b = p.text.slice(0, f), v = p.text.slice(f);
      if (p.text = b + h + v, t)
        for (var [E, y] of ot.points(t))
          t[y] = kt.transform(E, n);
      break;
    }
    case "merge_node": {
      var {
        path: N
      } = n, A = He.get(e, N), I = he.previous(N), j = He.get(e, I), $ = He.parent(e, N), _ = N[N.length - 1];
      if ($t.isText(A) && $t.isText(j))
        j.text += A.text;
      else if (!$t.isText(A) && !$t.isText(j))
        j.children.push(...A.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(N, "] to nodes of different interfaces: ").concat(Tr.stringify(A), " ").concat(Tr.stringify(j)));
      if ($.children.splice(_, 1), t)
        for (var [M, V] of ot.points(t))
          t[V] = kt.transform(M, n);
      break;
    }
    case "move_node": {
      var {
        path: G,
        newPath: O
      } = n;
      if (he.isAncestor(G, O))
        throw new Error("Cannot move a path [".concat(G, "] to new path [").concat(O, "] because the destination is inside itself."));
      var Q = He.get(e, G), ee = He.parent(e, G), H = G[G.length - 1];
      ee.children.splice(H, 1);
      var D = he.transform(G, n), R = He.get(e, he.parent(D)), Y = D[D.length - 1];
      if (R.children.splice(Y, 0, Q), t)
        for (var [P, Z] of ot.points(t))
          t[Z] = kt.transform(P, n);
      break;
    }
    case "remove_node": {
      var {
        path: W
      } = n, C = W[W.length - 1], pe = He.parent(e, W);
      if (pe.children.splice(C, 1), t)
        for (var [me, w] of ot.points(t)) {
          var Ne = kt.transform(me, n);
          if (t != null && Ne != null)
            t[w] = Ne;
          else {
            var Re = void 0, De = void 0;
            for (var [Qe, Ue] of He.texts(e))
              if (he.compare(Ue, W) === -1)
                Re = [Qe, Ue];
              else {
                De = [Qe, Ue];
                break;
              }
            var Ae = !1;
            Re && De && (he.equals(De[1], W) ? Ae = !he.hasPrevious(De[1]) : Ae = he.common(Re[1], W).length < he.common(De[1], W).length), Re && !Ae ? (me.path = Re[1], me.offset = Re[0].text.length) : De ? (me.path = De[1], me.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: Me,
        offset: it,
        text: pt
      } = n;
      if (pt.length === 0)
        break;
      var Kt = He.leaf(e, Me), Xt = Kt.text.slice(0, it), un = Kt.text.slice(it + pt.length);
      if (Kt.text = Xt + un, t)
        for (var [wn, br] of ot.points(t))
          t[br] = kt.transform(wn, n);
      break;
    }
    case "set_node": {
      var {
        path: Gn,
        properties: Nr,
        newProperties: Dn
      } = n;
      if (Gn.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Er = He.get(e, Gn);
      for (var Pn in Dn) {
        if (Pn === "children" || Pn === "text")
          throw new Error('Cannot set the "'.concat(Pn, '" property of nodes!'));
        var er = Dn[Pn];
        er == null ? delete Er[Pn] : Er[Pn] = er;
      }
      for (var Rr in Nr)
        Dn.hasOwnProperty(Rr) || delete Er[Rr];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ne
      } = n;
      if (ne == null)
        t = ne;
      else {
        if (t == null) {
          if (!ot.isRange(ne))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Tr.stringify(ne), " when there is no current selection."));
          t = qi({}, ne);
        }
        for (var be in ne) {
          var ke = ne[be];
          if (ke == null) {
            if (be === "anchor" || be === "focus")
              throw new Error('Cannot remove the "'.concat(be, '" selection property'));
            delete t[be];
          } else
            t[be] = ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Pe,
        position: Je,
        properties: Vt
      } = n;
      if (Pe.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Pe, "] because the root node cannot be split."));
      var Gt = He.get(e, Pe), tn = He.parent(e, Pe), Yn = Pe[Pe.length - 1], Cn;
      if ($t.isText(Gt)) {
        var qt = Gt.text.slice(0, Je), Wn = Gt.text.slice(Je);
        Gt.text = qt, Cn = qi(qi({}, Vt), {}, {
          text: Wn
        });
      } else {
        var ln = Gt.children.slice(0, Je), Ga = Gt.children.slice(Je);
        Gt.children = ln, Cn = qi(qi({}, Vt), {}, {
          children: Ga
        });
      }
      if (tn.children.splice(Yn + 1, 0, Cn), t)
        for (var [Mi, ha] of ot.points(t))
          t[ha] = kt.transform(Mi, n);
      break;
    }
  }
  return t;
}, X6 = {
  transform(e, t) {
    e.children = xp(e.children);
    var n = e.selection && xp(e.selection);
    try {
      n = K6(e, n, t);
    } finally {
      e.children = Np(e.children), n ? e.selection = Da(n) ? Np(n) : n : e.selection = null;
    }
  }
}, Z6 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Q6 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, bE = (e, t) => {
  for (var n in e) {
    var r = e[n], a = t[n];
    if (cn(r) && cn(a)) {
      if (!bE(r, a))
        return !1;
    } else if (Array.isArray(r) && Array.isArray(a)) {
      if (r.length !== a.length)
        return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== a[i])
          return !1;
    } else if (r !== a)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function J6(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function ws(e, t) {
  if (e == null)
    return {};
  var n = J6(e, t), r, a;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (a = 0; a < i.length; a++)
      r = i[a], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var eL = ["anchor", "focus"];
function kp(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kp(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kp(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ot = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: a
    } = e;
    return ot.isBackward(e) === n ? [r, a] : [a, r];
  },
  end(e) {
    var [, t] = ot.edges(e);
    return t;
  },
  equals(e, t) {
    return kt.equals(e.anchor, t.anchor) && kt.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ot.isRange(t)) {
      if (ot.includes(e, t.anchor) || ot.includes(e, t.focus))
        return !0;
      var [n, r] = ot.edges(e), [a, i] = ot.edges(t);
      return kt.isBefore(n, a) && kt.isAfter(r, i);
    }
    var [s, o] = ot.edges(e), u = !1, l = !1;
    return kt.isPoint(t) ? (u = kt.compare(t, s) >= 0, l = kt.compare(t, o) <= 0) : (u = he.compare(t, s.path) >= 0, l = he.compare(t, o.path) <= 0), u && l;
  },
  intersection(e, t) {
    var n = ws(e, eL), [r, a] = ot.edges(e), [i, s] = ot.edges(t), o = kt.isBefore(r, i) ? i : r, u = kt.isBefore(a, s) ? a : s;
    return kt.isBefore(u, o) ? null : tL({
      anchor: o,
      focus: u
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return kt.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return kt.equals(t, n);
  },
  isExpanded(e) {
    return !ot.isCollapsed(e);
  },
  isForward(e) {
    return !ot.isBackward(e);
  },
  isRange(e) {
    return cn(e) && kt.isPoint(e.anchor) && kt.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ot.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return yd(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: a = "inward"
      } = n, i, s;
      if (a === "inward") {
        var o = ot.isCollapsed(r);
        ot.isForward(r) ? (i = "forward", s = o ? i : "backward") : (i = "backward", s = o ? i : "forward");
      } else
        a === "outward" ? ot.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = a, s = a);
      var u = kt.transform(r.anchor, t, {
        affinity: i
      }), l = kt.transform(r.focus, t, {
        affinity: s
      });
      if (!u || !l)
        return null;
      r.anchor = u, r.focus = l;
    });
  }
}, wp = (e) => cn(e) && He.isNodeList(e.children) && !qn.isEditor(e), Lr = {
  isAncestor(e) {
    return cn(e) && He.isNodeList(e.children);
  },
  isElement: wp,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Lr.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return wp(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, nL = ["children"], rL = ["text"], Dp = /* @__PURE__ */ new WeakMap(), He = {
  ancestor(e, t) {
    var n = He.get(e, t);
    if ($t.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Tr.stringify(n)));
    return n;
  },
  *ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var r of he.ancestors(t, n)) {
      var a = He.ancestor(e, r), i = [a, r];
      yield i;
    }
  },
  child(e, t) {
    if ($t.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Tr.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Tr.stringify(e)));
    return n;
  },
  *children(e, t) {
    for (var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      reverse: r = !1
    } = n, a = He.ancestor(e, t), {
      children: i
    } = a, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
      var o = He.child(a, s), u = t.concat(s);
      yield [o, u], s = r ? s - 1 : s + 1;
    }
  },
  common(e, t, n) {
    var r = he.common(t, n), a = He.get(e, r);
    return [a, r];
  },
  descendant(e, t) {
    var n = He.get(e, t);
    if (qn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Tr.stringify(n)));
    return n;
  },
  *descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [n, r] of He.nodes(e, t))
      r.length !== 0 && (yield [n, r]);
  },
  *elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [n, r] of He.nodes(e, t))
      Lr.isElement(n) && (yield [n, r]);
  },
  extractProps(e) {
    if (Lr.isAncestor(e)) {
      var t = ws(e, nL);
      return t;
    } else {
      var t = ws(e, rL);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = He.get(e, n); r && !($t.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if ($t.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Tr.stringify(e)));
    var n = yd({
      children: e.children
    }, (r) => {
      var [a, i] = ot.edges(t), s = He.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, b] = p;
          return !ot.includes(t, b);
        }
      });
      for (var [, o] of s) {
        if (!ot.includes(t, o)) {
          var u = He.parent(r, o), l = o[o.length - 1];
          u.children.splice(l, 1);
        }
        if (he.equals(o, i.path)) {
          var f = He.leaf(r, o);
          f.text = f.text.slice(0, i.offset);
        }
        if (he.equals(o, a.path)) {
          var h = He.leaf(r, o);
          h.text = h.text.slice(a.offset);
        }
      }
      qn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var a = t[r];
      if ($t.isText(n) || !n.children[a])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Tr.stringify(e)));
      n = n.children[a];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var a = t[r];
      if ($t.isText(n) || !n.children[a])
        return !1;
      n = n.children[a];
    }
    return !0;
  },
  isNode(e) {
    return $t.isText(e) || Lr.isElement(e) || qn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Dp.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => He.isNode(r));
    return Dp.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = He.get(e, n); r && !($t.isText(r) || r.children.length === 0); ) {
      var a = r.children.length - 1;
      r = r.children[a], n.push(a);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = He.get(e, t);
    if (!$t.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Tr.stringify(n)));
    return n;
  },
  *levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var r of he.levels(t, n)) {
      var a = He.get(e, r);
      yield [a, r];
    }
  },
  matches(e, t) {
    return Lr.isElement(e) && Lr.isElementProps(t) && Lr.matches(e, t) || $t.isText(e) && $t.isTextProps(t) && $t.matches(e, t);
  },
  *nodes(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      pass: n,
      reverse: r = !1
    } = t, {
      from: a = [],
      to: i
    } = t, s = /* @__PURE__ */ new Set(), o = [], u = e; !(i && (r ? he.isBefore(o, i) : he.isAfter(o, i))); ) {
      if (s.has(u) || (yield [u, o]), !s.has(u) && !$t.isText(u) && u.children.length !== 0 && (n == null || n([u, o]) === !1)) {
        s.add(u);
        var l = r ? u.children.length - 1 : 0;
        he.isAncestor(o, a) && (l = a[o.length]), o = o.concat(l), u = He.get(e, o);
        continue;
      }
      if (o.length === 0)
        break;
      if (!r) {
        var f = he.next(o);
        if (He.has(e, f)) {
          o = f, u = He.get(e, o);
          continue;
        }
      }
      if (r && o[o.length - 1] !== 0) {
        var h = he.previous(o);
        o = h, u = He.get(e, o);
        continue;
      }
      o = he.parent(o), u = He.get(e, o), s.add(u);
    }
  },
  parent(e, t) {
    var n = he.parent(t), r = He.get(e, n);
    if ($t.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return $t.isText(e) ? e.text : e.children.map(He.string).join("");
  },
  *texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [n, r] of He.nodes(e, t))
      $t.isText(n) && (yield [n, r]);
  }
};
function Pp(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Pp(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Pp(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ji = {
  isNodeOperation(e) {
    return Ji.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!cn(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return he.isPath(e.path) && He.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && he.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && he.isPath(e.path) && cn(e.properties);
      case "move_node":
        return he.isPath(e.path) && he.isPath(e.newPath);
      case "remove_node":
        return he.isPath(e.path) && He.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && he.isPath(e.path);
      case "set_node":
        return he.isPath(e.path) && cn(e.properties) && cn(e.newProperties);
      case "set_selection":
        return e.properties === null && ot.isRange(e.newProperties) || e.newProperties === null && ot.isRange(e.properties) || cn(e.properties) && cn(e.newProperties);
      case "split_node":
        return he.isPath(e.path) && typeof e.position == "number" && cn(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Ji.isOperation(t));
  },
  isSelectionOperation(e) {
    return Ji.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Ji.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Pt(Pt({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Pt(Pt({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Pt(Pt({}, e), {}, {
          type: "split_node",
          path: he.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (he.equals(t, n))
          return e;
        if (he.isSibling(n, t))
          return Pt(Pt({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = he.transform(n, e), a = he.transform(he.next(n), e);
        return Pt(Pt({}, e), {}, {
          path: r,
          newPath: a
        });
      }
      case "remove_node":
        return Pt(Pt({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Pt(Pt({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Pt(Pt({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: o,
          newProperties: u
        } = e;
        return o == null ? Pt(Pt({}, e), {}, {
          properties: u,
          newProperties: null
        }) : u == null ? Pt(Pt({}, e), {}, {
          properties: null,
          newProperties: o
        }) : Pt(Pt({}, e), {}, {
          properties: u,
          newProperties: o
        });
      }
      case "split_node":
        return Pt(Pt({}, e), {}, {
          type: "merge_node",
          path: he.next(e.path)
        });
    }
  }
}, Lp = /* @__PURE__ */ new WeakMap(), aL = (e) => {
  var t = Lp.get(e);
  if (t !== void 0)
    return t;
  if (!cn(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || cn(e.marks)) && (e.selection === null || ot.isRange(e.selection)) && He.isNodeList(e.children) && Ji.isOperationList(e.operations);
  return Lp.set(e, n), n;
}, qn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return aL(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  }
};
function Mp(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $p(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Mp(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Mp(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kt = {
  compare(e, t) {
    var n = he.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return kt.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return kt.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && he.equals(e.path, t.path);
  },
  isPoint(e) {
    return cn(e) && typeof e.offset == "number" && he.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return yd(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: a = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = he.transform(i, t, n);
          break;
        }
        case "insert_text": {
          he.equals(t.path, i) && (t.offset < s || t.offset === s && a === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          he.equals(t.path, i) && (r.offset += t.position), r.path = he.transform(i, t, n);
          break;
        }
        case "remove_text": {
          he.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (he.equals(t.path, i) || he.isAncestor(t.path, i))
            return null;
          r.path = he.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (he.equals(t.path, i)) {
            if (t.position === s && a == null)
              return null;
            (t.position < s || t.position === s && a === "forward") && (r.offset -= t.position, r.path = he.transform(i, t, $p($p({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = he.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Bp = void 0, Tr = {
  setScrubber(e) {
    Bp = e;
  },
  stringify(e) {
    return JSON.stringify(e, Bp);
  }
}, iL = ["text"], sL = ["anchor", "focus"];
function Fp(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Fp(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fp(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $t = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function a(i) {
      var s = ws(i, iL);
      return s;
    }
    return bE(r ? a(e) : e, r ? a(t) : t);
  },
  isText(e) {
    return cn(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => $t.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Pr({}, e)];
    for (var r of t) {
      var a = ws(r, sL), [i, s] = ot.edges(r), o = [], u = 0, l = i.offset, f = s.offset;
      for (var h of n) {
        var {
          length: p
        } = h.text, b = u;
        if (u += p, l <= b && u <= f) {
          Object.assign(h, a), o.push(h);
          continue;
        }
        if (l !== f && (l === u || f === b) || l > u || f < b || f === b && b !== 0) {
          o.push(h);
          continue;
        }
        var v = h, E = void 0, y = void 0;
        if (f < u) {
          var N = f - b;
          y = Pr(Pr({}, v), {}, {
            text: v.text.slice(N)
          }), v = Pr(Pr({}, v), {}, {
            text: v.text.slice(0, N)
          });
        }
        if (l > b) {
          var A = l - b;
          E = Pr(Pr({}, v), {}, {
            text: v.text.slice(0, A)
          }), v = Pr(Pr({}, v), {}, {
            text: v.text.slice(A)
          });
        }
        Object.assign(v, a), E && o.push(E), o.push(v), y && o.push(y);
      }
      n = o;
    }
    return n;
  }
}, oL = (e) => e.selection ? e.selection : e.children.length > 0 ? qn.end(e, []) : [0], Rt;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Rt || (Rt = {}));
Rt.L, Rt.L | Rt.V | Rt.LV | Rt.LVT, Rt.LV | Rt.V, Rt.V | Rt.T, Rt.LVT | Rt.T, Rt.T, Rt.Any, Rt.Extend | Rt.ZWJ, Rt.Any, Rt.SpacingMark, Rt.Prepend, Rt.Any, Rt.ZWJ, Rt.ExtPict, Rt.RI, Rt.RI;
var uL = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    qn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: a = oL(e)
      } = n;
      if (he.isPath(a) && (a = qn.range(e, a)), ot.isRange(a))
        if (ot.isCollapsed(a))
          a = a.anchor;
        else {
          var i = ot.end(a);
          if (!r && qn.void(e, {
            at: i
          }))
            return;
          var s = ot.start(a), o = qn.pointRef(e, s), u = qn.pointRef(e, i);
          Hp.delete(e, {
            at: a,
            voids: r
          });
          var l = o.unref(), f = u.unref();
          a = l || f, Hp.setSelection(e, {
            anchor: a,
            focus: a
          });
        }
      if (!(!r && qn.void(e, {
        at: a
      }) || qn.elementReadOnly(e, {
        at: a
      }))) {
        var {
          path: h,
          offset: p
        } = a;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: h,
          offset: p,
          text: t
        });
      }
    });
  }
};
function Up(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Up(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Up(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Hp = fo(fo(fo(fo({}, X6), Z6), Q6), uL);
const EE = (e) => e.type === Na.LINK, vE = (e) => e.type === Na.VARIABLE, lL = (e, t) => Lr.isElement(e) ? EE(e) && t.markdownLinks ? `[${AE(e.children)}](${e.url})` : vE(e) && t.encodeVariables ? `{${e.name}}` : TE(e.children, t).join("") : He.string(e), TE = (e, t) => e.map((n) => lL(n, t)), AE = (e, { encodeVariables: t = !0, markdownLinks: n = !1 } = {}) => TE(e, { encodeVariables: t, markdownLinks: n }).join(`
`).trim(), cL = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, _E = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, jt = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, En = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, Xr = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class oe {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(t, n) {
    const r = n.match(t);
    return r && r.length > 0 && r[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(t, n) {
    const r = n.match(t);
    return r && r.length > 1 && r[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(t, n, r) {
    if (t.test(n))
      return r;
  }
  static getWindowsVersionName(t) {
    switch (t) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(t) {
    const n = t.split(".").splice(0, 2).map((r) => parseInt(r, 10) || 0);
    if (n.push(0), n[0] === 10)
      switch (n[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(t) {
    const n = t.split(".").splice(0, 2).map((r) => parseInt(r, 10) || 0);
    if (n.push(0), !(n[0] === 1 && n[1] < 5)) {
      if (n[0] === 1 && n[1] < 6)
        return "Cupcake";
      if (n[0] === 1 && n[1] >= 6)
        return "Donut";
      if (n[0] === 2 && n[1] < 2)
        return "Eclair";
      if (n[0] === 2 && n[1] === 2)
        return "Froyo";
      if (n[0] === 2 && n[1] > 2)
        return "Gingerbread";
      if (n[0] === 3)
        return "Honeycomb";
      if (n[0] === 4 && n[1] < 1)
        return "Ice Cream Sandwich";
      if (n[0] === 4 && n[1] < 4)
        return "Jelly Bean";
      if (n[0] === 4 && n[1] >= 4)
        return "KitKat";
      if (n[0] === 5)
        return "Lollipop";
      if (n[0] === 6)
        return "Marshmallow";
      if (n[0] === 7)
        return "Nougat";
      if (n[0] === 8)
        return "Oreo";
      if (n[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(t) {
    return t.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(t, n, r = !1) {
    const a = oe.getVersionPrecision(t), i = oe.getVersionPrecision(n);
    let s = Math.max(a, i), o = 0;
    const u = oe.map([t, n], (l) => {
      const f = s - oe.getVersionPrecision(l), h = l + new Array(f + 1).join(".0");
      return oe.map(h.split("."), (p) => new Array(20 - p.length).join("0") + p).reverse();
    });
    for (r && (o = s - Math.min(a, i)), s -= 1; s >= o; ) {
      if (u[0][s] > u[1][s])
        return 1;
      if (u[0][s] === u[1][s]) {
        if (s === o)
          return 0;
        s -= 1;
      } else if (u[0][s] < u[1][s])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(t, n) {
    const r = [];
    let a;
    if (Array.prototype.map)
      return Array.prototype.map.call(t, n);
    for (a = 0; a < t.length; a += 1)
      r.push(n(t[a]));
    return r;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(t, n) {
    let r, a;
    if (Array.prototype.find)
      return Array.prototype.find.call(t, n);
    for (r = 0, a = t.length; r < a; r += 1) {
      const i = t[r];
      if (n(i, r))
        return i;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(t, ...n) {
    const r = t;
    let a, i;
    if (Object.assign)
      return Object.assign(t, ...n);
    for (a = 0, i = n.length; a < i; a += 1) {
      const s = n[a];
      typeof s == "object" && s !== null && Object.keys(s).forEach((u) => {
        r[u] = s[u];
      });
    }
    return t;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(t) {
    return cL[t];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(t) {
    return _E[t] || "";
  }
}
const St = /version\/(\d+(\.?_?\d+)+)/i, fL = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(e) {
      const t = {
        name: "Googlebot"
      }, n = oe.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(e) {
      const t = {
        name: "Opera"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(e) {
      const t = {
        name: "Opera"
      }, n = oe.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(e) {
      const t = {
        name: "Samsung Internet for Android"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/Whale/i],
    describe(e) {
      const t = {
        name: "NAVER Whale Browser"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(e) {
      const t = {
        name: "MZ Browser"
      }, n = oe.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/focus/i],
    describe(e) {
      const t = {
        name: "Focus"
      }, n = oe.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/swing/i],
    describe(e) {
      const t = {
        name: "Swing"
      }, n = oe.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/coast/i],
    describe(e) {
      const t = {
        name: "Opera Coast"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(e) {
      const t = {
        name: "Opera Touch"
      }, n = oe.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/yabrowser/i],
    describe(e) {
      const t = {
        name: "Yandex Browser"
      }, n = oe.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(e) {
      const t = {
        name: "UC Browser"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(e) {
      const t = {
        name: "Maxthon"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/epiphany/i],
    describe(e) {
      const t = {
        name: "Epiphany"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/puffin/i],
    describe(e) {
      const t = {
        name: "Puffin"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/sleipnir/i],
    describe(e) {
      const t = {
        name: "Sleipnir"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/k-meleon/i],
    describe(e) {
      const t = {
        name: "K-Meleon"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/micromessenger/i],
    describe(e) {
      const t = {
        name: "WeChat"
      }, n = oe.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(e) {
      const t = {
        name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
      }, n = oe.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/msie|trident/i],
    describe(e) {
      const t = {
        name: "Internet Explorer"
      }, n = oe.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/\sedg\//i],
    describe(e) {
      const t = {
        name: "Microsoft Edge"
      }, n = oe.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(e) {
      const t = {
        name: "Microsoft Edge"
      }, n = oe.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/vivaldi/i],
    describe(e) {
      const t = {
        name: "Vivaldi"
      }, n = oe.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/seamonkey/i],
    describe(e) {
      const t = {
        name: "SeaMonkey"
      }, n = oe.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/sailfish/i],
    describe(e) {
      const t = {
        name: "Sailfish"
      }, n = oe.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/silk/i],
    describe(e) {
      const t = {
        name: "Amazon Silk"
      }, n = oe.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/phantom/i],
    describe(e) {
      const t = {
        name: "PhantomJS"
      }, n = oe.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/slimerjs/i],
    describe(e) {
      const t = {
        name: "SlimerJS"
      }, n = oe.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(e) {
      const t = {
        name: "BlackBerry"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(e) {
      const t = {
        name: "WebOS Browser"
      }, n = oe.getFirstMatch(St, e) || oe.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/bada/i],
    describe(e) {
      const t = {
        name: "Bada"
      }, n = oe.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/tizen/i],
    describe(e) {
      const t = {
        name: "Tizen"
      }, n = oe.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/qupzilla/i],
    describe(e) {
      const t = {
        name: "QupZilla"
      }, n = oe.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(e) {
      const t = {
        name: "Firefox"
      }, n = oe.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/electron/i],
    describe(e) {
      const t = {
        name: "Electron"
      }, n = oe.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(e) {
      const t = {
        name: "Miui"
      }, n = oe.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/chromium/i],
    describe(e) {
      const t = {
        name: "Chromium"
      }, n = oe.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(e) {
      const t = {
        name: "Chrome"
      }, n = oe.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/GSA/i],
    describe(e) {
      const t = {
        name: "Google Search"
      }, n = oe.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  /* Android Browser */
  {
    test(e) {
      const t = !e.test(/like android/i), n = e.test(/android/i);
      return t && n;
    },
    describe(e) {
      const t = {
        name: "Android Browser"
      }, n = oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(e) {
      const t = {
        name: "PlayStation 4"
      }, n = oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(e) {
      const t = {
        name: "Safari"
      }, n = oe.getFirstMatch(St, e);
      return n && (t.version = n), t;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(e) {
      const t = /^(.*)\/(.*) /, n = /^(.*)\/(.*)[ \t]\((.*)/, a = e.search("\\(") !== -1 ? n : t;
      return {
        name: oe.getFirstMatch(a, e),
        version: oe.getSecondMatch(a, e)
      };
    }
  }
], dL = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(e) {
      const t = oe.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
      return {
        name: En.Roku,
        version: t
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(e) {
      const t = oe.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
      return {
        name: En.WindowsPhone,
        version: t
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(e) {
      const t = oe.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e), n = oe.getWindowsVersionName(t);
      return {
        name: En.Windows,
        version: t,
        versionName: n
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(e) {
      const t = {
        name: En.iOS
      }, n = oe.getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
      return n && (t.version = n), t;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(e) {
      const t = oe.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."), n = oe.getMacOSVersionName(t), r = {
        name: En.MacOS,
        version: t
      };
      return n && (r.versionName = n), r;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(e) {
      const t = oe.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
      return {
        name: En.iOS,
        version: t
      };
    }
  },
  /* Android */
  {
    test(e) {
      const t = !e.test(/like android/i), n = e.test(/android/i);
      return t && n;
    },
    describe(e) {
      const t = oe.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e), n = oe.getAndroidVersionName(t), r = {
        name: En.Android,
        version: t
      };
      return n && (r.versionName = n), r;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(e) {
      const t = oe.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e), n = {
        name: En.WebOS
      };
      return t && t.length && (n.version = t), n;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(e) {
      const t = oe.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || oe.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || oe.getFirstMatch(/\bbb(\d+)/i, e);
      return {
        name: En.BlackBerry,
        version: t
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(e) {
      const t = oe.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
      return {
        name: En.Bada,
        version: t
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(e) {
      const t = oe.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
      return {
        name: En.Tizen,
        version: t
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: En.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: En.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(e) {
      const t = oe.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
      return {
        name: En.PlayStation4,
        version: t
      };
    }
  }
], hL = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(e) {
      const t = oe.getFirstMatch(/(can-l01)/i, e) && "Nova", n = {
        type: jt.mobile,
        vendor: "Huawei"
      };
      return t && (n.model = t), n;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: jt.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: jt.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: jt.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: jt.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: jt.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: jt.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(e) {
      const t = e.test(/ipod|iphone/i), n = e.test(/like (ipod|iphone)/i);
      return t && !n;
    },
    describe(e) {
      const t = oe.getFirstMatch(/(ipod|iphone)/i, e);
      return {
        type: jt.mobile,
        vendor: "Apple",
        model: t
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: jt.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: jt.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(e) {
      return e.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: jt.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(e) {
      return e.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: jt.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(e) {
      return e.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: jt.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(e) {
      const t = Number(String(e.getOSVersion()).split(".")[0]);
      return e.getOSName(!0) === "android" && t >= 3;
    },
    describe() {
      return {
        type: jt.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(e) {
      return e.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: jt.mobile
      };
    }
  },
  /* desktop */
  {
    test(e) {
      return e.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: jt.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(e) {
      return e.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: jt.desktop
      };
    }
  },
  /* Linux */
  {
    test(e) {
      return e.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: jt.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(e) {
      return e.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: jt.tv
      };
    }
  },
  /* Roku */
  {
    test(e) {
      return e.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: jt.tv
      };
    }
  }
], mL = [
  /* EdgeHTML */
  {
    test(e) {
      return e.getBrowserName(!0) === "microsoft edge";
    },
    describe(e) {
      if (/\sedg\//i.test(e))
        return {
          name: Xr.Blink
        };
      const n = oe.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
      return {
        name: Xr.EdgeHTML,
        version: n
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(e) {
      const t = {
        name: Xr.Trident
      }, n = oe.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  /* Presto */
  {
    test(e) {
      return e.test(/presto/i);
    },
    describe(e) {
      const t = {
        name: Xr.Presto
      }, n = oe.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  /* Gecko */
  {
    test(e) {
      const t = e.test(/gecko/i), n = e.test(/like gecko/i);
      return t && !n;
    },
    describe(e) {
      const t = {
        name: Xr.Gecko
      }, n = oe.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: Xr.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(e) {
      const t = {
        name: Xr.WebKit
      }, n = oe.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  }
];
let jp = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(t, n = !1) {
    if (t == null || t === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = t, this.parsedResult = {}, n !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(t) {
    return t.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const t = oe.find(fL, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(t) {
    return t ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const t = oe.find(dL, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(t) {
    const { name: n } = this.getOS();
    return t ? String(n).toLowerCase() || "" : n || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(t = !1) {
    const { type: n } = this.getPlatform();
    return t ? String(n).toLowerCase() || "" : n || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const t = oe.find(hL, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(t) {
    return t ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const t = oe.find(mL, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return oe.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(t) {
    const n = {};
    let r = 0;
    const a = {};
    let i = 0;
    if (Object.keys(t).forEach((o) => {
      const u = t[o];
      typeof u == "string" ? (a[o] = u, i += 1) : typeof u == "object" && (n[o] = u, r += 1);
    }), r > 0) {
      const o = Object.keys(n), u = oe.find(o, (f) => this.isOS(f));
      if (u) {
        const f = this.satisfies(n[u]);
        if (f !== void 0)
          return f;
      }
      const l = oe.find(
        o,
        (f) => this.isPlatform(f)
      );
      if (l) {
        const f = this.satisfies(n[l]);
        if (f !== void 0)
          return f;
      }
    }
    if (i > 0) {
      const o = Object.keys(a), u = oe.find(o, (l) => this.isBrowser(l, !0));
      if (u !== void 0)
        return this.compareVersion(a[u]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(t, n = !1) {
    const r = this.getBrowserName().toLowerCase();
    let a = t.toLowerCase();
    const i = oe.getBrowserTypeByAlias(a);
    return n && i && (a = i.toLowerCase()), a === r;
  }
  compareVersion(t) {
    let n = [0], r = t, a = !1;
    const i = this.getBrowserVersion();
    if (typeof i == "string")
      return t[0] === ">" || t[0] === "<" ? (r = t.substr(1), t[1] === "=" ? (a = !0, r = t.substr(2)) : n = [], t[0] === ">" ? n.push(1) : n.push(-1)) : t[0] === "=" ? r = t.substr(1) : t[0] === "~" && (a = !0, r = t.substr(1)), n.indexOf(
        oe.compareVersions(i, r, a)
      ) > -1;
  }
  isOS(t) {
    return this.getOSName(!0) === String(t).toLowerCase();
  }
  isPlatform(t) {
    return this.getPlatformType(!0) === String(t).toLowerCase();
  }
  isEngine(t) {
    return this.getEngineName(!0) === String(t).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(t, n = !1) {
    return this.isBrowser(t, n) || this.isOS(t) || this.isPlatform(t);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(t = []) {
    return t.some((n) => this.is(n));
  }
};
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class pL {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(t, n = !1) {
    if (typeof t != "string")
      throw new Error("UserAgent should be a string");
    return new jp(t, n);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(t) {
    return new jp(t).getResult();
  }
  static get BROWSER_MAP() {
    return _E;
  }
  static get ENGINE_MAP() {
    return Xr;
  }
  static get OS_MAP() {
    return En;
  }
  static get PLATFORMS_MAP() {
    return jt;
  }
}
const rs = {
  /** @deprecated GPT 3 should be removed */
  DaVinci_003: "text-davinci-003",
  GPT_3_5_turbo: "gpt-3.5-turbo",
  GPT_4: "gpt-4",
  GPT_4_TURBO: "gpt-4-turbo",
  CLAUDE_V1: "claude-v1",
  CLAUDE_V2: "claude-v2",
  CLAUDE_INSTANT_V1: "claude-instant-v1"
};
rs.GPT_3_5_turbo, rs.GPT_4, rs.GPT_4_TURBO;
const yE = d.object({
  id: d.string()
}).strict(), Sd = yE.extend({
  createdAt: d.string().datetime()
}).strict(), hn = Sd.extend({
  updatedAt: d.string().datetime()
}).strict(), Ir = hn.extend({
  name: d.string(),
  folderID: d.string().nullable(),
  assistantID: d.string(),
  createdByID: d.number(),
  updatedByID: d.number(),
  environmentID: d.string()
}).strict(), gL = {
  DEFAULT: "default"
}, Cd = {
  ENGLISH_US: "en-us"
}, zp = {
  ADMIN: "admin",
  OWNER: "owner",
  EDITOR: "editor",
  VIEWER: "viewer",
  BILLING: "billing"
}, bL = d.object({ variableID: d.string() }).strict(), EL = d.object({ entityID: d.string() }).strict(), vL = d.object({ text: d.lazy(() => kn), attributes: d.record(d.unknown()).optional() }).strict(), kn = d.union([d.string(), bL, EL, vL]).array();
hn.extend({
  name: d.string(),
  workspaceID: d.string(),
  activePersonaID: d.string().nullable(),
  activeEnvironmentID: d.string()
}).strict();
const Ni = {
  CARD: "card",
  MEDIA: "media"
}, TL = {
  IMAGE: "image",
  VIDEO: "video"
}, SE = hn.extend({
  type: d.nativeEnum(Ni),
  assistantID: d.string(),
  environmentID: d.string()
}).strict(), AL = SE.extend({
  type: d.literal(Ni.CARD),
  title: kn,
  mediaID: d.string().nullable(),
  description: kn,
  buttonOrder: d.array(d.string())
}).strict(), _L = SE.extend({
  url: kn,
  type: d.literal(Ni.MEDIA),
  name: d.string(),
  isAsset: d.boolean(),
  datatype: d.nativeEnum(TL)
}).strict();
d.union([AL, _L]);
hn.extend({
  label: kn,
  cardID: d.string(),
  assistantID: d.string(),
  environmentID: d.string()
}).strict();
d.object({
  id: d.number(),
  name: d.string(),
  s3ObjectRef: d.string(),
  assistantID: d.string(),
  createdByID: d.number(),
  createdAt: d.string().datetime(),
  updatedAt: d.string().datetime()
}).strict();
const Ou = {
  EXPRESSION: "expression",
  PROMPT: "prompt",
  SCRIPT: "script"
}, Od = yE.extend({
  type: d.nativeEnum(Ou),
  assistantID: d.string(),
  environmentID: d.string()
}).strict(), Id = Od.extend({
  type: d.literal(Ou.PROMPT),
  turns: d.number(),
  promptID: d.string().nullable()
}).strict(), CE = Od.extend({
  type: d.literal(Ou.SCRIPT),
  code: kn
}).strict(), OE = Od.extend({
  type: d.literal(Ou.EXPRESSION),
  matchAll: d.boolean()
}).strict();
d.union([Id, CE, OE]);
const IE = {
  IS: "is",
  IS_NOT: "is_not",
  IS_EMPTY: "is_empty",
  IS_NOT_EMPTY: "is_not_empty",
  GREATER_THAN: "greater_than",
  GREATER_OR_EQUAL: "greater_or_equal",
  LESS_THAN: "less_than",
  LESS_OR_EQUAL: "less_or_equal",
  CONTAINS: "contains",
  NOT_CONTAINS: "not_contains",
  STARTS_WITH: "starts_with",
  ENDS_WITH: "ends_with"
};
hn.extend({
  lhs: kn,
  rhs: kn,
  operation: d.nativeEnum(IE),
  conditionID: d.string(),
  assistantID: d.string(),
  environmentID: d.string()
}).strict();
const xE = Ir.extend({
  text: kn,
  personaID: d.string().nullable()
}).strict(), NE = xE.pick({ text: !0, personaID: !0 }).strict(), Vp = Id.pick({ type: !0, turns: !0 }).strict(), yL = d.union([
  Vp.extend(Id.pick({ promptID: !0 }).shape),
  Vp.extend({ prompt: NE })
]), SL = CE.pick({ type: !0, code: !0 }).strict(), CL = OE.pick({ type: !0, matchAll: !0 }).strict(), OL = d.union([
  yL,
  SL,
  CL
]);
hn.extend({
  rhs: kn,
  operation: d.nativeEnum(IE),
  conditionID: d.string(),
  assistantID: d.string(),
  environmentID: d.string()
}).strict();
const IL = d.object({
  type: d.string(),
  sourceID: d.string()
}).strict(), RE = d.object({
  type: d.string(),
  data: d.record(d.unknown()),
  nodeID: d.string(),
  coords: d.tuple([d.number(), d.number()]).optional()
}).strict();
d.object({
  _id: d.string(),
  name: d.string(),
  type: d.string().optional(),
  zoom: d.number(),
  nodes: d.record(RE),
  offsetX: d.number(),
  offsetY: d.number(),
  modified: d.number(),
  children: d.array(d.string()).optional(),
  diagramID: d.string(),
  versionID: d.string(),
  creatorID: d.number(),
  variables: d.array(d.string()),
  menuItems: d.array(IL).optional(),
  /**
   * @deprecated use `menuItems` instead
   */
  menuNodeIDs: d.array(d.string()).optional().describe("@deprecated in favor of menuItems"),
  /**
   * @deprecated use `menuNodeIDs` instead
   */
  intentStepIDs: d.array(d.string()).optional().describe("@deprecated in favor of menuNodeIDs")
}).strict();
const xL = Ir.extend({
  color: d.string(),
  isArray: d.boolean(),
  classifier: d.string().nullable(),
  description: d.string().nullable()
}).strict(), NL = hn.extend({
  value: d.string(),
  language: d.nativeEnum(Cd),
  synonyms: d.array(d.string()),
  entityID: d.string(),
  assistantID: d.string(),
  environmentID: d.string()
}).strict();
xL.extend({
  variants: d.array(NL)
}).strict();
Ir.extend({
  requestName: d.string(),
  description: d.string().nullable()
}).strict();
hn.extend({
  path: kn,
  eventID: d.string(),
  variableID: d.string().nullable(),
  assistantID: d.string(),
  environmentID: d.string()
}).strict();
Ir.extend({
  diagramID: d.string(),
  description: d.string().nullable()
}).strict();
const RL = {
  ENTITY: "entity",
  EVENT: "event",
  FLOW: "flow",
  FUNCTION: "function",
  INTENT: "intent",
  PROMPT: "prompt",
  PERSONA: "persona",
  RESPONSE: "response",
  STORY: "story",
  VARIABLE: "variable"
};
hn.extend({
  name: d.string(),
  scope: d.nativeEnum(RL),
  parentID: d.string().nullable(),
  assistantID: d.string(),
  environmentID: d.string()
}).strict();
Ir.extend({
  code: d.string(),
  image: d.string().nullable(),
  description: d.string().nullable()
}).strict();
hn.extend({
  name: d.string(),
  label: d.string().nullable(),
  functionID: d.string(),
  assistantID: d.string(),
  environmentID: d.string()
}).strict();
const kL = {
  INPUT: "input",
  OUTPUT: "output"
};
hn.extend({
  name: d.string(),
  type: d.nativeEnum(kL),
  functionID: d.string(),
  description: d.string().nullable(),
  assistantID: d.string(),
  environmentID: d.string()
}).strict();
const wL = Ir.extend({
  description: d.string().nullable(),
  entityOrder: d.array(d.string()),
  automaticReprompt: d.boolean()
}), DL = d.object({ entityID: d.string() }).strict(), PL = d.object({ text: d.lazy(() => kE), attributes: d.record(d.unknown()).optional() }).strict(), kE = d.union([d.string(), DL, PL]).array(), wE = hn.extend({
  text: kE,
  language: d.nativeEnum(Cd),
  intentID: d.string(),
  assistantID: d.string(),
  environmentID: d.string()
});
wL.extend({
  utterances: d.array(wE)
}).strict();
const DE = Sd.extend({
  intentID: d.string(),
  entityID: d.string(),
  repromptID: d.string().nullable(),
  assistantID: d.string(),
  environmentID: d.string()
}), PE = Sd.extend({
  type: d.nativeEnum(Ni),
  assistantID: d.string(),
  environmentID: d.string()
}).strict(), LE = PE.extend({
  type: d.literal(Ni.CARD),
  cardID: d.string()
}).strict(), ME = PE.extend({
  type: d.literal(Ni.MEDIA),
  mediaID: d.string()
}).strict();
d.union([LE, ME]);
const LL = LE.pick({ type: !0, cardID: !0 }).strict(), ML = ME.pick({ type: !0, mediaID: !0 }).strict(), $L = d.union([
  LL,
  ML
]), BL = {
  CAROUSEL: "carousel",
  LIST: "list"
}, FL = {
  PROMPT: "prompt",
  MEMORY: "memory",
  KNOWLEDGE_BASE: "knowledge_base"
}, xd = {
  JSON: "json",
  PROMPT: "prompt",
  /**
   * only available if the default interface is text
   */
  TEXT: "text"
}, Nd = hn.extend({
  conditionID: d.string().nullable(),
  assistantID: d.string(),
  environmentID: d.string(),
  attachmentOrder: d.array(d.string()),
  discriminatorID: d.string()
}).strict(), Iu = Nd.extend({
  type: d.literal(xd.JSON),
  json: kn
}).strict(), xu = Nd.extend({
  type: d.literal(xd.TEXT),
  text: kn,
  speed: d.number().nullable(),
  cardLayout: d.nativeEnum(BL)
}).strict(), Fs = Nd.extend({
  type: d.literal(xd.PROMPT),
  turns: d.number(),
  context: d.nativeEnum(FL),
  promptID: d.string().nullable()
}).strict();
d.union([
  Iu,
  xu,
  Fs
]);
const Rd = d.object({
  condition: d.nullable(OL),
  attachments: d.array($L)
}), UL = Rd.extend(Iu.pick({ type: !0, json: !0 }).shape).strict(), HL = Rd.extend(xu.pick({ type: !0, text: !0, speed: !0, cardLayout: !0 }).shape).strict(), Gp = Rd.extend(Fs.pick({
  type: !0,
  turns: !0,
  context: !0
}).shape).strict(), jL = d.union([
  Gp.extend(Fs.pick({ promptID: !0 }).shape).strict(),
  Gp.extend({ prompt: NE }).strict()
]), zL = d.union([
  UL,
  HL,
  jL
]), Yp = DE.pick({ entityID: !0 }).strict();
d.union([
  Yp.extend(DE.pick({ repromptID: !0 }).shape).strict(),
  Yp.extend({ reprompts: d.array(zL) }).strict()
]);
wE.pick({ text: !0, language: !0 }).strict();
const VL = {
  LIST: "List",
  CAROUSEL: "Carousel"
}, Nu = {
  TEXT: "text",
  BLOCK: "block",
  START: "start",
  ACTIONS: "actions",
  FUNCTION: "function"
}, GL = d.object({
  id: d.string(),
  type: d.nativeEnum(Nu),
  data: d.unknown().optional()
}), YL = {
  STRING: "string",
  NUMBER: "number",
  BOOLEAN: "boolean",
  ARRAY: "array",
  OBJECT: "object"
}, Wp = d.object({
  type: d.literal(YL.STRING).describe("The type of the Function variable. Used to render suitable UI and perform data validation.")
}), WL = d.object({
  code: d.string().describe("The code of the Function step"),
  inputVars: d.record(Wp).describe("Mapping of input variable name to its configuration."),
  outputVars: d.record(Wp).describe("Mapping of output variable name to its configuration."),
  pathCodes: d.array(d.string()).describe("List of valid return codes for a function")
});
GL.extend({
  type: d.literal(Nu.FUNCTION),
  data: d.object({
    functionDefinition: WL,
    inputMapping: d.record(d.string()),
    outputMapping: d.record(d.string().nullable()),
    paths: d.record(d.string())
  })
});
const qL = {
  FAIL: "fail",
  NEXT: "next",
  PAUSE: "pause",
  NO_REPLY: "no-reply",
  NO_MATCH: "else",
  PREVIOUS: "previous"
}, ii = {
  FAIL: "fail",
  NEXT: "next",
  PAUSE: "pause",
  NO_REPLY: "no-reply",
  NO_MATCH: "else",
  PREVIOUS: "previous"
}, qr = d.object({
  id: d.string(),
  type: d.union([d.string(), d.nativeEnum(qL)]),
  target: d.string().nullable().describe("Id of the node that the port points to")
}), $E = d.object({
  name: d.string().optional(),
  portsV2: d.object({
    byKey: d.record(qr).describe("Mapping of arbitrary string key to port"),
    /**
     * @deprecated use byKey instead
     */
    builtIn: d.record(d.object({
      [ii.FAIL]: qr,
      [ii.NEXT]: qr,
      [ii.PAUSE]: qr,
      [ii.NO_REPLY]: qr,
      [ii.NO_MATCH]: qr,
      [ii.PREVIOUS]: qr
    }).partial()).describe("@deprecated use byKey instead"),
    /**
     * @deprecated use byKey instead
     */
    dynamic: d.array(qr).describe("@deprecated use byKey instead")
  })
}), KL = RE.extend({
  type: d.nativeEnum(Nu),
  data: $E.optional()
});
KL.extend({
  type: d.literal(Nu.FUNCTION),
  data: $E.extend({
    functionID: d.string().nullable(),
    inputMapping: d.record(kn),
    outputMapping: d.record(d.string().nullable())
  })
});
const XL = {
  FULL: "full",
  HIDDEN: "hidden",
  CROPPED: "cropped"
}, ZL = {
  APL: "apl",
  IMAGE: "image"
};
Ir.extend({
  model: d.nativeEnum(rs),
  maxLength: d.number(),
  temperature: d.number(),
  systemPrompt: d.string()
}).strict();
hn.extend({
  name: d.string().nullable(),
  model: d.nativeEnum(rs).nullable(),
  maxLength: d.number().nullable(),
  personaID: d.string(),
  temperature: d.number().nullable(),
  assistantID: d.string(),
  systemPrompt: d.string().nullable(),
  environmentID: d.string()
}).strict();
const QL = d.object({
  type: d.string()
}).nonstrict(), JL = d.object({
  id: d.string(),
  type: d.string()
}).nonstrict(), e4 = d.object({
  _id: d.string(),
  name: d.string(),
  lines: d.record(JL),
  startId: d.string(),
  legacyId: d.string().optional(),
  commands: QL.array(),
  diagramID: d.string(),
  versionID: d.string(),
  variables: d.string().array()
}).strict(), t4 = d.object({
  type: d.string().optional(),
  name: d.string().optional()
}).nonstrict(), n4 = d.object({
  type: d.string().optional()
}).nonstrict(), r4 = d.object({
  tags: d.array(d.string()).optional(),
  data: t4.optional(),
  status: n4.optional(),
  version: d.number().optional(),
  updatedAt: d.string().optional(),
  creatorID: d.number().optional(),
  documentID: d.string().optional(),
  s3ObjectRef: d.string().optional()
}).strict(), a4 = d.object({
  type: d.string().optional()
}).nonstrict(), i4 = d.object({
  tags: d.array(d.string()).optional(),
  name: d.string().optional(),
  status: a4.optional(),
  version: d.number().optional(),
  faqSetID: d.string().optional(),
  updatedAt: d.string().optional(),
  creatorID: d.number().optional()
}).strict(), s4 = d.object({
  tagID: d.string(),
  label: d.string()
}).strict(), BE = d.object({
  tags: d.record(s4).optional(),
  faqSets: d.record(i4).optional(),
  settings: d.record(d.any()).optional(),
  documents: d.record(r4).optional()
}).strict(), o4 = d.object({
  aiPlayground: d.boolean().optional(),
  generateStep: d.boolean().optional(),
  generativeTasks: d.boolean().optional(),
  generateNoMatch: d.boolean().optional()
}).nonstrict(), u4 = d.object({
  50: d.string(),
  100: d.string(),
  200: d.string(),
  300: d.string(),
  400: d.string(),
  500: d.string(),
  600: d.string(),
  700: d.string(),
  800: d.string(),
  900: d.string()
}).strict(), l4 = d.object({
  name: d.string().optional(),
  palette: u4,
  standardColor: d.string()
}).strict(), c4 = d.object({
  creatorID: d.number(),
  platformData: d.record(d.unknown())
}).strict(), qp = {
  PUBLIC: "public",
  PRIVATE: "private"
}, f4 = d.object({
  label: d.string(),
  tagID: d.string()
}).strict(), d4 = d.object({
  id: d.string(),
  url: d.string()
}).strict();
d.object({
  _id: d.string(),
  nlu: d.string().optional(),
  type: d.string().optional(),
  name: d.string(),
  image: d.string().optional(),
  teamID: d.string(),
  members: d.array(c4),
  privacy: d.nativeEnum(qp).optional(),
  platform: d.string(),
  _version: d.number().optional(),
  linkType: d.string().optional(),
  stickers: d.array(d4).optional(),
  creatorID: d.number(),
  updatedBy: d.number().optional(),
  createdAt: d.string().nullable().optional(),
  updatedAt: d.string().optional(),
  prototype: d.record(d.unknown()).optional(),
  apiPrivacy: d.nativeEnum(qp).optional(),
  devVersion: d.string().optional(),
  liveVersion: d.string().optional(),
  reportTags: d.record(f4).optional(),
  platformData: d.record(d.unknown()),
  customThemes: d.array(l4).optional(),
  knowledgeBase: d.optional(BE).describe("@deprecated use version.knowledgeBase"),
  aiAssistSettings: d.optional(o4)
}).strict();
d.union([d.literal(zp.EDITOR), d.literal(zp.VIEWER)]);
e4.extend({}).strict();
const Us = {
  TEXT: "text",
  ACTION: "action",
  INTENT: "intent",
  LAUNCH: "launch",
  NO_REPLY: "no-reply"
}, fa = d.object({
  type: d.string(),
  payload: d.record(d.any()).optional(),
  diagramID: d.string().optional()
});
fa.extend({
  type: d.literal(Us.LAUNCH),
  payload: d.object({
    persona: d.string().optional()
  }).optional()
});
fa.extend({
  type: d.literal(Us.NO_REPLY)
});
fa.extend({
  type: d.literal(Us.TEXT),
  payload: d.string()
});
fa.extend({
  type: d.literal(Us.ACTION),
  payload: d.object({
    label: d.string().optional()
  })
});
const h4 = d.object({
  name: d.string(),
  value: d.string(),
  query: d.string().optional(),
  verboseValue: d.string().optional()
}), m4 = fa.extend({
  type: d.literal(Us.INTENT),
  payload: d.object({
    data: d.record(d.any()).optional(),
    query: d.string().optional(),
    intent: d.object({ name: d.string() }),
    entities: d.array(h4).optional(),
    confidence: d.number().optional()
  })
});
Ir.extend({});
const p4 = hn.extend({
  channel: d.nativeEnum(gL),
  language: d.nativeEnum(Cd),
  responseID: d.string(),
  assistantID: d.string(),
  variantOrder: d.array(d.string()),
  environmentID: d.string()
}).strict(), g4 = Fs.extend({
  prompt: xE
}).strict(), b4 = d.union([
  Iu,
  xu,
  g4
]);
p4.extend({
  variants: d.array(b4)
}).strict();
Iu.pick({ json: !0, attachmentOrder: !0 }).strict().partial();
xu.pick({
  text: !0,
  speed: !0,
  cardLayout: !0,
  attachmentOrder: !0
}).strict().partial();
Fs.pick({
  turns: !0,
  context: !0,
  promptID: !0,
  attachmentOrder: !0
}).strict().partial();
const E4 = {
  TO_DO: "to_do",
  COMPLETE: "complete",
  IN_PROGRESS: "in_progress"
};
Ir.extend({
  status: d.nativeEnum(E4).nullable(),
  flowID: d.string().nullable(),
  isStart: d.boolean(),
  isEnabled: d.boolean(),
  assigneeID: d.number().nullable(),
  description: d.string().nullable(),
  triggerOrder: d.array(d.string())
}).strict();
const kd = {
  EVENT: "event",
  INTENT: "intent"
}, FE = hn.extend({
  name: d.string(),
  target: d.nativeEnum(kd),
  storyID: d.string(),
  assistantID: d.string(),
  environmentID: d.string()
}).strict(), v4 = FE.extend({
  target: d.literal(kd.EVENT),
  eventID: d.string()
}).strict(), T4 = FE.extend({
  target: d.literal(kd.INTENT),
  intentID: d.string()
}).strict();
d.union([v4, T4]);
const UE = d.any();
d.object({
  id: d.string(),
  nodeID: d.string().nullable(),
  resolved: d.boolean(),
  position: d.tuple([d.number(), d.number()]),
  projectID: d.string(),
  diagramID: d.string()
}).strict();
d.object({
  id: d.string(),
  text: d.string(),
  created: d.string(),
  mentions: d.array(d.number()),
  threadID: d.string(),
  authorID: d.number()
}).strict();
const on = {
  LOG: "log",
  END: "end",
  TEXT: "text",
  PATH: "path",
  FLOW: "flow",
  GOTO: "goto",
  SPEAK: "speak",
  BLOCK: "block",
  DEBUG: "debug",
  CHOICE: "choice",
  STREAM: "stream",
  VISUAL: "visual",
  CARD_V2: "cardV2",
  CAROUSEL: "carousel",
  NO_REPLY: "no-reply",
  ENTITY_FILLING: "entity-filling",
  CHANNEL_ACTION: "channel-action",
  KNOWLEDGE_BASE: "knowledgeBase"
}, A4 = d.object({
  label: d.string().optional(),
  event: fa.optional()
}), HE = d.object({
  name: d.string(),
  request: fa.optional()
}), mn = d.object({
  type: d.nativeEnum(on),
  paths: d.array(A4).optional(),
  defaultPath: d.number().optional()
});
mn.extend({
  type: d.literal(on.BLOCK),
  payload: d.object({
    blockID: d.string()
  })
});
const jE = d.object({
  title: d.string(),
  buttons: d.array(HE),
  imageUrl: d.string().nullable(),
  description: d.object({
    text: d.string(),
    // slate is optional, but text is required
    slate: UE.optional()
  })
}).partial(), _4 = mn.extend({
  type: d.literal(on.CARD_V2),
  payload: jE
}), y4 = mn.extend({
  type: d.literal(on.CAROUSEL),
  payload: d.object({
    cards: d.array(jE),
    layout: d.nativeEnum(VL)
  })
});
mn.extend({
  type: d.literal(on.CHANNEL_ACTION),
  payload: d.object({
    name: d.string(),
    payload: d.record(d.any())
  })
});
const S4 = mn.extend({
  type: d.literal(on.CHOICE),
  payload: d.object({
    buttons: d.array(HE)
  })
});
mn.extend({
  type: d.literal(on.DEBUG),
  payload: d.object({
    type: d.string().optional(),
    message: d.string()
  })
});
mn.extend({
  type: d.literal(on.ENTITY_FILLING),
  payload: d.object({
    entityToFill: d.string(),
    intent: m4
  })
});
mn.extend({
  type: d.literal(on.END)
});
mn.extend({
  type: d.literal(on.FLOW),
  payload: d.object({
    name: d.string().optional(),
    diagramID: d.string()
  })
});
mn.extend({
  type: d.literal(on.GOTO),
  payload: d.object({
    request: fa
  })
});
mn.extend({
  type: d.literal(on.LOG),
  // TODO: define this later
  payload: d.record(d.unknown())
});
mn.extend({
  type: d.literal(on.NO_REPLY),
  payload: d.object({
    timeout: d.number()
  })
});
const C4 = {
  AUDIO: "audio",
  MESSAGE: "message"
};
mn.extend({
  type: d.literal(on.SPEAK),
  payload: d.object({
    src: d.string().nullable().optional(),
    type: d.nativeEnum(C4),
    voice: d.string().optional(),
    isPrompt: d.boolean().optional()
  })
});
const O4 = {
  LOOP: "LOOP",
  PLAY: "PLAY",
  PAUSE: "PAUSE",
  END: "END"
};
mn.extend({
  type: d.literal(on.STREAM),
  payload: d.object({
    src: d.string(),
    token: d.string(),
    action: d.nativeEnum(O4),
    loop: d.boolean().optional(),
    title: d.string().optional(),
    iconImage: d.string().optional(),
    description: d.string().optional(),
    backgroundImage: d.string().optional()
  })
});
const I4 = mn.extend({
  type: d.literal(on.TEXT),
  payload: d.object({
    slate: UE,
    delay: d.number().optional()
  })
}), x4 = d.object({
  visualType: d.literal(ZL.IMAGE),
  image: d.string().nullable(),
  device: d.string().nullable().optional(),
  options: d.object({ loop: d.boolean().optional() }).optional(),
  frameType: d.string().optional(),
  dimensions: d.object({ width: d.number(), height: d.number() }).nullable().optional(),
  canvasVisibility: d.nativeEnum(XL).optional()
}), N4 = mn.extend({
  type: d.literal(on.VISUAL),
  /**
   * APL is deprecated, so we only support Image for now.
   */
  payload: x4
}), R4 = {
  LOCALE: "locale",
  CHANNEL: "channel",
  USER_ID: "user_id",
  SESSIONS: "sessions",
  PLATFORM: "platform",
  TIMESTAMP: "timestamp",
  LAST_EVENT: "last_event",
  LAST_RESPONSE: "last_response",
  LAST_UTTERANCE: "last_utterance",
  INTENT_CONFIDENCE: "intent_confidence"
}, k4 = {
  TEXT: "text",
  DATE: "date",
  IMAGE: "image",
  NUMBER: "number",
  BOOLEAN: "boolean"
};
Ir.extend({
  color: d.string(),
  system: d.nativeEnum(R4).nullable(),
  isArray: d.boolean(),
  datatype: d.nativeEnum(k4),
  description: d.string().nullable(),
  defaultValue: d.string().nullable()
}).strict();
const w4 = d.object({
  stepID: d.string(),
  diagramID: d.string()
}).strict();
d.object({
  _id: d.string(),
  name: d.string(),
  projectID: d.string(),
  variables: d.record(d.any()),
  startFrom: w4.nullable().optional()
}).strict();
const D4 = d.object({
  id: d.string(),
  name: d.string(),
  color: d.string().nullable(),
  nodeIDs: d.array(d.string())
}).strict(), P4 = d.object({
  id: d.string(),
  name: d.string()
}).strict(), L4 = d.object({
  key: d.string(),
  name: d.string(),
  body: d.string().optional(),
  stop: d.boolean().optional(),
  paths: d.array(d.string()).optional(),
  parameters: d.record(P4).optional(),
  defaultPath: d.number().optional()
}).strict(), M4 = d.object({
  id: d.string(),
  name: d.string(),
  live: d.boolean(),
  status: d.string().optional(),
  topicIDs: d.array(d.string()),
  updatedBy: d.number().optional(),
  updatedAt: d.string().optional(),
  rootDiagramID: d.string(),
  /**
   * @deprecated in favor of updatedBy
   * */
  updatedByCreatorID: d.number().optional().describe("@deprecated in favor of updatedBy")
}).strict(), xf = d.object({
  type: d.string(),
  sourceID: d.string()
}).strict(), $4 = d.object({
  id: d.string(),
  name: d.string(),
  items: d.array(xf)
}).strict(), B4 = {
  PROTOTYPE: "prototype",
  CONVERSATION: "conversation",
  NLU_DATA_SOURCEIMPORT: "nluDatasourceImport"
}, F4 = d.object({
  id: d.string().optional(),
  sourceID: d.string().optional(),
  utterance: d.string(),
  /**
   * @deprecated in favor of unclassifiedData.importedAt
   */
  importedAt: d.string().optional().describe("@deprecated in favor of UnclassifiedData.importedAt")
}).strict(), U4 = d.object({
  key: d.string().optional(),
  name: d.string(),
  type: d.nativeEnum(B4),
  creatorID: d.number().optional(),
  utterances: d.array(F4),
  importedAt: d.string().optional(),
  /**
   * @deprecated in favor of key
   */
  id: d.number().optional().describe("@deprecated in favor of key")
}).strict(), H4 = d.object({
  id: d.string(),
  type: d.string(),
  text: d.string(),
  meta: d.record(d.unknown()).optional(),
  mentions: d.array(d.number())
}).strict();
d.object({
  _id: d.string(),
  name: d.string(),
  notes: d.record(H4).optional(),
  /**
   * @deprecated use domains instead
   */
  topics: d.array(xf).optional().describe("@deprecated in favor of domains"),
  folders: d.record($4).optional(),
  domains: d.array(M4).optional(),
  legacyID: d.string().optional(),
  _version: d.number(),
  creatorID: d.number(),
  projectID: d.string(),
  prototype: d.record(d.unknown()).optional(),
  variables: d.array(d.string()),
  components: d.array(xf).optional(),
  manualSave: d.boolean().optional(),
  platformData: d.record(d.unknown()),
  customBlocks: d.record(L4).optional(),
  rootDiagramID: d.string(),
  knowledgeBase: d.optional(BE),
  canvasTemplates: d.array(D4).optional(),
  templateDiagramID: d.string().optional(),
  defaultStepColors: d.record(d.string()).optional(),
  /**
   * @deprecated in favor of legacyID
   */
  secondaryVersionID: d.number().optional().describe("@deprecated in favor of legacyID"),
  autoSaveFromRestore: d.boolean().optional(),
  nluUnclassifiedData: d.array(U4).optional()
}).strict();
const Kp = (e) => {
  var t;
  return !!e.title || !!e.description || !!e.image || !!((t = e.actions) != null && t.filter(({ name: n }) => !!n).length);
}, j4 = [
  w6(({ context: e }, t) => {
    if (!I4.safeParse(t).success)
      return e;
    const { slate: n, message: r, ai: a, delay: i } = t.payload;
    return e.messages.push({
      type: vn.TEXT,
      text: (n == null ? void 0 : n.content) || r,
      delay: i,
      ...a ? { ai: a } : {}
    }), e;
  }),
  D6(({ context: e }, t) => (N4.safeParse(t).success && e.messages.push({ type: vn.IMAGE, url: t.payload.image }), e)),
  k6(({ context: e }, t) => {
    if (!S4.safeParse(t).success)
      return e;
    const {
      payload: { buttons: n }
    } = t;
    return e.actions = n.map(({ name: r, request: a }) => ({
      name: r,
      request: a
    })), e;
  }),
  R6(({ context: e }, t) => {
    if (!_4.safeParse(t).success)
      return e;
    const {
      payload: { title: n, imageUrl: r, description: a, buttons: i }
    } = t, s = {
      title: n,
      description: a.text,
      image: r,
      actions: i.map(({ name: o, request: u }) => ({ name: o, request: u }))
    };
    return Kp(s) && e.messages.push({
      type: "card",
      ...s
    }), e;
  }),
  {
    canHandle: ({ type: e }) => e === hr.CAROUSEL,
    handle: ({ context: e }, t) => {
      if (!y4.safeParse(t).success)
        return e;
      const n = t.payload.cards.map(({ title: r, description: a, imageUrl: i, buttons: s }) => ({
        title: r,
        description: a.text,
        image: i,
        actions: s.map(({ name: o, request: u }) => ({ name: o, request: u }))
      })).filter(Kp);
      return n.length && e.messages.push({
        type: vn.CAROUSEL,
        cards: n
      }), e;
    }
  },
  {
    canHandle: ({ type: e }) => e === hr.END,
    handle: ({ context: e }) => (e.messages.push({ type: vn.END }), e)
  }
];
var es = /* @__PURE__ */ ((e) => (e.POSITIVE = "Thumbs up", e.NEGATIVE = "Thumbs down", e))(es || {});
const zE = () => ({
  messages: []
}), z4 = ({
  url: e,
  user: t,
  userID: n,
  verify: r,
  versionID: a,
  traceHandlers: i = []
}) => {
  const s = ua(
    () => new N6({
      verify: r,
      url: e,
      traces: [...j4, ...i]
    }),
    []
  );
  return { interact: async (f) => s.interact(zE(), {
    sessionID: encodeURIComponent(n),
    action: f,
    ...a && { versionID: a }
  }), saveFeedback: async (f, h, p) => {
    const b = [];
    h.forEach((v) => {
      if (!v.ai || v.type !== vn.TEXT)
        return;
      const E = typeof v.text == "string" ? v.text : AE(v.text);
      b.push(E);
    }), await s.feedback({
      sessionID: encodeURIComponent(n),
      name: f,
      text: b,
      lastUserTurn: p,
      ...a && { versionID: a }
    });
  }, saveTranscript: async () => {
    const {
      browser: { name: f },
      os: { name: h },
      platform: { type: p }
    } = pL.parse(window.navigator.userAgent);
    await s.createTranscript(n, {
      ...h && { os: h },
      ...f && { browser: f },
      ...p && { device: p },
      ...t && { user: t }
    });
  } };
}, V4 = {
  turns: [],
  startTime: Date.now()
}, G4 = ({ assistant: e, config: t, traceHandlers: n }) => {
  const [r, a] = _n(!1), [i, s, o] = jw(() => ({
    ...V4,
    status: t.autostart ? or.IDLE : or.ENDED,
    // retrieve stored session
    ...BD(e.persistence, t.verify.projectID, t.userID)
  })), [u, l] = _n(!1), { clearNoReplyTimeout: f, setNoReplyTimeout: h } = M6(() => ({ interact: A, isStatus: v })), p = z4({
    ...t,
    ...i,
    traceHandlers: [
      P6(h),
      ...UP(e.extensions),
      ...L6(e.extensions),
      ...n ?? []
    ]
  }), b = (V) => {
    s((G) => G.status === V ? G : { ...G, status: V });
  }, v = (V) => o.current.status === V, E = (V) => {
    s((G) => ({ ...G, turns: V(G.turns) }));
  }, y = (V) => E((G) => [...G, V]), N = () => E(() => []), A = async (V, G) => {
    if (f(), o.current.status === or.ENDED)
      return;
    o.current.turns.length === 1 && p.saveTranscript(), LD(V);
    const O = G || (Mb.isTextRequest(V) ? V.payload : null);
    O && y({
      id: Es(),
      type: hi.USER,
      message: O,
      timestamp: Date.now()
    }), l(!0);
    const Q = await p.interact(V).catch((ee) => (console.error(ee), zE()));
    l(!1), y({
      id: Es(),
      type: hi.SYSTEM,
      timestamp: Date.now(),
      ...Q
    }), Ao({ type: ns.INTERACT, payload: { session: o.current, action: V } }), l0(e.persistence, t.verify.projectID, o.current);
  }, I = async () => {
    var V;
    o.current.turns.length && N(), b(or.ACTIVE), await A(((V = t.launch) == null ? void 0 : V.event) ?? { type: Qn.LAUNCH, payload: null });
  }, j = async (V) => A({ type: Qn.TEXT, payload: V }), $ = async () => {
    Ao({ type: ns.OPEN }), a(!0), v(or.IDLE) && await I();
  }, _ = () => {
    Ao({ type: ns.CLOSE }), l0(e.persistence, t.verify.projectID, o.current), a(!1);
  }, M = () => o.current.turns;
  return {
    state: {
      session: i,
      isOpen: r,
      indicator: u
    },
    api: {
      launch: I,
      reply: j,
      open: $,
      interact: A,
      close: _,
      addTurn: y,
      feedback: p.saveFeedback,
      setStatus: b,
      isStatus: v,
      reset: N,
      getTurns: M,
      // these are meant to be static, so bundling them with the API
      assistant: e,
      config: t
    }
  };
}, pr = Qf({}), Ru = Qf({}), zz = ({ children: e, extend: t, ...n }) => {
  const r = G4(n), a = ua(() => (t == null ? void 0 : t(r.api)) ?? r.api, []);
  return /* @__PURE__ */ J.jsx(pr.Provider, { value: a, children: /* @__PURE__ */ J.jsx(Ru.Provider, { value: r.state, children: e }) });
}, VE = 246, Hs = Ot(yt.CARD), GE = Ce(Hs("section"), {
  display: "inline-flex",
  flexDirection: "column",
  width: VE,
  border: "1px solid #f1f1f1",
  borderRadius: "$2",
  boxSizing: "content-box",
  overflow: "hidden",
  backgroundColor: "$lightGrey",
  [`& ${Zn.Container}`]: {
    width: "100%",
    color: "$primary",
    backgroundColor: "$white",
    boxShadow: "0 5px 8px -8px $shadow12, 0 2px 4px -3px $shadow12, 0 0 0 1px $shadow3, 0 1px 3px 1px $shadow1",
    marginBottom: "$2",
    trans: ["color", "box-shadow"],
    "&:hover": {
      color: "$darkPrimary",
      backgroundColor: "$white",
      boxShadow: "0 5px 8px -8px $shadow12, 0 2px 4px -3px $shadow12, 0 0 0 1px $shadow4, 0 1px 4px 1px $shadow4"
    },
    "&:first-of-type": {
      marginTop: "$3"
    },
    "&:last-of-type": {
      marginBottom: 0
    }
  }
}), Y4 = Ce(Hs("main", "content"), {
  padding: "$3"
}), W4 = Ce(Hs("h3", "header"), {
  margin: "0 0 $1 0",
  typo: { weight: "$2" },
  color: "$black",
  wordBreak: "break-word",
  maxWidth: "100%",
  whiteSpace: "break-spaces"
}), q4 = Ce(Hs("p", "description"), {
  margin: 0,
  typo: { size: "$1" },
  color: "$darkGrey",
  whiteSpace: "normal",
  wordBreak: "break-all"
}), K4 = Ce(Hs("a", "link"), {
  margin: 0,
  typo: { size: "$1" },
  whiteSpace: "normal",
  overflow: "hidden",
  textOverflow: "ellipsis",
  color: "rgb(93, 157, 245)",
  textDecoration: "underline",
  pointerEvents: "all",
  wordBreak: "break-all"
}), X4 = (e) => {
  let t;
  try {
    t = new URL(e);
  } catch {
    return !1;
  }
  return t.protocol === "http:" || t.protocol === "https:";
}, Z4 = ({ title: e, description: t, image: n, actions: r = [] }) => {
  const a = jn(pr), i = X4(t), s = ua(() => r.filter(({ name: o }) => !!o), [r]);
  return /* @__PURE__ */ J.jsxs(GE, { children: [
    !!n && /* @__PURE__ */ J.jsx(rb, { image: n }),
    /* @__PURE__ */ J.jsxs(Y4, { children: [
      !!e && /* @__PURE__ */ J.jsx(W4, { children: e }),
      !!t && (i ? /* @__PURE__ */ J.jsx(K4, { rel: "noopener noreferrer", href: t, target: "_blank", children: t }) : /* @__PURE__ */ J.jsx(q4, { children: t })),
      s.map(({ request: o, name: u }, l) => /* @__PURE__ */ J.jsx(Zn, { onClick: () => a.interact(o, u), children: u }, l))
    ] })
  ] });
}, wd = Object.assign(Z4, {
  Container: GE
}), ho = 42, ku = 12, YE = Ot(yt.CAROUSEL), Q4 = Ce(YE("span", "button"), {
  position: "absolute",
  zIndex: 1,
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "$round",
  trans: ["background-color", "box-shadow", "opacity"],
  height: ho,
  width: ho,
  cursor: "pointer",
  backgroundColor: "$white",
  color: "$black",
  boxShadow: "0 1px 3px 1px $shadow1, 0 0 0 1px $shadow3, 0 2px 4px -3px $shadow12, 0 5px 8px -8px $shadow12",
  border: "none",
  [`& ${Rn.Frame}`]: {
    height: "$xxs",
    width: "$xxs",
    color: "rgba(0,0,0,0.6)",
    trans: ["color"]
  },
  "&:hover": {
    boxShadow: "0 1px 4px 1px $shadow4, 0 0 0 1px $shadow4, 0 2px 4px -3px $shadow12, 0 5px 8px -8px $shadow12"
  },
  "&:active": {
    boxShadow: "0 1px 4px 1px $shadow8, 0 0 0 1px $shadow4, 0 2px 4px -3px $shadow12, 0 5px 8px -8px $shadow12"
  },
  [`
      &:hover ${Rn.Frame},
      &:active ${Rn.Frame}
    `]: {
    color: "rgba(0,0,0,0.8)"
  },
  variants: {
    visible: {
      true: {
        opacity: 1,
        pointerEvents: "auto"
      },
      false: {
        opacity: 0,
        pointerEvents: "none"
      }
    },
    alignment: {
      left: {
        left: 48 - ho / 2
      },
      right: {
        right: 70 - ho / 2,
        [`& ${Rn.Frame}`]: {
          transform: "scaleX(-1)"
        }
      }
    }
  }
}), WE = Ce(YE("div"), {
  display: "flex",
  whiteSpace: "nowrap",
  [`& ${wd.Container}`]: {
    height: "fit-content",
    flexShrink: 0,
    marginLeft: ku,
    "&:first-of-type": {
      marginLeft: 0
    }
  }
}), Xp = Xf(
  ({ onClick: e, alignment: t, visible: n, containerEl: r }, a) => /* @__PURE__ */ J.jsx(
    Q4,
    {
      ref: a,
      alignment: t,
      visible: n,
      css: {
        transform: `translateY(calc(${r.clientHeight / 2}px - 50%))`
      },
      onClick: e,
      children: /* @__PURE__ */ J.jsx(Rn, { svg: "largeArrowLeft" })
    }
  )
), Dd = VE + 2, qE = Dd / 3, J4 = Dd + ku + qE, ru = Dd + ku, Zp = (e, t) => () => {
  const n = e == null ? void 0 : e.current;
  if (!n)
    return;
  const r = t(n);
  n.scrollTo({
    left: r && r * ru,
    behavior: "smooth"
  });
}, eM = (e, t, n) => {
  const [r, a] = _n(!1), [i, s] = _n(!1), o = Xn(null), u = Xn(null), l = n.length > 1;
  return Sr(() => {
    !(t != null && t.current) || !l || s(!0);
  }, []), Sr(() => {
    const f = e == null ? void 0 : e.current;
    if (!f || !l)
      return;
    const h = ru * n.length - ku, p = () => {
      const { scrollLeft: b } = f;
      a(b >= qE), s(b <= h - J4);
    };
    return f.addEventListener("scroll", p), () => {
      f.removeEventListener("scroll", p);
    };
  }, []), {
    previousButtonRef: o,
    nextButtonRef: u,
    showPreviousButton: r,
    showNextButton: i
  };
}, tM = ({ cards: e, containerRef: t, controlsRef: n }) => {
  const { previousButtonRef: r, nextButtonRef: a, showPreviousButton: i, showNextButton: s } = eM(
    t,
    n,
    e
  ), o = t == null ? void 0 : t.current, u = n == null ? void 0 : n.current, l = o && u, f = Zp(t, (p) => Math.ceil(p.scrollLeft / ru) - 1), h = Zp(t, (p) => Math.floor(p.scrollLeft / ru) + 1);
  return /* @__PURE__ */ J.jsxs(J.Fragment, { children: [
    /* @__PURE__ */ J.jsx(WE, { children: e.map((p, b) => /* @__PURE__ */ Zf(wd, { ...p, key: b })) }),
    l && yS(
      /* @__PURE__ */ J.jsxs(J.Fragment, { children: [
        /* @__PURE__ */ J.jsx(
          Xp,
          {
            ref: r,
            alignment: "left",
            visible: i,
            containerEl: o,
            onClick: f
          }
        ),
        /* @__PURE__ */ J.jsx(
          Xp,
          {
            ref: a,
            alignment: "right",
            visible: s,
            containerEl: o,
            onClick: h
          }
        )
      ] }),
      u
    )
  ] });
}, nM = Object.assign(tM, {
  Container: WE
}), Pd = (e, t) => ({ initialValue: n, ...r }) => {
  var u;
  const a = _n(n ?? (t == null ? void 0 : t.defaultValue)), i = ((u = t == null ? void 0 : t.enrichProps) == null ? void 0 : u.call(t, r, a)) ?? r, [s, o] = a;
  return /* @__PURE__ */ J.jsx(e, { ...i, value: s, onValueChange: o });
}, Ld = (...e) => (...t) => e.forEach((n) => n == null ? void 0 : n(...t)), Vz = () => {
};
function Nf() {
  return Nf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Nf.apply(this, arguments);
}
function rM(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var aM = L1, iM = function(t) {
  var n = Fe.useRef(t);
  return aM(function() {
    n.current = t;
  }), n;
}, Qp = function(t, n) {
  if (typeof t == "function") {
    t(n);
    return;
  }
  t.current = n;
}, sM = function(t, n) {
  var r = Xn();
  return ra(function(a) {
    t.current = a, r.current && Qp(r.current, null), r.current = n, n && Qp(n, a);
  }, [n]);
}, Jp = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0"
}, oM = function(t) {
  Object.keys(Jp).forEach(function(n) {
    t.style.setProperty(n, Jp[n], "important");
  });
}, eg = oM, bn = null, tg = function(t, n) {
  var r = t.scrollHeight;
  return n.sizingStyle.boxSizing === "border-box" ? r + n.borderSize : r - n.paddingSize;
};
function uM(e, t, n, r) {
  n === void 0 && (n = 1), r === void 0 && (r = 1 / 0), bn || (bn = document.createElement("textarea"), bn.setAttribute("tabindex", "-1"), bn.setAttribute("aria-hidden", "true"), eg(bn)), bn.parentNode === null && document.body.appendChild(bn);
  var a = e.paddingSize, i = e.borderSize, s = e.sizingStyle, o = s.boxSizing;
  Object.keys(s).forEach(function(p) {
    var b = p;
    bn.style[b] = s[b];
  }), eg(bn), bn.value = t;
  var u = tg(bn, e);
  bn.value = t, u = tg(bn, e), bn.value = "x";
  var l = bn.scrollHeight - a, f = l * n;
  o === "border-box" && (f = f + a + i), u = Math.max(f, u);
  var h = l * r;
  return o === "border-box" && (h = h + a + i), u = Math.min(h, u), [u, l];
}
var ng = function() {
}, lM = function(t, n) {
  return t.reduce(function(r, a) {
    return r[a] = n[a], r;
  }, {});
}, cM = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak"
], fM = !!document.documentElement.currentStyle, dM = function(t) {
  var n = window.getComputedStyle(t);
  if (n === null)
    return null;
  var r = lM(cM, n), a = r.boxSizing;
  if (a === "")
    return null;
  fM && a === "border-box" && (r.width = parseFloat(r.width) + parseFloat(r.borderRightWidth) + parseFloat(r.borderLeftWidth) + parseFloat(r.paddingRight) + parseFloat(r.paddingLeft) + "px");
  var i = parseFloat(r.paddingBottom) + parseFloat(r.paddingTop), s = parseFloat(r.borderBottomWidth) + parseFloat(r.borderTopWidth);
  return {
    sizingStyle: r,
    paddingSize: i,
    borderSize: s
  };
}, hM = dM;
function KE(e, t, n) {
  var r = iM(n);
  Fe.useLayoutEffect(function() {
    var a = function(s) {
      return r.current(s);
    };
    if (e)
      return e.addEventListener(t, a), function() {
        return e.removeEventListener(t, a);
      };
  }, []);
}
var mM = function(t) {
  KE(window, "resize", t);
}, pM = function(t) {
  KE(document.fonts, "loadingdone", t);
}, gM = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], bM = function(t, n) {
  var r = t.cacheMeasurements, a = t.maxRows, i = t.minRows, s = t.onChange, o = s === void 0 ? ng : s, u = t.onHeightChange, l = u === void 0 ? ng : u, f = rM(t, gM), h = f.value !== void 0, p = Fe.useRef(null), b = sM(p, n), v = Fe.useRef(0), E = Fe.useRef(), y = function() {
    var I = p.current, j = r && E.current ? E.current : hM(I);
    if (j) {
      E.current = j;
      var $ = uM(j, I.value || I.placeholder || "x", i, a), _ = $[0], M = $[1];
      v.current !== _ && (v.current = _, I.style.setProperty("height", _ + "px", "important"), l(_, {
        rowHeight: M
      }));
    }
  }, N = function(I) {
    h || y(), o(I);
  };
  return Fe.useLayoutEffect(y), mM(y), pM(y), /* @__PURE__ */ Fe.createElement("textarea", Nf({}, f, {
    onChange: N,
    ref: b
  }));
}, EM = /* @__PURE__ */ Fe.forwardRef(bM);
const rg = {
  width: "calc(100% - 42px)",
  borderRadius: "$1 0 0 $1",
  height: "42px",
  borderRightWidth: 0,
  fontFamily: "$default",
  fontSize: "$2"
}, Md = {
  boxSizing: "border-box",
  border: "1px solid rgba(115,115,118,0.3)",
  backgroundColor: "$white",
  boxShadow: "0 1px 12px $shadow2",
  trans: ["border-color"],
  resize: "none"
}, Rf = {
  border: "1px solid rgba(115,115,118,0.5)"
}, XE = Ce(EM, {
  ...Md,
  ...rg,
  // TODO use tokens
  padding: "11px $4 11px",
  color: "$black",
  "&:focus": {
    ...Rf,
    ...rg,
    outline: "none"
  },
  "&::placeholder": {
    color: "$darkGrey"
  }
}), ag = Xf(({ onValueChange: e, onChange: t, ...n }, r) => {
  const a = Ld(t, (i) => e(i.target.value));
  return /* @__PURE__ */ J.jsx(XE, { ref: r, ...n, onChange: a, minRows: 1, maxRows: 5, style: { height: 42 } });
}), yo = Object.assign(ag, {
  Controlled: Pd(ag, { defaultValue: "" }),
  Container: XE
}), ZE = Ot(yt.CHAT_INPUT), au = Ce(ZE("label", "button"), {
  ...Md,
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  paddingBottom: "8px",
  width: "$md",
  borderRadius: "$1",
  boxSizing: "border-box",
  cursor: "text",
  [`& ${oc.Container}`]: {
    transform: "scale(0)",
    marginTop: "auto",
    trans: ["background-color", "transform"]
  },
  variants: {
    ready: {
      true: {
        [`& ${oc.Container}`]: {
          transform: "scale(1)",
          cursor: "pointer"
        }
      }
    }
  }
}), QE = Ce(ZE("div"), {
  display: "flex",
  boxShadow: "0 1px 12px $shadow2",
  trans: ["border-color", "box-shadow"],
  [`& ${yo.Container}`]: {
    ...Md,
    minHeight: "$md",
    margin: 0,
    borderRightWidth: 0,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 0,
    paddingRight: 7,
    boxShadow: "none"
  },
  [`& ${au}`]: {
    height: "inherit",
    borderLeftWidth: 0,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 0
  },
  [`& ${Rn.Frame}`]: {
    color: "$white"
  },
  [`& ${yo.Container}:focus`]: {
    ...Rf,
    borderRightWidth: 0
  },
  [`& ${yo.Container}:focus + ${au}`]: {
    ...Rf,
    borderLeftWidth: 0
  }
}), ig = ({ id: e, onSend: t, disableSend: n, ...r }) => {
  const a = ua(() => `vf-chat-input--${Es()}`, []) ?? e, i = Xn(null), s = (o) => {
    o.stopPropagation();
    const { shiftKey: u } = o;
    o.key === "Enter" && o.key === "Enter" && !u && (o.preventDefault(), t == null || t());
  };
  return /* @__PURE__ */ J.jsxs(QE, { children: [
    /* @__PURE__ */ J.jsx(yo, { ref: i, id: a, onKeyDown: s, ...r }),
    /* @__PURE__ */ J.jsx(au, { htmlFor: a, ready: !!r.value && !n, children: /* @__PURE__ */ J.jsx(oc, { size: "small", svg: "smallArrowUp", onClick: t }) })
  ] });
}, vM = Object.assign(ig, {
  Controlled: Pd(ig, {
    defaultValue: "",
    enrichProps: (e, [, t]) => ({
      ...e,
      onSend: () => {
        var n;
        t(""), (n = e.onSend) == null || n.call(e);
      }
    })
  }),
  Container: QE,
  ButtonContainer: au
}), TM = Ot(yt.INPUT), AM = {
  height: "$md",
  boxSizing: "border-box",
  border: "1px solid rgba(115,115,118,0.3)",
  borderRadius: "$1",
  backgroundColor: "$white",
  boxShadow: "0 1px 12px $shadow2",
  trans: ["border-color"]
}, _M = {
  border: "1px solid rgba(115,115,118,0.5)"
}, JE = Ce(TM("input"), {
  ...AM,
  padding: "0 $4",
  typo: {},
  color: "$black",
  "&:focus": {
    ..._M,
    outline: 0
  },
  "&::placeholder": {
    color: "$darkGrey"
  }
}), sg = ({ onValueChange: e, onChange: t, ...n }) => {
  const r = Ld(t, (a) => e(a.target.value));
  return /* @__PURE__ */ J.jsx(JE, { ...n, onChange: r });
}, yM = Object.assign(sg, {
  Controlled: Pd(sg, { defaultValue: "" }),
  Container: JE
}), ev = Ot(yt.FOOTER), tv = Ce(ev("footer"), {
  padding: "$3 $4 $4 $4",
  borderRadius: "$1",
  [`& ${yM.Container}`]: {
    flex: 1
  },
  [`& ${Zn.Container}`]: {
    width: "100%"
  },
  variants: {
    withShadow: {
      true: {
        boxShadow: "0 12px 48px $shadow16"
      }
    },
    withWatermark: {
      true: {
        paddingBottom: "0"
      }
    }
  }
}), nv = Ce(ev("aside", "watermark"), {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  padding: "10px 0 $3 0",
  typo: { size: 12, height: "17px" },
  color: "$darkGrey",
  "& a": {
    marginLeft: "0.5ch",
    textDecoration: "none",
    color: "$blue",
    "&:focus": {
      outline: 0
    }
  }
}), SM = ({ withWatermark: e, hasEnded: t, disableSend: n, onStart: r, onSend: a }) => {
  const [i, s] = _n(""), o = async () => {
    !i || n || (s(""), await (a == null ? void 0 : a(i)));
  };
  return /* @__PURE__ */ J.jsxs(tv, { withShadow: !!t, withWatermark: e, children: [
    t ? /* @__PURE__ */ J.jsx(Zn, { onClick: r, children: "Start New Chat" }) : /* @__PURE__ */ J.jsx(
      vM,
      {
        value: i,
        placeholder: "Message",
        autoFocus: !0,
        onValueChange: s,
        onSend: o,
        disableSend: n
      }
    ),
    e && /* @__PURE__ */ J.jsxs(nv, { children: [
      "Assistant  by",
      /* @__PURE__ */ J.jsx("a", { target: "_blank", href: "https://voiceflow.com", rel: "noreferrer", children: "Voiceflow" })
    ] })
  ] });
}, rv = Object.assign(SM, {
  Container: tv,
  Watermark: nv
}), $d = Ot(yt.HEADER), Bd = Ce($d("h1", "title"), {
  ...V1,
  typo: { size: 17, weight: "$2", height: "$2" },
  color: "rgba(255,255,255,0.95)"
}), av = Ce($d(Zn.Reset, "button"), {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  height: 32,
  width: 32,
  marginLeft: 8,
  borderRadius: 6,
  background: "none",
  trans: ["background-color"],
  "&:hover": {
    backgroundColor: "rgba(255,255,255,0.16)",
    [`& ${Rn.Frame}`]: {
      color: "$white"
    }
  },
  [`& ${Rn.Frame}`]: {
    height: "$xxs",
    width: "$xxs",
    color: "rgba(255,255,255,0.8)",
    trans: ["color"]
  }
}), iv = Ce($d("header"), {
  display: "flex",
  flexShrink: 0,
  alignItems: "center",
  height: "$lg",
  padding: "0 $4 0 $5",
  backgroundColor: "$primary",
  boxShadow: "0 1px 2px $shadow16",
  [`& ${aa.Container}`]: {
    height: 32,
    width: 32
  },
  [`& ${Bd}`]: {
    flex: 1,
    margin: "0 0 0 14px"
  }
}), CM = ({ title: e, image: t, actions: n = [] }) => /* @__PURE__ */ J.jsxs(iv, { children: [
  /* @__PURE__ */ J.jsx(aa, { avatar: t }),
  /* @__PURE__ */ J.jsx(Bd, { children: e }),
  n.map(({ svg: r, onClick: a }, i) => /* @__PURE__ */ J.jsx(av, { onClick: a, children: /* @__PURE__ */ J.jsx(Rn, { svg: r }) }, i))
] }), sv = Object.assign(CM, {
  Container: iv,
  Title: Bd,
  Button: av
}), og = 32, OM = 1e3, IM = Ot(yt.LOADER), ov = Ce(IM("div"), {
  height: og,
  width: og,
  borderWidth: "2px",
  borderStyle: "solid",
  borderRadius: "$round",
  borderColor: "#f0f0f0",
  borderTopColor: "#000",
  animation: `${EC} ${OM}ms linear`,
  animationIterationCount: "infinite"
}), xM = Ot(yt.PROMPT), uv = Ce(xM("div"), {
  padding: "$4 $4 $3 $4",
  borderRadius: "$1",
  backgroundColor: "$white",
  boxShadow: "0 12px 48px 4px $shadow12",
  [`& ${Zn.Container}`]: {
    width: "100%",
    marginTop: "$1",
    "&:first-of-type": {
      marginTop: 0
    }
  }
}), NM = ({ accept: e, cancel: t }) => /* @__PURE__ */ J.jsxs(uv, { children: [
  /* @__PURE__ */ J.jsx(Zn.Primary, { tabIndex: -1, ...e, children: e.label }),
  /* @__PURE__ */ J.jsx(Zn, { type: "subtle", tabIndex: -1, ...t, children: t.label })
] }), So = Object.assign(NM, {
  Container: uv
}), RM = "voiceflow-chat-frame";
var wu = /* @__PURE__ */ ((e) => (e.EMBEDDED = "embedded", e.OVERLAY = "overlay", e))(wu || {});
const kM = d.object({
  mode: d.nativeEnum(wu).default(
    "overlay"
    /* OVERLAY */
  ),
  target: d.instanceof(HTMLElement).optional().transform((e) => e ?? document.getElementById(RM) ?? void 0)
}).optional().transform((e) => {
  if (e != null && e.target && e.mode !== "embedded" && console.warn(`render.target has no effect in ${e.mode} mode.`), (e == null ? void 0 : e.mode) === "embedded") {
    if (e.target)
      return {
        mode: "embedded",
        target: e.target
      };
    console.error("No valid target found for embedded mode. Defaulting to overlay mode.");
  }
  return {
    mode: "overlay"
    /* OVERLAY */
  };
});
var lv = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    var n = 1e3, r = 6e4, a = 36e5, i = "millisecond", s = "second", o = "minute", u = "hour", l = "day", f = "week", h = "month", p = "quarter", b = "year", v = "date", E = "Invalid Date", y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, N = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, A = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, I = function(H, D, R) {
      var Y = String(H);
      return !Y || Y.length >= D ? H : "" + Array(D + 1 - Y.length).join(R) + H;
    }, j = { s: I, z: function(H) {
      var D = -H.utcOffset(), R = Math.abs(D), Y = Math.floor(R / 60), P = R % 60;
      return (D <= 0 ? "+" : "-") + I(Y, 2, "0") + ":" + I(P, 2, "0");
    }, m: function H(D, R) {
      if (D.date() < R.date())
        return -H(R, D);
      var Y = 12 * (R.year() - D.year()) + (R.month() - D.month()), P = D.clone().add(Y, h), Z = R - P < 0, W = D.clone().add(Y + (Z ? -1 : 1), h);
      return +(-(Y + (R - P) / (Z ? P - W : W - P)) || 0);
    }, a: function(H) {
      return H < 0 ? Math.ceil(H) || 0 : Math.floor(H);
    }, p: function(H) {
      return { M: h, y: b, w: f, d: l, D: v, h: u, m: o, s, ms: i, Q: p }[H] || String(H || "").toLowerCase().replace(/s$/, "");
    }, u: function(H) {
      return H === void 0;
    } }, $ = "en", _ = {};
    _[$] = A;
    var M = function(H) {
      return H instanceof Q;
    }, V = function H(D, R, Y) {
      var P;
      if (!D)
        return $;
      if (typeof D == "string") {
        var Z = D.toLowerCase();
        _[Z] && (P = Z), R && (_[Z] = R, P = Z);
        var W = D.split("-");
        if (!P && W.length > 1)
          return H(W[0]);
      } else {
        var C = D.name;
        _[C] = D, P = C;
      }
      return !Y && P && ($ = P), P || !Y && $;
    }, G = function(H, D) {
      if (M(H))
        return H.clone();
      var R = typeof D == "object" ? D : {};
      return R.date = H, R.args = arguments, new Q(R);
    }, O = j;
    O.l = V, O.i = M, O.w = function(H, D) {
      return G(H, { locale: D.$L, utc: D.$u, x: D.$x, $offset: D.$offset });
    };
    var Q = function() {
      function H(R) {
        this.$L = V(R.locale, null, !0), this.parse(R);
      }
      var D = H.prototype;
      return D.parse = function(R) {
        this.$d = function(Y) {
          var P = Y.date, Z = Y.utc;
          if (P === null)
            return /* @__PURE__ */ new Date(NaN);
          if (O.u(P))
            return /* @__PURE__ */ new Date();
          if (P instanceof Date)
            return new Date(P);
          if (typeof P == "string" && !/Z$/i.test(P)) {
            var W = P.match(y);
            if (W) {
              var C = W[2] - 1 || 0, pe = (W[7] || "0").substring(0, 3);
              return Z ? new Date(Date.UTC(W[1], C, W[3] || 1, W[4] || 0, W[5] || 0, W[6] || 0, pe)) : new Date(W[1], C, W[3] || 1, W[4] || 0, W[5] || 0, W[6] || 0, pe);
            }
          }
          return new Date(P);
        }(R), this.$x = R.x || {}, this.init();
      }, D.init = function() {
        var R = this.$d;
        this.$y = R.getFullYear(), this.$M = R.getMonth(), this.$D = R.getDate(), this.$W = R.getDay(), this.$H = R.getHours(), this.$m = R.getMinutes(), this.$s = R.getSeconds(), this.$ms = R.getMilliseconds();
      }, D.$utils = function() {
        return O;
      }, D.isValid = function() {
        return this.$d.toString() !== E;
      }, D.isSame = function(R, Y) {
        var P = G(R);
        return this.startOf(Y) <= P && P <= this.endOf(Y);
      }, D.isAfter = function(R, Y) {
        return G(R) < this.startOf(Y);
      }, D.isBefore = function(R, Y) {
        return this.endOf(Y) < G(R);
      }, D.$g = function(R, Y, P) {
        return O.u(R) ? this[Y] : this.set(P, R);
      }, D.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, D.valueOf = function() {
        return this.$d.getTime();
      }, D.startOf = function(R, Y) {
        var P = this, Z = !!O.u(Y) || Y, W = O.p(R), C = function(Ue, Ae) {
          var Me = O.w(P.$u ? Date.UTC(P.$y, Ae, Ue) : new Date(P.$y, Ae, Ue), P);
          return Z ? Me : Me.endOf(l);
        }, pe = function(Ue, Ae) {
          return O.w(P.toDate()[Ue].apply(P.toDate("s"), (Z ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Ae)), P);
        }, me = this.$W, w = this.$M, Ne = this.$D, Re = "set" + (this.$u ? "UTC" : "");
        switch (W) {
          case b:
            return Z ? C(1, 0) : C(31, 11);
          case h:
            return Z ? C(1, w) : C(0, w + 1);
          case f:
            var De = this.$locale().weekStart || 0, Qe = (me < De ? me + 7 : me) - De;
            return C(Z ? Ne - Qe : Ne + (6 - Qe), w);
          case l:
          case v:
            return pe(Re + "Hours", 0);
          case u:
            return pe(Re + "Minutes", 1);
          case o:
            return pe(Re + "Seconds", 2);
          case s:
            return pe(Re + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, D.endOf = function(R) {
        return this.startOf(R, !1);
      }, D.$set = function(R, Y) {
        var P, Z = O.p(R), W = "set" + (this.$u ? "UTC" : ""), C = (P = {}, P[l] = W + "Date", P[v] = W + "Date", P[h] = W + "Month", P[b] = W + "FullYear", P[u] = W + "Hours", P[o] = W + "Minutes", P[s] = W + "Seconds", P[i] = W + "Milliseconds", P)[Z], pe = Z === l ? this.$D + (Y - this.$W) : Y;
        if (Z === h || Z === b) {
          var me = this.clone().set(v, 1);
          me.$d[C](pe), me.init(), this.$d = me.set(v, Math.min(this.$D, me.daysInMonth())).$d;
        } else
          C && this.$d[C](pe);
        return this.init(), this;
      }, D.set = function(R, Y) {
        return this.clone().$set(R, Y);
      }, D.get = function(R) {
        return this[O.p(R)]();
      }, D.add = function(R, Y) {
        var P, Z = this;
        R = Number(R);
        var W = O.p(Y), C = function(w) {
          var Ne = G(Z);
          return O.w(Ne.date(Ne.date() + Math.round(w * R)), Z);
        };
        if (W === h)
          return this.set(h, this.$M + R);
        if (W === b)
          return this.set(b, this.$y + R);
        if (W === l)
          return C(1);
        if (W === f)
          return C(7);
        var pe = (P = {}, P[o] = r, P[u] = a, P[s] = n, P)[W] || 1, me = this.$d.getTime() + R * pe;
        return O.w(me, this);
      }, D.subtract = function(R, Y) {
        return this.add(-1 * R, Y);
      }, D.format = function(R) {
        var Y = this, P = this.$locale();
        if (!this.isValid())
          return P.invalidDate || E;
        var Z = R || "YYYY-MM-DDTHH:mm:ssZ", W = O.z(this), C = this.$H, pe = this.$m, me = this.$M, w = P.weekdays, Ne = P.months, Re = function(Ae, Me, it, pt) {
          return Ae && (Ae[Me] || Ae(Y, Z)) || it[Me].slice(0, pt);
        }, De = function(Ae) {
          return O.s(C % 12 || 12, Ae, "0");
        }, Qe = P.meridiem || function(Ae, Me, it) {
          var pt = Ae < 12 ? "AM" : "PM";
          return it ? pt.toLowerCase() : pt;
        }, Ue = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: me + 1, MM: O.s(me + 1, 2, "0"), MMM: Re(P.monthsShort, me, Ne, 3), MMMM: Re(Ne, me), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: Re(P.weekdaysMin, this.$W, w, 2), ddd: Re(P.weekdaysShort, this.$W, w, 3), dddd: w[this.$W], H: String(C), HH: O.s(C, 2, "0"), h: De(1), hh: De(2), a: Qe(C, pe, !0), A: Qe(C, pe, !1), m: String(pe), mm: O.s(pe, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: W };
        return Z.replace(N, function(Ae, Me) {
          return Me || Ue[Ae] || W.replace(":", "");
        });
      }, D.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, D.diff = function(R, Y, P) {
        var Z, W = O.p(Y), C = G(R), pe = (C.utcOffset() - this.utcOffset()) * r, me = this - C, w = O.m(this, C);
        return w = (Z = {}, Z[b] = w / 12, Z[h] = w, Z[p] = w / 3, Z[f] = (me - pe) / 6048e5, Z[l] = (me - pe) / 864e5, Z[u] = me / a, Z[o] = me / r, Z[s] = me / n, Z)[W] || me, P ? w : O.a(w);
      }, D.daysInMonth = function() {
        return this.endOf(h).$D;
      }, D.$locale = function() {
        return _[this.$L];
      }, D.locale = function(R, Y) {
        if (!R)
          return this.$L;
        var P = this.clone(), Z = V(R, Y, !0);
        return Z && (P.$L = Z), P;
      }, D.clone = function() {
        return O.w(this.$d, this);
      }, D.toDate = function() {
        return new Date(this.valueOf());
      }, D.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, D.toISOString = function() {
        return this.$d.toISOString();
      }, D.toString = function() {
        return this.$d.toUTCString();
      }, H;
    }(), ee = Q.prototype;
    return G.prototype = ee, [["$ms", i], ["$s", s], ["$m", o], ["$H", u], ["$W", l], ["$M", h], ["$y", b], ["$D", v]].forEach(function(H) {
      ee[H[1]] = function(D) {
        return this.$g(D, H[0], H[1]);
      };
    }), G.extend = function(H, D) {
      return H.$i || (H(D, Q, G), H.$i = !0), G;
    }, G.locale = V, G.isDayjs = M, G.unix = function(H) {
      return G(1e3 * H);
    }, G.en = _[$], G.Ls = _, G.p = {}, G;
  });
})(lv);
var wM = lv.exports;
const kf = /* @__PURE__ */ Ft(wM);
var cv = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(je, function() {
    return function(n, r, a) {
      n = n || {};
      var i = r.prototype, s = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function o(l, f, h, p) {
        return i.fromToBase(l, f, h, p);
      }
      a.en.relativeTime = s, i.fromToBase = function(l, f, h, p, b) {
        for (var v, E, y, N = h.$locale().relativeTime || s, A = n.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], I = A.length, j = 0; j < I; j += 1) {
          var $ = A[j];
          $.d && (v = p ? a(l).diff(h, $.d, !0) : h.diff(l, $.d, !0));
          var _ = (n.rounding || Math.round)(Math.abs(v));
          if (y = v > 0, _ <= $.r || !$.r) {
            _ <= 1 && j > 0 && ($ = A[j - 1]);
            var M = N[$.l];
            b && (_ = b("" + _)), E = typeof M == "string" ? M.replace("%d", _) : M(_, f, $.l, y);
            break;
          }
        }
        if (f)
          return E;
        var V = y ? N.future : N.past;
        return typeof V == "function" ? V(E) : V.replace("%s", E);
      }, i.to = function(l, f) {
        return o(l, f, this, !0);
      }, i.from = function(l, f) {
        return o(l, f, this);
      };
      var u = function(l) {
        return l.$u ? a.utc() : a();
      };
      i.toNow = function(l) {
        return this.to(u(this), l);
      }, i.fromNow = function(l) {
        return this.from(u(this), l);
      };
    };
  });
})(cv);
var DM = cv.exports;
const PM = /* @__PURE__ */ Ft(DM);
kf.extend(PM);
const LM = (e) => ua(() => {
  if (!e)
    return null;
  const t = kf(e), n = kf();
  switch (!0) {
    case n.isSame(t, "day"):
      return "Today";
    case n.subtract(1, "day").isSame(t, "day"):
      return "Yesterday";
    default:
      return t.fromNow();
  }
}, [e]), fv = (e = []) => {
  const { scrollToBottom: t } = jn(od);
  L1(() => {
    t();
  }, e);
}, ug = (e) => {
  const t = (n) => () => console.warn(e(n));
  return {
    open: t("open"),
    hide: t("hide"),
    show: t("show"),
    close: t("close"),
    interact: t("interact"),
    proactive: {
      clear: t("proactive.clear"),
      push: t("proactive.push")
    }
  };
}, dv = (e, t, n) => Sr(() => {
  if (!OS(e))
    return;
  const r = ug((i) => `Method '${i}' has no effect in this mode.`), a = t();
  return Object.assign(e, {
    ...r,
    ...a,
    proactive: {
      ...r.proactive,
      ...a.proactive
    }
  }), n == null || n(), () => {
    const i = ug(
      (s) => `Method '${s}' has no effect after 'destroy' has been called. Call 'load' to render the chat and restore this method.`
    );
    Object.assign(e, i);
  };
}, []), MM = (e, t = []) => {
  const n = Xn(!1);
  Sr(() => {
    if (n.current)
      return e();
    n.current = !0;
  }, t);
}, hv = (e) => {
  const [t, n] = _n("");
  return Sr(() => {
    e != null && e.color && n(gC({ color: e.color }));
  }, [e == null ? void 0 : e.color]), t;
};
var iu = Symbol("@ts-pattern/matcher"), lg = "@ts-pattern/anonymous-select-key", cg = function(e) {
  return !!(e && typeof e == "object");
}, Ll = function(e) {
  return e && !!e[iu];
}, $M = function e(t, n, r) {
  if (cg(t)) {
    if (Ll(t)) {
      var a = t[iu]().match(n), i = a.matched, s = a.selections;
      return i && s && Object.keys(s).forEach(function(u) {
        return r(u, s[u]);
      }), i;
    }
    if (!cg(n))
      return !1;
    if (Array.isArray(t))
      return !!Array.isArray(n) && t.length === n.length && t.every(function(u, l) {
        return e(u, n[l], r);
      });
    if (t instanceof Map)
      return n instanceof Map && Array.from(t.keys()).every(function(u) {
        return e(t.get(u), n.get(u), r);
      });
    if (t instanceof Set) {
      if (!(n instanceof Set))
        return !1;
      if (t.size === 0)
        return n.size === 0;
      if (t.size === 1) {
        var o = Array.from(t.values())[0];
        return Ll(o) ? Array.from(n.values()).every(function(u) {
          return e(o, u, r);
        }) : n.has(o);
      }
      return Array.from(t.values()).every(function(u) {
        return n.has(u);
      });
    }
    return Object.keys(t).every(function(u) {
      var l, f = t[u];
      return (u in n || Ll(l = f) && l[iu]().matcherType === "optional") && e(f, n[u], r);
    });
  }
  return Object.is(n, t);
};
function Fa(e) {
  var t;
  return (t = {})[iu] = function() {
    return { match: function(n) {
      return { matched: !!e(n) };
    } };
  }, t;
}
Fa(function(e) {
  return !0;
});
Fa(function(e) {
  return typeof e == "string";
});
Fa(function(e) {
  return typeof e == "number";
});
Fa(function(e) {
  return typeof e == "boolean";
});
Fa(function(e) {
  return typeof e == "bigint";
});
Fa(function(e) {
  return typeof e == "symbol";
});
Fa(function(e) {
  return e == null;
});
function Du(e) {
  return new BM(e, []);
}
var BM = /* @__PURE__ */ function() {
  function e(n, r) {
    this.value = void 0, this.cases = void 0, this.value = n, this.cases = r;
  }
  var t = e.prototype;
  return t.with = function() {
    var n = [].slice.call(arguments), r = n[n.length - 1], a = [n[0]], i = [];
    return n.length === 3 && typeof n[1] == "function" ? (a.push(n[0]), i.push(n[1])) : n.length > 2 && a.push.apply(a, n.slice(1, n.length - 1)), new e(this.value, this.cases.concat([{ match: function(s) {
      var o = {}, u = !!(a.some(function(l) {
        return $M(l, s, function(f, h) {
          o[f] = h;
        });
      }) && i.every(function(l) {
        return l(s);
      }));
      return { matched: u, value: u && Object.keys(o).length ? lg in o ? o[lg] : o : s };
    }, handler: r }]));
  }, t.when = function(n, r) {
    return new e(this.value, this.cases.concat([{ match: function(a) {
      return { matched: !!n(a), value: a };
    }, handler: r }]));
  }, t.otherwise = function(n) {
    return new e(this.value, this.cases.concat([{ match: function(r) {
      return { matched: !0, value: r };
    }, handler: n }])).run();
  }, t.exhaustive = function() {
    return this.run();
  }, t.run = function() {
    for (var n = this.value, r = void 0, a = 0; a < this.cases.length; a++) {
      var i = this.cases[a], s = i.match(this.value);
      if (s.matched) {
        n = s.value, r = i.handler;
        break;
      }
    }
    if (!r) {
      var o;
      try {
        o = JSON.stringify(this.value);
      } catch {
        o = this.value;
      }
      throw new Error("Pattern matching error: no pattern matches value " + o);
    }
    return r(n, this.value);
  }, e;
}();
const FM = (e = Jo) => ({
  type: "indicator",
  messageDelay: e
}), UM = ({
  messages: e,
  isLast: t
}) => {
  const n = Xn(t && !!e.length), [r, a] = _n(!n.current), [i, s] = _n(n.current), [o, u] = _n(n.current ? [] : e), l = ra(() => {
    a(!0), s(!1);
  }, []);
  return Sr(() => {
    if (!n)
      return;
    const f = e.flatMap((v) => [
      FM(v.delay),
      { type: "message", message: v }
    ]);
    let h;
    const p = (v, E) => {
      if (E === 0) {
        v();
        return;
      }
      h = setTimeout(() => {
        v();
      }, E);
    }, b = () => {
      if (!n.current)
        return;
      const v = f.shift();
      if (!v) {
        l();
        return;
      }
      Du(v).with({
        type: "message"
        /* MESSAGE */
      }, ({ message: E }) => {
        s(!1), u((y) => [...y, E]), p(b, Jo);
      }).with({
        type: "indicator"
        /* INDICATOR */
      }, ({ messageDelay: E = Jo }) => {
        s(!0), p(b, E);
      }).exhaustive();
    };
    return b(), () => {
      clearTimeout(h);
    };
  }, []), MM(() => {
    t || (n.current = !1, l(), u(e));
  }, [t]), {
    complete: r,
    showIndicator: i,
    visibleMessages: o
  };
}, mv = 1e3, pv = Ot(yt.TYPING_INDICATOR), gv = Ce(pv("span"), {
  display: "inline-flex"
}), bv = Ce(pv("span", "dot"), {
  height: 8,
  width: 8,
  margin: "0 2px",
  borderRadius: "$round",
  backgroundColor: "#adadb3",
  opacity: 0.2,
  animation: `${bC} ${mv}ms`,
  animationIterationCount: "infinite"
}), HM = Math.floor(mv / 3), jM = () => /* @__PURE__ */ J.jsx(gv, { children: Array.from({ length: 3 }).map((e, t) => /* @__PURE__ */ J.jsx(bv, { css: { animationDelay: `${HM * (t + 1)}ms` } }, t)) }), zM = Object.assign(jM, {
  Container: gv,
  Dot: bv
}), Fd = Ot(yt.MESSAGE), Ud = Ce(Fd("div"), {
  display: "inline-block",
  boxSizing: "border-box",
  padding: "10px 14px",
  borderRadius: "$1",
  typo: {},
  overflowWrap: "anywhere"
}), Ev = Ce(Fd(Ud, "chat"), {
  variants: {
    from: {
      system: {
        color: "$black",
        backgroundColor: "$lightGrey"
      },
      user: {
        color: "$white",
        backgroundColor: "$primary",
        whiteSpace: "break-spaces"
      }
    }
  }
});
var Ds = /* @__PURE__ */ ((e) => (e.CHAT = "chat", e.DEBUG = "debug", e))(Ds || {});
const fg = 6, dg = 32, vv = Ce(Fd(Ud, "debug"), {
  position: "relative",
  marginTop: fg,
  border: "1px solid $medGrey",
  padding: "10px 14px",
  backgroundColor: "$white",
  boxShadow: "0 1px 2px $shadow2",
  svg: {
    position: "absolute",
    top: -fg
  },
  variants: {
    orientation: {
      left: {
        svg: {
          left: dg
        }
      },
      right: {
        svg: {
          right: dg
        }
      }
    }
  },
  defaultVariants: {
    orientation: "left"
  }
}), VM = ({ children: e, ...t }) => /* @__PURE__ */ J.jsxs(vv, { ...t, children: [
  /* @__PURE__ */ J.jsx(K1, {}),
  e
] }), Tv = Object.assign(VM, {
  Container: vv
}), GM = {
  [Ds.CHAT]: Ev,
  [Ds.DEBUG]: Tv
}, YM = Z1(GM, Ds.CHAT), Ur = Object.assign(YM, {
  Variant: Ds,
  Container: Ud,
  Chat: Ev,
  Debug: Tv
}), WM = (e) => {
  const t = new Date(e), n = t.getHours(), r = t.getMinutes();
  return `${n % 12 || 12}:${r >= 10 ? "" : "0"}${r} ${n >= 12 ? "pm" : "am"}`;
}, qM = Ot(yt.TIMESTAMP), Av = Ce(qM("div"), {
  typo: { size: 12, height: "17px" },
  color: "$darkGrey",
  whiteSpace: "nowrap",
  flexShrink: 0
}), KM = ({ value: e }) => /* @__PURE__ */ J.jsx(Av, { children: WM(e) }), La = Object.assign(KM, {
  Container: Av
}), Ri = Ot(yt.SYSTEM_RESPONSE), _v = Ce(Ri("div", "actions"), {
  display: "flex",
  flexWrap: "wrap",
  marginBottom: 8,
  padding: "0 $5 0 54px",
  [`& ${Zn.Container}`]: {
    height: "unset",
    paddingTop: 7,
    paddingBottom: 7,
    marginTop: 8,
    marginRight: 8,
    whiteSpace: "normal",
    textAlign: "start"
  }
}), yv = Ce(Ri("span", "controls"), {
  position: "relative"
}), Hd = Ce(Ri("div"), {
  display: "flex",
  [`& ${aa.Container}`]: {
    visibility: "hidden",
    alignSelf: "flex-end",
    margin: "0 8px 4px 0"
  },
  [`& ${La.Container}`]: {
    alignSelf: "center",
    whiteSpace: "nowrap",
    marginLeft: 8,
    opacity: "0%",
    trans: ["opacity"]
  },
  [`&:hover ${La.Container}`]: {
    opacity: "100%"
  },
  variants: {
    withImage: {
      true: {
        [`& ${aa.Container}`]: {
          visibility: "visible"
        }
      }
    },
    scrollable: {
      true: {
        overflowX: "scroll",
        flexShrink: 0,
        scrollbarWidth: "none",
        "-ms-overflow-style": "none",
        "&::-webkit-scrollbar": {
          display: "none"
        }
      }
    },
    center: {
      true: {
        alignItems: "center"
      }
    }
  }
}), XM = Ce(Ri(Hd, "message")), ZM = Ce(Ri(Hd, "indicator")), Sv = Ce(Ri("div", "list"), {
  display: "flex",
  flexDirection: "column",
  flexShrink: 0,
  flex: "inherit",
  [`& ${Ur.Container}`]: {
    marginBottom: "$1",
    "&:last-of-type": {
      marginBottom: 0
    }
  }
}), Cv = ({ avatar: e }) => /* @__PURE__ */ J.jsxs(ZM, { withImage: !0, center: !0, children: [
  /* @__PURE__ */ J.jsx(aa, { avatar: e }),
  /* @__PURE__ */ J.jsx(zM, {})
] }), QM = (e) => {
  const t = e[ya.ITALIC], n = e[ya.UNDERLINE], r = e[ya.STRIKE_THROUGH], a = e[ya.FONT_WEIGHT];
  let { text: i } = e;
  if (!i.trim())
    return i;
  const s = i.match(/^\s+/) || "", o = i.match(/\s+$/) || "";
  return i = i.trim(), t && (i = `*${i}*`), n && (i = `<u>${i}</u>`), r && (i = `~~${i}~~`), a && (i = `**${i}**`), `${s}${i}${o}`;
}, JM = (e) => {
  var t;
  return `[${e.children.map(jd())}](${(t = e.url) === null || t === void 0 ? void 0 : t.replace(/\s+/g, "")})`;
}, e5 = (e) => `{${e.name}}`, t5 = (e) => EE(e) ? JM(e) : vE(e) ? e5(e) : e.children.map(jd()).join(""), jd = () => (e) => (
  // eslint-disable-next-line no-nested-ternary
  $t.isText(e) ? QM(e) : Lr.isElement(e) ? t5(e) : ""
), n5 = (e) => e.map(jd()).join(`
`).replace(/\n{3,}/g, (t) => `
${"<br/>".repeat(t.length - 2)}

`), Ov = -1, Pu = 0, su = 1, ou = 2, zd = 3, Vd = 4, Gd = 5, Yd = 6, Iv = 7, xv = 8, hg = typeof self == "object" ? self : globalThis, r5 = (e, t) => {
  const n = (a, i) => (e.set(i, a), a), r = (a) => {
    if (e.has(a))
      return e.get(a);
    const [i, s] = t[a];
    switch (i) {
      case Pu:
      case Ov:
        return n(s, a);
      case su: {
        const o = n([], a);
        for (const u of s)
          o.push(r(u));
        return o;
      }
      case ou: {
        const o = n({}, a);
        for (const [u, l] of s)
          o[r(u)] = r(l);
        return o;
      }
      case zd:
        return n(new Date(s), a);
      case Vd: {
        const { source: o, flags: u } = s;
        return n(new RegExp(o, u), a);
      }
      case Gd: {
        const o = n(/* @__PURE__ */ new Map(), a);
        for (const [u, l] of s)
          o.set(r(u), r(l));
        return o;
      }
      case Yd: {
        const o = n(/* @__PURE__ */ new Set(), a);
        for (const u of s)
          o.add(r(u));
        return o;
      }
      case Iv: {
        const { name: o, message: u } = s;
        return n(new hg[o](u), a);
      }
      case xv:
        return n(BigInt(s), a);
      case "BigInt":
        return n(Object(BigInt(s)), a);
    }
    return n(new hg[i](s), a);
  };
  return r;
}, mg = (e) => r5(/* @__PURE__ */ new Map(), e)(0), si = "", { toString: a5 } = {}, { keys: i5 } = Object, Ki = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Pu, t];
  const n = a5.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [su, si];
    case "Object":
      return [ou, si];
    case "Date":
      return [zd, si];
    case "RegExp":
      return [Vd, si];
    case "Map":
      return [Gd, si];
    case "Set":
      return [Yd, si];
  }
  return n.includes("Array") ? [su, n] : n.includes("Error") ? [Iv, n] : [ou, n];
}, mo = ([e, t]) => e === Pu && (t === "function" || t === "symbol"), s5 = (e, t, n, r) => {
  const a = (s, o) => {
    const u = r.push(s) - 1;
    return n.set(o, u), u;
  }, i = (s) => {
    if (n.has(s))
      return n.get(s);
    let [o, u] = Ki(s);
    switch (o) {
      case Pu: {
        let f = s;
        switch (u) {
          case "bigint":
            o = xv, f = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + u);
            f = null;
            break;
          case "undefined":
            return a([Ov], s);
        }
        return a([o, f], s);
      }
      case su: {
        if (u)
          return a([u, [...s]], s);
        const f = [], h = a([o, f], s);
        for (const p of s)
          f.push(i(p));
        return h;
      }
      case ou: {
        if (u)
          switch (u) {
            case "BigInt":
              return a([u, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return a([u, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return i(s.toJSON());
        const f = [], h = a([o, f], s);
        for (const p of i5(s))
          (e || !mo(Ki(s[p]))) && f.push([i(p), i(s[p])]);
        return h;
      }
      case zd:
        return a([o, s.toISOString()], s);
      case Vd: {
        const { source: f, flags: h } = s;
        return a([o, { source: f, flags: h }], s);
      }
      case Gd: {
        const f = [], h = a([o, f], s);
        for (const [p, b] of s)
          (e || !(mo(Ki(p)) || mo(Ki(b)))) && f.push([i(p), i(b)]);
        return h;
      }
      case Yd: {
        const f = [], h = a([o, f], s);
        for (const p of s)
          (e || !mo(Ki(p))) && f.push(i(p));
        return h;
      }
    }
    const { message: l } = s;
    return a([o, { name: u, message: l }], s);
  };
  return i;
}, pg = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return s5(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Ma = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? mg(pg(e, t)) : structuredClone(e)
) : (e, t) => mg(pg(e, t));
class js {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
js.prototype.property = {};
js.prototype.normal = {};
js.prototype.space = null;
function Nv(e, t) {
  const n = {}, r = {};
  let a = -1;
  for (; ++a < e.length; )
    Object.assign(n, e[a].property), Object.assign(r, e[a].normal);
  return new js(n, r, t);
}
function Ps(e) {
  return e.toLowerCase();
}
class Jn {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
Jn.prototype.space = null;
Jn.prototype.boolean = !1;
Jn.prototype.booleanish = !1;
Jn.prototype.overloadedBoolean = !1;
Jn.prototype.number = !1;
Jn.prototype.commaSeparated = !1;
Jn.prototype.spaceSeparated = !1;
Jn.prototype.commaOrSpaceSeparated = !1;
Jn.prototype.mustUseProperty = !1;
Jn.prototype.defined = !1;
let o5 = 0;
const Ge = Ua(), Wt = Ua(), Rv = Ua(), ge = Ua(), wt = Ua(), pi = Ua(), $n = Ua();
function Ua() {
  return 2 ** ++o5;
}
const wf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Ge,
  booleanish: Wt,
  commaOrSpaceSeparated: $n,
  commaSeparated: pi,
  number: ge,
  overloadedBoolean: Rv,
  spaceSeparated: wt
}, Symbol.toStringTag, { value: "Module" })), Ml = Object.keys(wf);
class Wd extends Jn {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, a) {
    let i = -1;
    if (super(t, n), gg(this, "space", a), typeof r == "number")
      for (; ++i < Ml.length; ) {
        const s = Ml[i];
        gg(this, Ml[i], (r & wf[s]) === wf[s]);
      }
  }
}
Wd.prototype.defined = !0;
function gg(e, t, n) {
  n && (e[t] = n);
}
const u5 = {}.hasOwnProperty;
function ki(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (u5.call(e.properties, r)) {
      const a = e.properties[r], i = new Wd(
        r,
        e.transform(e.attributes || {}, r),
        a,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (i.mustUseProperty = !0), t[r] = i, n[Ps(r)] = r, n[Ps(i.attribute)] = r;
    }
  return new js(t, n, e.space);
}
const kv = ki({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), wv = ki({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Dv(e, t) {
  return t in e ? e[t] : t;
}
function Pv(e, t) {
  return Dv(e, t.toLowerCase());
}
const Lv = ki({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Pv,
  properties: { xmlns: null, xmlnsXLink: null }
}), Mv = ki({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Wt,
    ariaAutoComplete: null,
    ariaBusy: Wt,
    ariaChecked: Wt,
    ariaColCount: ge,
    ariaColIndex: ge,
    ariaColSpan: ge,
    ariaControls: wt,
    ariaCurrent: null,
    ariaDescribedBy: wt,
    ariaDetails: null,
    ariaDisabled: Wt,
    ariaDropEffect: wt,
    ariaErrorMessage: null,
    ariaExpanded: Wt,
    ariaFlowTo: wt,
    ariaGrabbed: Wt,
    ariaHasPopup: null,
    ariaHidden: Wt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: wt,
    ariaLevel: ge,
    ariaLive: null,
    ariaModal: Wt,
    ariaMultiLine: Wt,
    ariaMultiSelectable: Wt,
    ariaOrientation: null,
    ariaOwns: wt,
    ariaPlaceholder: null,
    ariaPosInSet: ge,
    ariaPressed: Wt,
    ariaReadOnly: Wt,
    ariaRelevant: null,
    ariaRequired: Wt,
    ariaRoleDescription: wt,
    ariaRowCount: ge,
    ariaRowIndex: ge,
    ariaRowSpan: ge,
    ariaSelected: Wt,
    ariaSetSize: ge,
    ariaSort: null,
    ariaValueMax: ge,
    ariaValueMin: ge,
    ariaValueNow: ge,
    ariaValueText: null,
    role: null
  }
}), l5 = ki({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Pv,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: pi,
    acceptCharset: wt,
    accessKey: wt,
    action: null,
    allow: null,
    allowFullScreen: Ge,
    allowPaymentRequest: Ge,
    allowUserMedia: Ge,
    alt: null,
    as: null,
    async: Ge,
    autoCapitalize: null,
    autoComplete: wt,
    autoFocus: Ge,
    autoPlay: Ge,
    capture: Ge,
    charSet: null,
    checked: Ge,
    cite: null,
    className: wt,
    cols: ge,
    colSpan: null,
    content: null,
    contentEditable: Wt,
    controls: Ge,
    controlsList: wt,
    coords: ge | pi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Ge,
    defer: Ge,
    dir: null,
    dirName: null,
    disabled: Ge,
    download: Rv,
    draggable: Wt,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Ge,
    formTarget: null,
    headers: wt,
    height: ge,
    hidden: Ge,
    high: ge,
    href: null,
    hrefLang: null,
    htmlFor: wt,
    httpEquiv: wt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Ge,
    itemId: null,
    itemProp: wt,
    itemRef: wt,
    itemScope: Ge,
    itemType: wt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Ge,
    low: ge,
    manifest: null,
    max: null,
    maxLength: ge,
    media: null,
    method: null,
    min: null,
    minLength: ge,
    multiple: Ge,
    muted: Ge,
    name: null,
    nonce: null,
    noModule: Ge,
    noValidate: Ge,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Ge,
    optimum: ge,
    pattern: null,
    ping: wt,
    placeholder: null,
    playsInline: Ge,
    poster: null,
    preload: null,
    readOnly: Ge,
    referrerPolicy: null,
    rel: wt,
    required: Ge,
    reversed: Ge,
    rows: ge,
    rowSpan: ge,
    sandbox: wt,
    scope: null,
    scoped: Ge,
    seamless: Ge,
    selected: Ge,
    shape: null,
    size: ge,
    sizes: null,
    slot: null,
    span: ge,
    spellCheck: Wt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: ge,
    step: null,
    style: null,
    tabIndex: ge,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Ge,
    useMap: null,
    value: Wt,
    width: ge,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: wt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: ge,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: ge,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Ge,
    // Lists. Use CSS to reduce space between items instead
    declare: Ge,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: ge,
    // `<img>` and `<object>`
    leftMargin: ge,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: ge,
    // `<body>`
    marginWidth: ge,
    // `<body>`
    noResize: Ge,
    // `<frame>`
    noHref: Ge,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Ge,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Ge,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: ge,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Wt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: ge,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: ge,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Ge,
    disableRemotePlayback: Ge,
    prefix: null,
    property: null,
    results: ge,
    security: null,
    unselectable: null
  }
}), c5 = ki({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Dv,
  properties: {
    about: $n,
    accentHeight: ge,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: ge,
    amplitude: ge,
    arabicForm: null,
    ascent: ge,
    attributeName: null,
    attributeType: null,
    azimuth: ge,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: ge,
    by: null,
    calcMode: null,
    capHeight: ge,
    className: wt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: ge,
    diffuseConstant: ge,
    direction: null,
    display: null,
    dur: null,
    divisor: ge,
    dominantBaseline: null,
    download: Ge,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: ge,
    enableBackground: null,
    end: null,
    event: null,
    exponent: ge,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: ge,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: pi,
    g2: pi,
    glyphName: pi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: ge,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: ge,
    horizOriginX: ge,
    horizOriginY: ge,
    id: null,
    ideographic: ge,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: ge,
    k: ge,
    k1: ge,
    k2: ge,
    k3: ge,
    k4: ge,
    kernelMatrix: $n,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: ge,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: ge,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: ge,
    overlineThickness: ge,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: ge,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: wt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: ge,
    pointsAtY: ge,
    pointsAtZ: ge,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: $n,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: $n,
    rev: $n,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: $n,
    requiredFeatures: $n,
    requiredFonts: $n,
    requiredFormats: $n,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: ge,
    specularExponent: ge,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: ge,
    strikethroughThickness: ge,
    string: null,
    stroke: null,
    strokeDashArray: $n,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: ge,
    strokeOpacity: ge,
    strokeWidth: null,
    style: null,
    surfaceScale: ge,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: $n,
    tabIndex: ge,
    tableValues: null,
    target: null,
    targetX: ge,
    targetY: ge,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: $n,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: ge,
    underlineThickness: ge,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: ge,
    values: null,
    vAlphabetic: ge,
    vMathematical: ge,
    vectorEffect: null,
    vHanging: ge,
    vIdeographic: ge,
    version: null,
    vertAdvY: ge,
    vertOriginX: ge,
    vertOriginY: ge,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: ge,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), f5 = /^data[-\w.:]+$/i, bg = /-[a-z]/g, d5 = /[A-Z]/g;
function Lu(e, t) {
  const n = Ps(t);
  let r = t, a = Jn;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && f5.test(t)) {
    if (t.charAt(4) === "-") {
      const i = t.slice(5).replace(bg, m5);
      r = "data" + i.charAt(0).toUpperCase() + i.slice(1);
    } else {
      const i = t.slice(4);
      if (!bg.test(i)) {
        let s = i.replace(d5, h5);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    a = Wd;
  }
  return new a(r, t);
}
function h5(e) {
  return "-" + e.toLowerCase();
}
function m5(e) {
  return e.charAt(1).toUpperCase();
}
const p5 = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, zs = Nv([wv, kv, Lv, Mv, l5], "html"), Ha = Nv([wv, kv, Lv, Mv, c5], "svg");
function Eg(e) {
  const t = [], n = String(e || "");
  let r = n.indexOf(","), a = 0, i = !1;
  for (; !i; ) {
    r === -1 && (r = n.length, i = !0);
    const s = n.slice(a, r).trim();
    (s || !i) && t.push(s), a = r + 1, r = n.indexOf(",", a);
  }
  return t;
}
function $v(e, t) {
  const n = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const vg = /[#.]/g;
function g5(e, t) {
  const n = e || "", r = {};
  let a = 0, i, s;
  for (; a < n.length; ) {
    vg.lastIndex = a;
    const o = vg.exec(n), u = n.slice(a, o ? o.index : n.length);
    u && (i ? i === "#" ? r.id = u : Array.isArray(r.className) ? r.className.push(u) : r.className = [u] : s = u, a += u.length), o && (i = o[0], a++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: s || t || "div",
    properties: r,
    children: []
  };
}
function Tg(e) {
  const t = String(e || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function Bv(e) {
  return e.join(" ").trim();
}
const b5 = /* @__PURE__ */ new Set(["button", "menu", "reset", "submit"]), Df = {}.hasOwnProperty;
function Fv(e, t, n) {
  const r = n && A5(n);
  function a(i, s, ...o) {
    let u = -1, l;
    if (i == null) {
      l = { type: "root", children: [] };
      const f = (
        /** @type {Child} */
        s
      );
      o.unshift(f);
    } else if (l = g5(i, t), l.tagName = l.tagName.toLowerCase(), r && Df.call(r, l.tagName) && (l.tagName = r[l.tagName]), E5(s, l.tagName)) {
      let f;
      for (f in s)
        Df.call(s, f) && v5(e, l.properties, f, s[f]);
    } else
      o.unshift(s);
    for (; ++u < o.length; )
      Pf(l.children, o[u]);
    return l.type === "element" && l.tagName === "template" && (l.content = { type: "root", children: l.children }, l.children = []), l;
  }
  return a;
}
function E5(e, t) {
  return e == null || typeof e != "object" || Array.isArray(e) ? !1 : t === "input" || !e.type || typeof e.type != "string" ? !0 : "children" in e && Array.isArray(e.children) ? !1 : t === "button" ? b5.has(e.type.toLowerCase()) : !("value" in e);
}
function v5(e, t, n, r) {
  const a = Lu(e, n);
  let i = -1, s;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r))
        return;
      s = r;
    } else
      typeof r == "boolean" ? s = r : typeof r == "string" ? a.spaceSeparated ? s = Tg(r) : a.commaSeparated ? s = Eg(r) : a.commaOrSpaceSeparated ? s = Tg(Eg(r).join(" ")) : s = Ag(a, a.property, r) : Array.isArray(r) ? s = r.concat() : s = a.property === "style" ? T5(r) : String(r);
    if (Array.isArray(s)) {
      const o = [];
      for (; ++i < s.length; ) {
        const u = (
          /** @type {number | string} */
          Ag(a, a.property, s[i])
        );
        o[i] = u;
      }
      s = o;
    }
    if (a.property === "className" && Array.isArray(t.className)) {
      const o = (
        /** @type {number | string} */
        s
      );
      s = t.className.concat(o);
    }
    t[a.property] = s;
  }
}
function Pf(e, t) {
  let n = -1;
  if (t != null)
    if (typeof t == "string" || typeof t == "number")
      e.push({ type: "text", value: String(t) });
    else if (Array.isArray(t))
      for (; ++n < t.length; )
        Pf(e, t[n]);
    else if (typeof t == "object" && "type" in t)
      t.type === "root" ? Pf(e, t.children) : e.push(t);
    else
      throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function Ag(e, t, n) {
  if (typeof n == "string") {
    if (e.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((e.boolean || e.overloadedBoolean) && (n === "" || Ps(n) === Ps(t)))
      return !0;
  }
  return n;
}
function T5(e) {
  const t = [];
  let n;
  for (n in e)
    Df.call(e, n) && t.push([n, e[n]].join(": "));
  return t.join("; ");
}
function A5(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    t[e[n].toLowerCase()] = e[n];
  return t;
}
const _5 = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], y5 = Fv(zs, "div"), S5 = Fv(Ha, "g", _5), $l = /\r?\n|\r/g;
function C5(e) {
  const t = String(e), n = [];
  for ($l.lastIndex = 0; $l.test(t); )
    n.push($l.lastIndex);
  return n.push(t.length + 1), { toPoint: r, toOffset: a };
  function r(i) {
    let s = -1;
    if (typeof i == "number" && i > -1 && i < n[n.length - 1]) {
      for (; ++s < n.length; )
        if (n[s] > i)
          return {
            line: s + 1,
            column: i - (s > 0 ? n[s - 1] : 0) + 1,
            offset: i
          };
    }
  }
  function a(i) {
    const s = i && i.line, o = i && i.column;
    if (typeof s == "number" && typeof o == "number" && !Number.isNaN(s) && !Number.isNaN(o) && s - 1 in n) {
      const u = (n[s - 2] || 0) + o - 1 || 0;
      if (u > -1 && u < n[n.length - 1])
        return u;
    }
  }
}
const Sa = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, Uv = {}.hasOwnProperty, O5 = Object.prototype;
function I5(e, t) {
  const n = t || {};
  return qd(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? Ha : zs,
      verbose: n.verbose || !1
    },
    e
  );
}
function qd(e, t) {
  let n;
  switch (t.nodeName) {
    case "#comment": {
      const r = (
        /** @type {P5Comment} */
        t
      );
      return n = { type: "comment", value: r.data }, Co(e, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {P5Document | P5DocumentFragment} */
        t
      ), a = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: Hv(e, t.childNodes),
        data: { quirksMode: a }
      }, e.file && e.location) {
        const i = String(e.file), s = C5(i), o = s.toPoint(0), u = s.toPoint(i.length);
        n.position = { start: o, end: u };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {P5DocumentType} */
        t
      );
      return n = { type: "doctype" }, Co(e, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {P5Text} */
        t
      );
      return n = { type: "text", value: r.value }, Co(e, r, n), n;
    }
    default:
      return n = x5(
        e,
        /** @type {P5Element} */
        t
      ), n;
  }
}
function Hv(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; ) {
    const a = (
      /** @type {RootContent} */
      qd(e, t[n])
    );
    r.push(a);
  }
  return r;
}
function x5(e, t) {
  const n = e.schema;
  e.schema = t.namespaceURI === Sa.svg ? Ha : zs;
  let r = -1;
  const a = {};
  for (; ++r < t.attrs.length; ) {
    const o = t.attrs[r], u = (o.prefix ? o.prefix + ":" : "") + o.name;
    Uv.call(O5, u) || (a[u] = o.value);
  }
  const s = (e.schema.space === "svg" ? S5 : y5)(t.tagName, a, Hv(e, t.childNodes));
  if (Co(e, t, s), s.tagName === "template") {
    const o = (
      /** @type {P5Template} */
      t
    ), u = o.sourceCodeLocation, l = u && u.startTag && di(u.startTag), f = u && u.endTag && di(u.endTag), h = (
      /** @type {Root} */
      qd(e, o.content)
    );
    l && f && e.file && (h.position = { start: l.end, end: f.start }), s.content = h;
  }
  return e.schema = n, s;
}
function Co(e, t, n) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const r = N5(e, n, t.sourceCodeLocation);
    r && (e.location = !0, n.position = r);
  }
}
function N5(e, t, n) {
  const r = di(n);
  if (t.type === "element") {
    const a = t.children[t.children.length - 1];
    if (r && !n.endTag && a && a.position && a.position.end && (r.end = Object.assign({}, a.position.end)), e.verbose) {
      const i = {};
      let s;
      if (n.attrs)
        for (s in n.attrs)
          Uv.call(n.attrs, s) && (i[Lu(e.schema, s).property] = di(
            n.attrs[s]
          ));
      n.startTag;
      const o = di(n.startTag), u = n.endTag ? di(n.endTag) : void 0, l = { opening: o };
      u && (l.closing = u), l.properties = i, t.data = { position: l };
    }
  }
  return r;
}
function di(e) {
  const t = _g({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), n = _g({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || n ? { start: t, end: n } : void 0;
}
function _g(e) {
  return e.line && e.column ? e : void 0;
}
var yg = {}.hasOwnProperty;
function jv(e, t) {
  var n = t || {};
  function r(a) {
    var i = r.invalid, s = r.handlers;
    if (a && yg.call(a, e) && (i = yg.call(s, a[e]) ? s[a[e]] : r.unknown), i)
      return i.apply(this, arguments);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const R5 = {}, k5 = {}.hasOwnProperty, zv = jv("type", { handlers: { root: D5, element: B5, text: M5, comment: $5, doctype: L5 } });
function w5(e, t) {
  const r = (t || R5).space;
  return zv(e, r === "svg" ? Ha : zs);
}
function D5(e, t) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = Kd(e.children, n, t), wi(e, n), n;
}
function P5(e, t) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = Kd(e.children, n, t), wi(e, n), n;
}
function L5(e) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return wi(e, t), t;
}
function M5(e) {
  const t = {
    nodeName: "#text",
    value: e.value,
    parentNode: null
  };
  return wi(e, t), t;
}
function $5(e) {
  const t = {
    nodeName: "#comment",
    data: e.value,
    parentNode: null
  };
  return wi(e, t), t;
}
function B5(e, t) {
  const n = t;
  let r = n;
  e.type === "element" && e.tagName.toLowerCase() === "svg" && n.space === "html" && (r = Ha);
  const a = [];
  let i;
  if (e.properties) {
    for (i in e.properties)
      if (i !== "children" && k5.call(e.properties, i)) {
        const u = F5(
          r,
          i,
          e.properties[i]
        );
        u && a.push(u);
      }
  }
  const s = r.space, o = {
    nodeName: e.tagName,
    tagName: e.tagName,
    attrs: a,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: Sa[s],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = Kd(e.children, o, r), wi(e, o), e.tagName === "template" && e.content && (o.content = P5(e.content, r)), o;
}
function F5(e, t, n) {
  const r = Lu(e, t);
  if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? $v(n) : Bv(n));
  const a = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const i = a.name.indexOf(":");
    i < 0 ? a.prefix = "" : (a.name = a.name.slice(i + 1), a.prefix = r.attribute.slice(0, i)), a.namespace = Sa[r.space];
  }
  return a;
}
function Kd(e, t, n) {
  let r = -1;
  const a = [];
  if (e)
    for (; ++r < e.length; ) {
      const i = zv(e[r], n);
      i.parentNode = t, a.push(i);
    }
  return a;
}
function wi(e, t) {
  const n = e.position;
  n && n.start && n.end && (n.start.offset, n.end.offset, t.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
const U5 = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], H5 = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), Lt = "";
var S;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.NUMBER_SIGN = 35] = "NUMBER_SIGN", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_F = 70] = "LATIN_CAPITAL_F", e[e.LATIN_CAPITAL_X = 88] = "LATIN_CAPITAL_X", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_F = 102] = "LATIN_SMALL_F", e[e.LATIN_SMALL_X = 120] = "LATIN_SMALL_X", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z", e[e.REPLACEMENT_CHARACTER = 65533] = "REPLACEMENT_CHARACTER";
})(S = S || (S = {}));
const xn = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function Vv(e) {
  return e >= 55296 && e <= 57343;
}
function j5(e) {
  return e >= 56320 && e <= 57343;
}
function z5(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function Gv(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function Yv(e) {
  return e >= 64976 && e <= 65007 || H5.has(e);
}
var te;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(te = te || (te = {}));
const V5 = 65536;
class G5 {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = V5, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t) {
    const { line: n, col: r, offset: a } = this;
    return {
      code: t,
      startLine: n,
      endLine: n,
      startCol: r,
      endCol: r,
      startOffset: a,
      endOffset: a
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (j5(n))
        return this.pos++, this._addGap(), z5(t, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, S.EOF;
    return this._err(te.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, n) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, n) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(t, this.pos);
    for (let r = 0; r < t.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(t) {
    const n = this.pos + t;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, S.EOF;
    const r = this.html.charCodeAt(n);
    return r === S.CARRIAGE_RETURN ? S.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, S.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === S.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, S.LINE_FEED) : t === S.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, Vv(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === S.LINE_FEED || t === S.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    Gv(t) ? this._err(te.controlCharacterInInputStream) : Yv(t) && this._err(te.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var Ze;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(Ze = Ze || (Ze = {}));
function Wv(e, t) {
  for (let n = e.attrs.length - 1; n >= 0; n--)
    if (e.attrs[n].name === t)
      return e.attrs[n].value;
  return null;
}
const Zr = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((e) => e.charCodeAt(0))
), Y5 = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((e) => e.charCodeAt(0))
);
var Bl;
const W5 = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), q5 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Bl = String.fromCodePoint) !== null && Bl !== void 0 ? Bl : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function K5(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = W5.get(e)) !== null && t !== void 0 ? t : e;
}
var en;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(en || (en = {}));
const X5 = 32;
var _r;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(_r || (_r = {}));
function Lf(e) {
  return e >= en.ZERO && e <= en.NINE;
}
function Z5(e) {
  return e >= en.UPPER_A && e <= en.UPPER_F || e >= en.LOWER_A && e <= en.LOWER_F;
}
function Q5(e) {
  return e >= en.UPPER_A && e <= en.UPPER_Z || e >= en.LOWER_A && e <= en.LOWER_Z || Lf(e);
}
function J5(e) {
  return e === en.EQUALS || Q5(e);
}
var Jt;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(Jt || (Jt = {}));
var Ta;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(Ta || (Ta = {}));
class e8 {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = Jt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Ta.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = Jt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case Jt.EntityStart:
        return t.charCodeAt(n) === en.NUM ? (this.state = Jt.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = Jt.NamedEntity, this.stateNamedEntity(t, n));
      case Jt.NumericStart:
        return this.stateNumericStart(t, n);
      case Jt.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case Jt.NumericHex:
        return this.stateNumericHex(t, n);
      case Jt.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | X5) === en.LOWER_X ? (this.state = Jt.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = Jt.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, a) {
    if (n !== r) {
      const i = r - n;
      this.result = this.result * Math.pow(a, i) + parseInt(t.substr(n, i), a), this.consumed += i;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const a = t.charCodeAt(n);
      if (Lf(a) || Z5(a))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(a, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const a = t.charCodeAt(n);
      if (Lf(a))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(a, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === en.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Ta.Strict)
      return 0;
    return this.emitCodePoint(K5(this.result), this.consumed), this.errors && (t !== en.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let a = r[this.treeIndex], i = (a & _r.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const s = t.charCodeAt(n);
      if (this.treeIndex = Kv(r, a, this.treeIndex + Math.max(1, i), s), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Ta.Attribute && // We shouldn't have consumed any characters after the entity,
        (i === 0 || // And there should be no invalid characters.
        J5(s)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (a = r[this.treeIndex], i = (a & _r.VALUE_LENGTH) >> 14, i !== 0) {
        if (s === en.SEMI)
          return this.emitNamedEntityData(this.treeIndex, i, this.consumed + this.excess);
        this.decodeMode !== Ta.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, a = (r[n] & _r.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, a, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: a } = this;
    return this.emitCodePoint(n === 1 ? a[t] & ~_r.VALUE_LENGTH : a[t + 1], r), n === 3 && this.emitCodePoint(a[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case Jt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Ta.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case Jt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Jt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Jt.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Jt.EntityStart:
        return 0;
    }
  }
}
function qv(e) {
  let t = "";
  const n = new e8(e, (r) => t += q5(r));
  return function(a, i) {
    let s = 0, o = 0;
    for (; (o = a.indexOf("&", o)) >= 0; ) {
      t += a.slice(s, o), n.startEntity(i);
      const l = n.write(
        a,
        // Skip the "&"
        o + 1
      );
      if (l < 0) {
        s = o + n.end();
        break;
      }
      s = o + l, o = l === 0 ? s + 1 : s;
    }
    const u = t + a.slice(s);
    return t = "", u;
  };
}
function Kv(e, t, n, r) {
  const a = (t & _r.BRANCH_LENGTH) >> 7, i = t & _r.JUMP_TABLE;
  if (a === 0)
    return i !== 0 && r === i ? n : -1;
  if (i) {
    const u = r - i;
    return u < 0 || u >= a ? -1 : e[n + u] - 1;
  }
  let s = n, o = s + a - 1;
  for (; s <= o; ) {
    const u = s + o >>> 1, l = e[u];
    if (l < r)
      s = u + 1;
    else if (l > r)
      o = u - 1;
    else
      return e[u + a];
  }
  return -1;
}
qv(Zr);
qv(Y5);
var ae;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(ae = ae || (ae = {}));
var na;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(na = na || (na = {}));
var Bn;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(Bn = Bn || (Bn = {}));
var K;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(K = K || (K = {}));
var c;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SECTION = 94] = "SECTION", e[e.SELECT = 95] = "SELECT", e[e.SOURCE = 96] = "SOURCE", e[e.SMALL = 97] = "SMALL", e[e.SPAN = 98] = "SPAN", e[e.STRIKE = 99] = "STRIKE", e[e.STRONG = 100] = "STRONG", e[e.STYLE = 101] = "STYLE", e[e.SUB = 102] = "SUB", e[e.SUMMARY = 103] = "SUMMARY", e[e.SUP = 104] = "SUP", e[e.TABLE = 105] = "TABLE", e[e.TBODY = 106] = "TBODY", e[e.TEMPLATE = 107] = "TEMPLATE", e[e.TEXTAREA = 108] = "TEXTAREA", e[e.TFOOT = 109] = "TFOOT", e[e.TD = 110] = "TD", e[e.TH = 111] = "TH", e[e.THEAD = 112] = "THEAD", e[e.TITLE = 113] = "TITLE", e[e.TR = 114] = "TR", e[e.TRACK = 115] = "TRACK", e[e.TT = 116] = "TT", e[e.U = 117] = "U", e[e.UL = 118] = "UL", e[e.SVG = 119] = "SVG", e[e.VAR = 120] = "VAR", e[e.WBR = 121] = "WBR", e[e.XMP = 122] = "XMP";
})(c = c || (c = {}));
const t8 = /* @__PURE__ */ new Map([
  [K.A, c.A],
  [K.ADDRESS, c.ADDRESS],
  [K.ANNOTATION_XML, c.ANNOTATION_XML],
  [K.APPLET, c.APPLET],
  [K.AREA, c.AREA],
  [K.ARTICLE, c.ARTICLE],
  [K.ASIDE, c.ASIDE],
  [K.B, c.B],
  [K.BASE, c.BASE],
  [K.BASEFONT, c.BASEFONT],
  [K.BGSOUND, c.BGSOUND],
  [K.BIG, c.BIG],
  [K.BLOCKQUOTE, c.BLOCKQUOTE],
  [K.BODY, c.BODY],
  [K.BR, c.BR],
  [K.BUTTON, c.BUTTON],
  [K.CAPTION, c.CAPTION],
  [K.CENTER, c.CENTER],
  [K.CODE, c.CODE],
  [K.COL, c.COL],
  [K.COLGROUP, c.COLGROUP],
  [K.DD, c.DD],
  [K.DESC, c.DESC],
  [K.DETAILS, c.DETAILS],
  [K.DIALOG, c.DIALOG],
  [K.DIR, c.DIR],
  [K.DIV, c.DIV],
  [K.DL, c.DL],
  [K.DT, c.DT],
  [K.EM, c.EM],
  [K.EMBED, c.EMBED],
  [K.FIELDSET, c.FIELDSET],
  [K.FIGCAPTION, c.FIGCAPTION],
  [K.FIGURE, c.FIGURE],
  [K.FONT, c.FONT],
  [K.FOOTER, c.FOOTER],
  [K.FOREIGN_OBJECT, c.FOREIGN_OBJECT],
  [K.FORM, c.FORM],
  [K.FRAME, c.FRAME],
  [K.FRAMESET, c.FRAMESET],
  [K.H1, c.H1],
  [K.H2, c.H2],
  [K.H3, c.H3],
  [K.H4, c.H4],
  [K.H5, c.H5],
  [K.H6, c.H6],
  [K.HEAD, c.HEAD],
  [K.HEADER, c.HEADER],
  [K.HGROUP, c.HGROUP],
  [K.HR, c.HR],
  [K.HTML, c.HTML],
  [K.I, c.I],
  [K.IMG, c.IMG],
  [K.IMAGE, c.IMAGE],
  [K.INPUT, c.INPUT],
  [K.IFRAME, c.IFRAME],
  [K.KEYGEN, c.KEYGEN],
  [K.LABEL, c.LABEL],
  [K.LI, c.LI],
  [K.LINK, c.LINK],
  [K.LISTING, c.LISTING],
  [K.MAIN, c.MAIN],
  [K.MALIGNMARK, c.MALIGNMARK],
  [K.MARQUEE, c.MARQUEE],
  [K.MATH, c.MATH],
  [K.MENU, c.MENU],
  [K.META, c.META],
  [K.MGLYPH, c.MGLYPH],
  [K.MI, c.MI],
  [K.MO, c.MO],
  [K.MN, c.MN],
  [K.MS, c.MS],
  [K.MTEXT, c.MTEXT],
  [K.NAV, c.NAV],
  [K.NOBR, c.NOBR],
  [K.NOFRAMES, c.NOFRAMES],
  [K.NOEMBED, c.NOEMBED],
  [K.NOSCRIPT, c.NOSCRIPT],
  [K.OBJECT, c.OBJECT],
  [K.OL, c.OL],
  [K.OPTGROUP, c.OPTGROUP],
  [K.OPTION, c.OPTION],
  [K.P, c.P],
  [K.PARAM, c.PARAM],
  [K.PLAINTEXT, c.PLAINTEXT],
  [K.PRE, c.PRE],
  [K.RB, c.RB],
  [K.RP, c.RP],
  [K.RT, c.RT],
  [K.RTC, c.RTC],
  [K.RUBY, c.RUBY],
  [K.S, c.S],
  [K.SCRIPT, c.SCRIPT],
  [K.SECTION, c.SECTION],
  [K.SELECT, c.SELECT],
  [K.SOURCE, c.SOURCE],
  [K.SMALL, c.SMALL],
  [K.SPAN, c.SPAN],
  [K.STRIKE, c.STRIKE],
  [K.STRONG, c.STRONG],
  [K.STYLE, c.STYLE],
  [K.SUB, c.SUB],
  [K.SUMMARY, c.SUMMARY],
  [K.SUP, c.SUP],
  [K.TABLE, c.TABLE],
  [K.TBODY, c.TBODY],
  [K.TEMPLATE, c.TEMPLATE],
  [K.TEXTAREA, c.TEXTAREA],
  [K.TFOOT, c.TFOOT],
  [K.TD, c.TD],
  [K.TH, c.TH],
  [K.THEAD, c.THEAD],
  [K.TITLE, c.TITLE],
  [K.TR, c.TR],
  [K.TRACK, c.TRACK],
  [K.TT, c.TT],
  [K.U, c.U],
  [K.UL, c.UL],
  [K.SVG, c.SVG],
  [K.VAR, c.VAR],
  [K.WBR, c.WBR],
  [K.XMP, c.XMP]
]);
function Di(e) {
  var t;
  return (t = t8.get(e)) !== null && t !== void 0 ? t : c.UNKNOWN;
}
const ce = c, n8 = {
  [ae.HTML]: /* @__PURE__ */ new Set([
    ce.ADDRESS,
    ce.APPLET,
    ce.AREA,
    ce.ARTICLE,
    ce.ASIDE,
    ce.BASE,
    ce.BASEFONT,
    ce.BGSOUND,
    ce.BLOCKQUOTE,
    ce.BODY,
    ce.BR,
    ce.BUTTON,
    ce.CAPTION,
    ce.CENTER,
    ce.COL,
    ce.COLGROUP,
    ce.DD,
    ce.DETAILS,
    ce.DIR,
    ce.DIV,
    ce.DL,
    ce.DT,
    ce.EMBED,
    ce.FIELDSET,
    ce.FIGCAPTION,
    ce.FIGURE,
    ce.FOOTER,
    ce.FORM,
    ce.FRAME,
    ce.FRAMESET,
    ce.H1,
    ce.H2,
    ce.H3,
    ce.H4,
    ce.H5,
    ce.H6,
    ce.HEAD,
    ce.HEADER,
    ce.HGROUP,
    ce.HR,
    ce.HTML,
    ce.IFRAME,
    ce.IMG,
    ce.INPUT,
    ce.LI,
    ce.LINK,
    ce.LISTING,
    ce.MAIN,
    ce.MARQUEE,
    ce.MENU,
    ce.META,
    ce.NAV,
    ce.NOEMBED,
    ce.NOFRAMES,
    ce.NOSCRIPT,
    ce.OBJECT,
    ce.OL,
    ce.P,
    ce.PARAM,
    ce.PLAINTEXT,
    ce.PRE,
    ce.SCRIPT,
    ce.SECTION,
    ce.SELECT,
    ce.SOURCE,
    ce.STYLE,
    ce.SUMMARY,
    ce.TABLE,
    ce.TBODY,
    ce.TD,
    ce.TEMPLATE,
    ce.TEXTAREA,
    ce.TFOOT,
    ce.TH,
    ce.THEAD,
    ce.TITLE,
    ce.TR,
    ce.TRACK,
    ce.UL,
    ce.WBR,
    ce.XMP
  ]),
  [ae.MATHML]: /* @__PURE__ */ new Set([ce.MI, ce.MO, ce.MN, ce.MS, ce.MTEXT, ce.ANNOTATION_XML]),
  [ae.SVG]: /* @__PURE__ */ new Set([ce.TITLE, ce.FOREIGN_OBJECT, ce.DESC]),
  [ae.XLINK]: /* @__PURE__ */ new Set(),
  [ae.XML]: /* @__PURE__ */ new Set(),
  [ae.XMLNS]: /* @__PURE__ */ new Set()
};
function Xv(e) {
  return e === ce.H1 || e === ce.H2 || e === ce.H3 || e === ce.H4 || e === ce.H5 || e === ce.H6;
}
K.STYLE, K.SCRIPT, K.XMP, K.IFRAME, K.NOEMBED, K.NOFRAMES, K.PLAINTEXT;
const r8 = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var x;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.NAMED_CHARACTER_REFERENCE = 72] = "NAMED_CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 73] = "AMBIGUOUS_AMPERSAND", e[e.NUMERIC_CHARACTER_REFERENCE = 74] = "NUMERIC_CHARACTER_REFERENCE", e[e.HEXADEMICAL_CHARACTER_REFERENCE_START = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START", e[e.HEXADEMICAL_CHARACTER_REFERENCE = 76] = "HEXADEMICAL_CHARACTER_REFERENCE", e[e.DECIMAL_CHARACTER_REFERENCE = 77] = "DECIMAL_CHARACTER_REFERENCE", e[e.NUMERIC_CHARACTER_REFERENCE_END = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(x || (x = {}));
const zt = {
  DATA: x.DATA,
  RCDATA: x.RCDATA,
  RAWTEXT: x.RAWTEXT,
  SCRIPT_DATA: x.SCRIPT_DATA,
  PLAINTEXT: x.PLAINTEXT,
  CDATA_SECTION: x.CDATA_SECTION
};
function as(e) {
  return e >= S.DIGIT_0 && e <= S.DIGIT_9;
}
function ts(e) {
  return e >= S.LATIN_CAPITAL_A && e <= S.LATIN_CAPITAL_Z;
}
function a8(e) {
  return e >= S.LATIN_SMALL_A && e <= S.LATIN_SMALL_Z;
}
function Qr(e) {
  return a8(e) || ts(e);
}
function Mf(e) {
  return Qr(e) || as(e);
}
function Zv(e) {
  return e >= S.LATIN_CAPITAL_A && e <= S.LATIN_CAPITAL_F;
}
function Qv(e) {
  return e >= S.LATIN_SMALL_A && e <= S.LATIN_SMALL_F;
}
function i8(e) {
  return as(e) || Zv(e) || Qv(e);
}
function po(e) {
  return e + 32;
}
function Jv(e) {
  return e === S.SPACE || e === S.LINE_FEED || e === S.TABULATION || e === S.FORM_FEED;
}
function s8(e) {
  return e === S.EQUALS_SIGN || Mf(e);
}
function Sg(e) {
  return Jv(e) || e === S.SOLIDUS || e === S.GREATER_THAN_SIGN;
}
class o8 {
  constructor(t, n) {
    this.options = t, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = x.DATA, this.returnState = x.DATA, this.charRefCode = -1, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new G5(n), this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(t) {
    var n, r;
    (r = (n = this.handler).onParseError) === null || r === void 0 || r.call(n, this.preprocessor.getError(t));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t());
  }
  write(t, n, r) {
    this.active = !0, this.preprocessor.write(t, n), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this._unconsume(this.consumedAfterSnapshot), this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _unconsume(t) {
    this.consumedAfterSnapshot -= t, this.preprocessor.retreat(t);
  }
  _reconsumeInState(t, n) {
    this.state = t, this._callState(n);
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let n = 0; n < t; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, n) {
    return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: Ze.START_TAG,
      tagName: "",
      tagID: c.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: Ze.END_TAG,
      tagName: "",
      tagID: c.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: Ze.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: Ze.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, n) {
    this.currentCharacterToken = {
      type: t,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, n;
    const r = this.currentToken;
    if (Wv(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const a = (t = (n = r.location).attrs) !== null && t !== void 0 ? t : n.attrs = /* @__PURE__ */ Object.create(null);
        a[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(te.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = Di(t.tagName), t.type === Ze.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(te.endTagWithAttributes), t.selfClosing && this._err(te.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case Ze.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case Ze.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case Ze.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: Ze.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type !== t)
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
      else {
        this.currentCharacterToken.chars += n;
        return;
      }
    this._createCharacterToken(t, n);
  }
  _emitCodePoint(t) {
    const n = Jv(t) ? Ze.WHITESPACE_CHARACTER : t === S.NULL ? Ze.NULL_CHARACTER : Ze.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(Ze.CHARACTER, t);
  }
  // Character reference helpers
  _matchNamedCharacterReference(t) {
    let n = null, r = 0, a = !1;
    for (let i = 0, s = Zr[0]; i >= 0 && (i = Kv(Zr, s, i + 1, t), !(i < 0)); t = this._consume()) {
      r += 1, s = Zr[i];
      const o = s & _r.VALUE_LENGTH;
      if (o) {
        const u = (o >> 14) - 1;
        if (t !== S.SEMICOLON && this._isCharacterReferenceInAttribute() && s8(this.preprocessor.peek(1)) ? (n = [S.AMPERSAND], i += u) : (n = u === 0 ? [Zr[i] & ~_r.VALUE_LENGTH] : u === 1 ? [Zr[++i]] : [Zr[++i], Zr[++i]], r = 0, a = t !== S.SEMICOLON), u === 0) {
          this._consume();
          break;
        }
      }
    }
    return this._unconsume(r), a && !this.preprocessor.endOfChunkHit && this._err(te.missingSemicolonAfterCharacterReference), this._unconsume(1), n;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === x.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === x.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === x.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case x.DATA: {
        this._stateData(t);
        break;
      }
      case x.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case x.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case x.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case x.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case x.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case x.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case x.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case x.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case x.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case x.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case x.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case x.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case x.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case x.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case x.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case x.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case x.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case x.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case x.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case x.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case x.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case x.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case x.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case x.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case x.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case x.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case x.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case x.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case x.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case x.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case x.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case x.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case x.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case x.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case x.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case x.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case x.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case x.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case x.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case x.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case x.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case x.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case x.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case x.COMMENT: {
        this._stateComment(t);
        break;
      }
      case x.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case x.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case x.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case x.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case x.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case x.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case x.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case x.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case x.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case x.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case x.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case x.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case x.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case x.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case x.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case x.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case x.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case x.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case x.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case x.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case x.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case x.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case x.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case x.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case x.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case x.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case x.CHARACTER_REFERENCE: {
        this._stateCharacterReference(t);
        break;
      }
      case x.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(t);
        break;
      }
      case x.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      case x.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(t);
        break;
      }
      case x.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(t);
        break;
      }
      case x.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(t);
        break;
      }
      case x.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(t);
        break;
      }
      case x.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case S.LESS_THAN_SIGN: {
        this.state = x.TAG_OPEN;
        break;
      }
      case S.AMPERSAND: {
        this.returnState = x.DATA, this.state = x.CHARACTER_REFERENCE;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case S.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case S.AMPERSAND: {
        this.returnState = x.RCDATA, this.state = x.CHARACTER_REFERENCE;
        break;
      }
      case S.LESS_THAN_SIGN: {
        this.state = x.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this._emitChars(Lt);
        break;
      }
      case S.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case S.LESS_THAN_SIGN: {
        this.state = x.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this._emitChars(Lt);
        break;
      }
      case S.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case S.LESS_THAN_SIGN: {
        this.state = x.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this._emitChars(Lt);
        break;
      }
      case S.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this._emitChars(Lt);
        break;
      }
      case S.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (Qr(t))
      this._createStartTagToken(), this.state = x.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case S.EXCLAMATION_MARK: {
          this.state = x.MARKUP_DECLARATION_OPEN;
          break;
        }
        case S.SOLIDUS: {
          this.state = x.END_TAG_OPEN;
          break;
        }
        case S.QUESTION_MARK: {
          this._err(te.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = x.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case S.EOF: {
          this._err(te.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(te.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = x.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (Qr(t))
      this._createEndTagToken(), this.state = x.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case S.GREATER_THAN_SIGN: {
          this._err(te.missingEndTagName), this.state = x.DATA;
          break;
        }
        case S.EOF: {
          this._err(te.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(te.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = x.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const n = this.currentToken;
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED: {
        this.state = x.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case S.SOLIDUS: {
        this.state = x.SELF_CLOSING_START_TAG;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this.state = x.DATA, this.emitCurrentTagToken();
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), n.tagName += Lt;
        break;
      }
      case S.EOF: {
        this._err(te.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(ts(t) ? po(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === S.SOLIDUS ? this.state = x.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = x.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    Qr(t) ? (this.state = x.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = x.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = x.BEFORE_ATTRIBUTE_NAME, !1;
      case S.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = x.SELF_CLOSING_START_TAG, !1;
      case S.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = x.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = x.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === S.SOLIDUS ? this.state = x.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = x.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    Qr(t) ? (this.state = x.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = x.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = x.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case S.SOLIDUS: {
        this.state = x.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case S.EXCLAMATION_MARK: {
        this.state = x.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = x.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    Qr(t) ? (this.state = x.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = x.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = x.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === S.HYPHEN_MINUS ? (this.state = x.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = x.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === S.HYPHEN_MINUS ? (this.state = x.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = x.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case S.HYPHEN_MINUS: {
        this.state = x.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case S.LESS_THAN_SIGN: {
        this.state = x.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this._emitChars(Lt);
        break;
      }
      case S.EOF: {
        this._err(te.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case S.HYPHEN_MINUS: {
        this.state = x.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case S.LESS_THAN_SIGN: {
        this.state = x.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this.state = x.SCRIPT_DATA_ESCAPED, this._emitChars(Lt);
        break;
      }
      case S.EOF: {
        this._err(te.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = x.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case S.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case S.LESS_THAN_SIGN: {
        this.state = x.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this.state = x.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this.state = x.SCRIPT_DATA_ESCAPED, this._emitChars(Lt);
        break;
      }
      case S.EOF: {
        this._err(te.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = x.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === S.SOLIDUS ? this.state = x.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Qr(t) ? (this._emitChars("<"), this.state = x.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = x.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    Qr(t) ? (this.state = x.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = x.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = x.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(xn.SCRIPT, !1) && Sg(this.preprocessor.peek(xn.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < xn.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else
      this._ensureHibernation() || (this.state = x.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case S.HYPHEN_MINUS: {
        this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case S.LESS_THAN_SIGN: {
        this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this._emitChars(Lt);
        break;
      }
      case S.EOF: {
        this._err(te.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case S.HYPHEN_MINUS: {
        this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case S.LESS_THAN_SIGN: {
        this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Lt);
        break;
      }
      case S.EOF: {
        this._err(te.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case S.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case S.LESS_THAN_SIGN: {
        this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this.state = x.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Lt);
        break;
      }
      case S.EOF: {
        this._err(te.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === S.SOLIDUS ? (this.state = x.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(xn.SCRIPT, !1) && Sg(this.preprocessor.peek(xn.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < xn.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = x.SCRIPT_DATA_ESCAPED;
    } else
      this._ensureHibernation() || (this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED:
        break;
      case S.SOLIDUS:
      case S.GREATER_THAN_SIGN:
      case S.EOF: {
        this.state = x.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case S.EQUALS_SIGN: {
        this._err(te.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = x.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = x.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED:
      case S.SOLIDUS:
      case S.GREATER_THAN_SIGN:
      case S.EOF: {
        this._leaveAttrName(), this.state = x.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case S.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = x.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case S.QUOTATION_MARK:
      case S.APOSTROPHE:
      case S.LESS_THAN_SIGN: {
        this._err(te.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this.currentAttr.name += Lt;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(ts(t) ? po(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED:
        break;
      case S.SOLIDUS: {
        this.state = x.SELF_CLOSING_START_TAG;
        break;
      }
      case S.EQUALS_SIGN: {
        this.state = x.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this.state = x.DATA, this.emitCurrentTagToken();
        break;
      }
      case S.EOF: {
        this._err(te.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = x.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED:
        break;
      case S.QUOTATION_MARK: {
        this.state = x.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case S.APOSTROPHE: {
        this.state = x.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.missingAttributeValue), this.state = x.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = x.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case S.QUOTATION_MARK: {
        this.state = x.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case S.AMPERSAND: {
        this.returnState = x.ATTRIBUTE_VALUE_DOUBLE_QUOTED, this.state = x.CHARACTER_REFERENCE;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this.currentAttr.value += Lt;
        break;
      }
      case S.EOF: {
        this._err(te.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case S.APOSTROPHE: {
        this.state = x.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case S.AMPERSAND: {
        this.returnState = x.ATTRIBUTE_VALUE_SINGLE_QUOTED, this.state = x.CHARACTER_REFERENCE;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this.currentAttr.value += Lt;
        break;
      }
      case S.EOF: {
        this._err(te.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED: {
        this._leaveAttrValue(), this.state = x.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case S.AMPERSAND: {
        this.returnState = x.ATTRIBUTE_VALUE_UNQUOTED, this.state = x.CHARACTER_REFERENCE;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = x.DATA, this.emitCurrentTagToken();
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), this.currentAttr.value += Lt;
        break;
      }
      case S.QUOTATION_MARK:
      case S.APOSTROPHE:
      case S.LESS_THAN_SIGN:
      case S.EQUALS_SIGN:
      case S.GRAVE_ACCENT: {
        this._err(te.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case S.EOF: {
        this._err(te.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED: {
        this._leaveAttrValue(), this.state = x.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case S.SOLIDUS: {
        this._leaveAttrValue(), this.state = x.SELF_CLOSING_START_TAG;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = x.DATA, this.emitCurrentTagToken();
        break;
      }
      case S.EOF: {
        this._err(te.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(te.missingWhitespaceBetweenAttributes), this.state = x.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case S.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = x.DATA, this.emitCurrentTagToken();
        break;
      }
      case S.EOF: {
        this._err(te.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(te.unexpectedSolidusInTag), this.state = x.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const n = this.currentToken;
    switch (t) {
      case S.GREATER_THAN_SIGN: {
        this.state = x.DATA, this.emitCurrentComment(n);
        break;
      }
      case S.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), n.data += Lt;
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(xn.DASH_DASH, !0) ? (this._createCommentToken(xn.DASH_DASH.length + 1), this.state = x.COMMENT_START) : this._consumeSequenceIfMatch(xn.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(xn.DOCTYPE.length + 1), this.state = x.DOCTYPE) : this._consumeSequenceIfMatch(xn.CDATA_START, !0) ? this.inForeignNode ? this.state = x.CDATA_SECTION : (this._err(te.cdataInHtmlContent), this._createCommentToken(xn.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = x.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(te.incorrectlyOpenedComment), this._createCommentToken(2), this.state = x.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case S.HYPHEN_MINUS: {
        this.state = x.COMMENT_START_DASH;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.abruptClosingOfEmptyComment), this.state = x.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = x.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const n = this.currentToken;
    switch (t) {
      case S.HYPHEN_MINUS: {
        this.state = x.COMMENT_END;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.abruptClosingOfEmptyComment), this.state = x.DATA, this.emitCurrentComment(n);
        break;
      }
      case S.EOF: {
        this._err(te.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = x.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const n = this.currentToken;
    switch (t) {
      case S.HYPHEN_MINUS: {
        this.state = x.COMMENT_END_DASH;
        break;
      }
      case S.LESS_THAN_SIGN: {
        n.data += "<", this.state = x.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), n.data += Lt;
        break;
      }
      case S.EOF: {
        this._err(te.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const n = this.currentToken;
    switch (t) {
      case S.EXCLAMATION_MARK: {
        n.data += "!", this.state = x.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case S.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = x.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === S.HYPHEN_MINUS ? this.state = x.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = x.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === S.HYPHEN_MINUS ? this.state = x.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = x.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== S.GREATER_THAN_SIGN && t !== S.EOF && this._err(te.nestedComment), this.state = x.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const n = this.currentToken;
    switch (t) {
      case S.HYPHEN_MINUS: {
        this.state = x.COMMENT_END;
        break;
      }
      case S.EOF: {
        this._err(te.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = x.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const n = this.currentToken;
    switch (t) {
      case S.GREATER_THAN_SIGN: {
        this.state = x.DATA, this.emitCurrentComment(n);
        break;
      }
      case S.EXCLAMATION_MARK: {
        this.state = x.COMMENT_END_BANG;
        break;
      }
      case S.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case S.EOF: {
        this._err(te.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = x.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const n = this.currentToken;
    switch (t) {
      case S.HYPHEN_MINUS: {
        n.data += "--!", this.state = x.COMMENT_END_DASH;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.incorrectlyClosedComment), this.state = x.DATA, this.emitCurrentComment(n);
        break;
      }
      case S.EOF: {
        this._err(te.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = x.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED: {
        this.state = x.BEFORE_DOCTYPE_NAME;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this.state = x.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(te.missingWhitespaceBeforeDoctypeName), this.state = x.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (ts(t))
      this._createDoctypeToken(String.fromCharCode(po(t))), this.state = x.DOCTYPE_NAME;
    else
      switch (t) {
        case S.SPACE:
        case S.LINE_FEED:
        case S.TABULATION:
        case S.FORM_FEED:
          break;
        case S.NULL: {
          this._err(te.unexpectedNullCharacter), this._createDoctypeToken(Lt), this.state = x.DOCTYPE_NAME;
          break;
        }
        case S.GREATER_THAN_SIGN: {
          this._err(te.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = x.DATA;
          break;
        }
        case S.EOF: {
          this._err(te.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = x.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED: {
        this.state = x.AFTER_DOCTYPE_NAME;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this.state = x.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), n.name += Lt;
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(ts(t) ? po(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED:
        break;
      case S.GREATER_THAN_SIGN: {
        this.state = x.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(xn.PUBLIC, !1) ? this.state = x.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(xn.SYSTEM, !1) ? this.state = x.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(te.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED: {
        this.state = x.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case S.QUOTATION_MARK: {
        this._err(te.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = x.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case S.APOSTROPHE: {
        this._err(te.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = x.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = x.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(te.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED:
        break;
      case S.QUOTATION_MARK: {
        n.publicId = "", this.state = x.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case S.APOSTROPHE: {
        n.publicId = "", this.state = x.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = x.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(te.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case S.QUOTATION_MARK: {
        this.state = x.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), n.publicId += Lt;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = x.DATA;
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case S.APOSTROPHE: {
        this.state = x.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), n.publicId += Lt;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = x.DATA;
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED: {
        this.state = x.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this.state = x.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case S.QUOTATION_MARK: {
        this._err(te.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case S.APOSTROPHE: {
        this._err(te.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(te.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const n = this.currentToken;
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED:
        break;
      case S.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = x.DATA;
        break;
      }
      case S.QUOTATION_MARK: {
        n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case S.APOSTROPHE: {
        n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(te.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED: {
        this.state = x.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case S.QUOTATION_MARK: {
        this._err(te.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case S.APOSTROPHE: {
        this._err(te.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(te.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED:
        break;
      case S.QUOTATION_MARK: {
        n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case S.APOSTROPHE: {
        n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(te.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case S.QUOTATION_MARK: {
        this.state = x.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), n.systemId += Lt;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = x.DATA;
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case S.APOSTROPHE: {
        this.state = x.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter), n.systemId += Lt;
        break;
      }
      case S.GREATER_THAN_SIGN: {
        this._err(te.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = x.DATA;
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case S.SPACE:
      case S.LINE_FEED:
      case S.TABULATION:
      case S.FORM_FEED:
        break;
      case S.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = x.DATA;
        break;
      }
      case S.EOF: {
        this._err(te.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(te.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const n = this.currentToken;
    switch (t) {
      case S.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = x.DATA;
        break;
      }
      case S.NULL: {
        this._err(te.unexpectedNullCharacter);
        break;
      }
      case S.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case S.RIGHT_SQUARE_BRACKET: {
        this.state = x.CDATA_SECTION_BRACKET;
        break;
      }
      case S.EOF: {
        this._err(te.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === S.RIGHT_SQUARE_BRACKET ? this.state = x.CDATA_SECTION_END : (this._emitChars("]"), this.state = x.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case S.GREATER_THAN_SIGN: {
        this.state = x.DATA;
        break;
      }
      case S.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = x.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(t) {
    t === S.NUMBER_SIGN ? this.state = x.NUMERIC_CHARACTER_REFERENCE : Mf(t) ? (this.state = x.NAMED_CHARACTER_REFERENCE, this._stateNamedCharacterReference(t)) : (this._flushCodePointConsumedAsCharacterReference(S.AMPERSAND), this._reconsumeInState(this.returnState, t));
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(t) {
    const n = this._matchNamedCharacterReference(t);
    if (!this._ensureHibernation())
      if (n) {
        for (let r = 0; r < n.length; r++)
          this._flushCodePointConsumedAsCharacterReference(n[r]);
        this.state = this.returnState;
      } else
        this._flushCodePointConsumedAsCharacterReference(S.AMPERSAND), this.state = x.AMBIGUOUS_AMPERSAND;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    Mf(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === S.SEMICOLON && this._err(te.unknownNamedCharacterReference), this._reconsumeInState(this.returnState, t));
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(t) {
    this.charRefCode = 0, t === S.LATIN_SMALL_X || t === S.LATIN_CAPITAL_X ? this.state = x.HEXADEMICAL_CHARACTER_REFERENCE_START : as(t) ? (this.state = x.DECIMAL_CHARACTER_REFERENCE, this._stateDecimalCharacterReference(t)) : (this._err(te.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(S.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(S.NUMBER_SIGN), this._reconsumeInState(this.returnState, t));
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(t) {
    i8(t) ? (this.state = x.HEXADEMICAL_CHARACTER_REFERENCE, this._stateHexademicalCharacterReference(t)) : (this._err(te.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(S.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(S.NUMBER_SIGN), this._unconsume(2), this.state = this.returnState);
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(t) {
    Zv(t) ? this.charRefCode = this.charRefCode * 16 + t - 55 : Qv(t) ? this.charRefCode = this.charRefCode * 16 + t - 87 : as(t) ? this.charRefCode = this.charRefCode * 16 + t - 48 : t === S.SEMICOLON ? this.state = x.NUMERIC_CHARACTER_REFERENCE_END : (this._err(te.missingSemicolonAfterCharacterReference), this.state = x.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(t) {
    as(t) ? this.charRefCode = this.charRefCode * 10 + t - 48 : t === S.SEMICOLON ? this.state = x.NUMERIC_CHARACTER_REFERENCE_END : (this._err(te.missingSemicolonAfterCharacterReference), this.state = x.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(t) {
    if (this.charRefCode === S.NULL)
      this._err(te.nullCharacterReference), this.charRefCode = S.REPLACEMENT_CHARACTER;
    else if (this.charRefCode > 1114111)
      this._err(te.characterReferenceOutsideUnicodeRange), this.charRefCode = S.REPLACEMENT_CHARACTER;
    else if (Vv(this.charRefCode))
      this._err(te.surrogateCharacterReference), this.charRefCode = S.REPLACEMENT_CHARACTER;
    else if (Yv(this.charRefCode))
      this._err(te.noncharacterCharacterReference);
    else if (Gv(this.charRefCode) || this.charRefCode === S.CARRIAGE_RETURN) {
      this._err(te.controlCharacterReference);
      const n = r8.get(this.charRefCode);
      n !== void 0 && (this.charRefCode = n);
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode), this._reconsumeInState(this.returnState, t);
  }
}
const eT = /* @__PURE__ */ new Set([c.DD, c.DT, c.LI, c.OPTGROUP, c.OPTION, c.P, c.RB, c.RP, c.RT, c.RTC]), Cg = /* @__PURE__ */ new Set([
  ...eT,
  c.CAPTION,
  c.COLGROUP,
  c.TBODY,
  c.TD,
  c.TFOOT,
  c.TH,
  c.THEAD,
  c.TR
]), go = /* @__PURE__ */ new Map([
  [c.APPLET, ae.HTML],
  [c.CAPTION, ae.HTML],
  [c.HTML, ae.HTML],
  [c.MARQUEE, ae.HTML],
  [c.OBJECT, ae.HTML],
  [c.TABLE, ae.HTML],
  [c.TD, ae.HTML],
  [c.TEMPLATE, ae.HTML],
  [c.TH, ae.HTML],
  [c.ANNOTATION_XML, ae.MATHML],
  [c.MI, ae.MATHML],
  [c.MN, ae.MATHML],
  [c.MO, ae.MATHML],
  [c.MS, ae.MATHML],
  [c.MTEXT, ae.MATHML],
  [c.DESC, ae.SVG],
  [c.FOREIGN_OBJECT, ae.SVG],
  [c.TITLE, ae.SVG]
]), u8 = [c.H1, c.H2, c.H3, c.H4, c.H5, c.H6], l8 = [c.TR, c.TEMPLATE, c.HTML], c8 = [c.TBODY, c.TFOOT, c.THEAD, c.TEMPLATE, c.HTML], f8 = [c.TABLE, c.TEMPLATE, c.HTML], d8 = [c.TD, c.TH];
class h8 {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = c.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === c.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === ae.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, n) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, n) {
    const r = this._indexOf(t);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(t, n, r) {
    const a = this._indexOf(t) + 1;
    this.items.splice(a, 0, n), this.tagIDs.splice(a, 0, r), this.stackTop++, a === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, a === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(t, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== ae.HTML);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const n = this._indexOf(t);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  popUntilPopped(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(u8, ae.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(d8, ae.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (t.includes(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(f8, ae.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(c8, ae.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(l8, ae.HTML);
  }
  remove(t) {
    const n = this._indexOf(t);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === c.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const n = this._indexOf(t) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === c.HTML;
  }
  //Element in scope
  hasInScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n], a = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === t && a === ae.HTML)
        return !0;
      if (go.get(r) === a)
        return !1;
    }
    return !0;
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t], r = this.treeAdapter.getNamespaceURI(this.items[t]);
      if (Xv(n) && r === ae.HTML)
        return !0;
      if (go.get(n) === r)
        return !1;
    }
    return !0;
  }
  hasInListItemScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n], a = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === t && a === ae.HTML)
        return !0;
      if ((r === c.UL || r === c.OL) && a === ae.HTML || go.get(r) === a)
        return !1;
    }
    return !0;
  }
  hasInButtonScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n], a = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === t && a === ae.HTML)
        return !0;
      if (r === c.BUTTON && a === ae.HTML || go.get(r) === a)
        return !1;
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n];
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === ae.HTML) {
        if (r === t)
          return !0;
        if (r === c.TABLE || r === c.TEMPLATE || r === c.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t];
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === ae.HTML) {
        if (n === c.TBODY || n === c.THEAD || n === c.TFOOT)
          return !0;
        if (n === c.TABLE || n === c.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasInSelectScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n];
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === ae.HTML) {
        if (r === t)
          return !0;
        if (r !== c.OPTION && r !== c.OPTGROUP)
          return !1;
      }
    }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; eT.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; Cg.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== t && Cg.has(this.currentTagId); )
      this.pop();
  }
}
const Fl = 3;
var sr;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(sr = sr || (sr = {}));
const Og = { type: sr.Marker };
class m8 {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, n) {
    const r = [], a = n.length, i = this.treeAdapter.getTagName(t), s = this.treeAdapter.getNamespaceURI(t);
    for (let o = 0; o < this.entries.length; o++) {
      const u = this.entries[o];
      if (u.type === sr.Marker)
        break;
      const { element: l } = u;
      if (this.treeAdapter.getTagName(l) === i && this.treeAdapter.getNamespaceURI(l) === s) {
        const f = this.treeAdapter.getAttrList(l);
        f.length === a && r.push({ idx: o, attrs: f });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < Fl)
      return;
    const n = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n);
    if (r.length < Fl)
      return;
    const a = new Map(n.map((s) => [s.name, s.value]));
    let i = 0;
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      o.attrs.every((u) => a.get(u.name) === u.value) && (i += 1, i >= Fl && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(Og);
  }
  pushElement(t, n) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: sr.Element,
      element: t,
      token: n
    });
  }
  insertElementAfterBookmark(t, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: sr.Element,
      element: t,
      token: n
    });
  }
  removeEntry(t) {
    const n = this.entries.indexOf(t);
    n >= 0 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(Og);
    t >= 0 ? this.entries.splice(0, t + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const n = this.entries.find((r) => r.type === sr.Marker || this.treeAdapter.getTagName(r.element) === t);
    return n && n.type === sr.Element ? n : null;
  }
  getElementEntry(t) {
    return this.entries.find((n) => n.type === sr.Element && n.element === t);
  }
}
function Ig(e) {
  return {
    nodeName: "#text",
    value: e,
    parentNode: null
  };
}
const ui = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: Bn.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, n) {
    return {
      nodeName: e,
      tagName: e,
      attrs: n,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, n) {
    const r = e.childNodes.indexOf(n);
    e.childNodes.splice(r, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, n, r) {
    const a = e.childNodes.find((i) => i.nodeName === "#documentType");
    if (a)
      a.name = t, a.publicId = n, a.systemId = r;
    else {
      const i = {
        nodeName: "#documentType",
        name: t,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      ui.appendChild(e, i);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const n = e.childNodes[e.childNodes.length - 1];
      if (ui.isTextNode(n)) {
        n.value += t;
        return;
      }
    }
    ui.appendChild(e, Ig(t));
  },
  insertTextBefore(e, t, n) {
    const r = e.childNodes[e.childNodes.indexOf(n) - 1];
    r && ui.isTextNode(r) ? r.value += t : ui.insertBefore(e, Ig(t), n);
  },
  adoptAttributes(e, t) {
    const n = new Set(e.attrs.map((r) => r.name));
    for (let r = 0; r < t.length; r++)
      n.has(t[r].name) || e.attrs.push(t[r]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, tT = "html", p8 = "about:legacy-compat", g8 = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", nT = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], b8 = [
  ...nT,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], E8 = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), rT = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], v8 = [
  ...rT,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function xg(e, t) {
  return t.some((n) => e.startsWith(n));
}
function T8(e) {
  return e.name === tT && e.publicId === null && (e.systemId === null || e.systemId === p8);
}
function A8(e) {
  if (e.name !== tT)
    return Bn.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === g8)
    return Bn.QUIRKS;
  let { publicId: n } = e;
  if (n !== null) {
    if (n = n.toLowerCase(), E8.has(n))
      return Bn.QUIRKS;
    let r = t === null ? b8 : nT;
    if (xg(n, r))
      return Bn.QUIRKS;
    if (r = t === null ? rT : v8, xg(n, r))
      return Bn.LIMITED_QUIRKS;
  }
  return Bn.NO_QUIRKS;
}
const Ng = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, _8 = "definitionurl", y8 = "definitionURL", S8 = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), C8 = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: ae.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: ae.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: ae.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: ae.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: ae.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: ae.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: ae.XLINK }],
  ["xml:base", { prefix: "xml", name: "base", namespace: ae.XML }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: ae.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: ae.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: ae.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: ae.XMLNS }]
]), O8 = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), I8 = /* @__PURE__ */ new Set([
  c.B,
  c.BIG,
  c.BLOCKQUOTE,
  c.BODY,
  c.BR,
  c.CENTER,
  c.CODE,
  c.DD,
  c.DIV,
  c.DL,
  c.DT,
  c.EM,
  c.EMBED,
  c.H1,
  c.H2,
  c.H3,
  c.H4,
  c.H5,
  c.H6,
  c.HEAD,
  c.HR,
  c.I,
  c.IMG,
  c.LI,
  c.LISTING,
  c.MENU,
  c.META,
  c.NOBR,
  c.OL,
  c.P,
  c.PRE,
  c.RUBY,
  c.S,
  c.SMALL,
  c.SPAN,
  c.STRONG,
  c.STRIKE,
  c.SUB,
  c.SUP,
  c.TABLE,
  c.TT,
  c.U,
  c.UL,
  c.VAR
]);
function x8(e) {
  const t = e.tagID;
  return t === c.FONT && e.attrs.some(({ name: r }) => r === na.COLOR || r === na.SIZE || r === na.FACE) || I8.has(t);
}
function aT(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === _8) {
      e.attrs[t].name = y8;
      break;
    }
}
function iT(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = S8.get(e.attrs[t].name);
    n != null && (e.attrs[t].name = n);
  }
}
function Xd(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = C8.get(e.attrs[t].name);
    n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace);
  }
}
function N8(e) {
  const t = O8.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = Di(e.tagName));
}
function R8(e, t) {
  return t === ae.MATHML && (e === c.MI || e === c.MO || e === c.MN || e === c.MS || e === c.MTEXT);
}
function k8(e, t, n) {
  if (t === ae.MATHML && e === c.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === na.ENCODING) {
        const a = n[r].value.toLowerCase();
        return a === Ng.TEXT_HTML || a === Ng.APPLICATION_XML;
      }
  }
  return t === ae.SVG && (e === c.FOREIGN_OBJECT || e === c.DESC || e === c.TITLE);
}
function w8(e, t, n, r) {
  return (!r || r === ae.HTML) && k8(e, t, n) || (!r || r === ae.MATHML) && R8(e, t);
}
const D8 = "hidden", P8 = 8, L8 = 3;
var L;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(L || (L = {}));
const M8 = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, sT = /* @__PURE__ */ new Set([c.TABLE, c.TBODY, c.TFOOT, c.THEAD, c.TR]), Rg = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: ui,
  onParseError: null
};
class kg {
  constructor(t, n, r = null, a = null) {
    this.fragmentContext = r, this.scriptHandler = a, this.currentToken = null, this.stopped = !1, this.insertionMode = L.INITIAL, this.originalInsertionMode = L.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...Rg,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new o8(this.options, this), this.activeFormattingElements = new m8(this.treeAdapter), this.fragmentContextID = r ? Di(this.treeAdapter.getTagName(r)) : c.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new h8(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, n) {
    const r = new this(n);
    return r.tokenizer.write(t, !0), r.document;
  }
  static getFragmentParser(t, n) {
    const r = {
      ...Rg,
      ...n
    };
    t ?? (t = r.treeAdapter.createElement(K.TEMPLATE, ae.HTML, []));
    const a = r.treeAdapter.createElement("documentmock", ae.HTML, []), i = new this(r, a, t);
    return i.fragmentContextID === c.TEMPLATE && i.tmplInsertionModeStack.unshift(L.IN_TEMPLATE), i._initTokenizerForFragmentParsing(), i._insertFakeRootElement(), i._resetInsertionMode(), i._findFormInFragmentContext(), i;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, n), n;
  }
  //Errors
  _err(t, n, r) {
    var a;
    if (!this.onParseError)
      return;
    const i = (a = t.location) !== null && a !== void 0 ? a : M8, s = {
      code: n,
      startLine: i.startLine,
      startCol: i.startCol,
      startOffset: i.startOffset,
      endLine: r ? i.startLine : i.endLine,
      endCol: r ? i.startCol : i.endCol,
      endOffset: r ? i.startOffset : i.endOffset
    };
    this.onParseError(s);
  }
  //Stack events
  onItemPush(t, n, r) {
    var a, i;
    (i = (a = this.treeAdapter).onItemPush) === null || i === void 0 || i.call(a, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n);
  }
  onItemPop(t, n) {
    var r, a;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (a = (r = this.treeAdapter).onItemPop) === null || a === void 0 || a.call(r, t, this.openElements.current), n) {
      let i, s;
      this.openElements.stackTop === 0 && this.fragmentContext ? (i = this.fragmentContext, s = this.fragmentContextID) : { current: i, currentTagId: s } = this.openElements, this._setContextModes(i, s);
    }
  }
  _setContextModes(t, n) {
    const r = t === this.document || this.treeAdapter.getNamespaceURI(t) === ae.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(n, t);
  }
  _switchToTextParsing(t, n) {
    this._insertElement(t, ae.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = L.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = L.TEXT, this.originalInsertionMode = L.IN_BODY, this.tokenizer.state = zt.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === K.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== ae.HTML))
      switch (this.fragmentContextID) {
        case c.TITLE:
        case c.TEXTAREA: {
          this.tokenizer.state = zt.RCDATA;
          break;
        }
        case c.STYLE:
        case c.XMP:
        case c.IFRAME:
        case c.NOEMBED:
        case c.NOFRAMES:
        case c.NOSCRIPT: {
          this.tokenizer.state = zt.RAWTEXT;
          break;
        }
        case c.SCRIPT: {
          this.tokenizer.state = zt.SCRIPT_DATA;
          break;
        }
        case c.PLAINTEXT: {
          this.tokenizer.state = zt.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  _setDocumentType(t) {
    const n = t.name || "", r = t.publicId || "", a = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, a), t.location) {
      const s = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      s && this.treeAdapter.setNodeSourceCodeLocation(s, t.location);
    }
  }
  _attachElementToTree(t, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r, t);
    }
  }
  _appendElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location);
  }
  _insertElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID);
  }
  _insertFakeElement(t, n) {
    const r = this.treeAdapter.createElement(t, ae.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  _insertTemplate(t) {
    const n = this.treeAdapter.createElement(t.tagName, ae.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, t.location), this.openElements.push(n, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(K.HTML, ae.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, c.HTML);
  }
  _appendCommentNode(t, n) {
    const r = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location);
  }
  _insertCharacters(t) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, t.chars, r) : this.treeAdapter.insertText(n, t.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t.chars)), !t.location)
      return;
    const a = this.treeAdapter.getChildNodes(n), i = r ? a.lastIndexOf(r) : a.length, s = a[i - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(s)) {
      const { endLine: u, endCol: l, endOffset: f } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(s, { endLine: u, endCol: l, endOffset: f });
    } else
      this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(s, t.location);
  }
  _adoptNodes(t, n) {
    for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  _setEndLocation(t, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) {
      const r = n.location, a = this.treeAdapter.getTagName(t), i = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === Ze.END_TAG && a === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, i);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, t.tagID === c.SVG && this.treeAdapter.getTagName(n) === K.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === ae.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === c.MGLYPH || t.tagID === c.MALIGNMARK) && !this._isIntegrationPoint(r, n, ae.HTML)
    );
  }
  _processToken(t) {
    switch (t.type) {
      case Ze.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case Ze.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case Ze.COMMENT: {
        this.onComment(t);
        break;
      }
      case Ze.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case Ze.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case Ze.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case Ze.EOF: {
        this.onEof(t);
        break;
      }
      case Ze.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(t, n, r) {
    const a = this.treeAdapter.getNamespaceURI(n), i = this.treeAdapter.getAttrList(n);
    return w8(t, a, i, r);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const n = this.activeFormattingElements.entries.findIndex((a) => a.type === sr.Marker || this.openElements.contains(a.element)), r = n < 0 ? t - 1 : n - 1;
      for (let a = r; a >= 0; a--) {
        const i = this.activeFormattingElements.entries[a];
        this._insertElement(i.token, this.treeAdapter.getNamespaceURI(i.element)), i.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = L.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(c.P), this.openElements.popUntilTagNamePopped(c.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case c.TR: {
          this.insertionMode = L.IN_ROW;
          return;
        }
        case c.TBODY:
        case c.THEAD:
        case c.TFOOT: {
          this.insertionMode = L.IN_TABLE_BODY;
          return;
        }
        case c.CAPTION: {
          this.insertionMode = L.IN_CAPTION;
          return;
        }
        case c.COLGROUP: {
          this.insertionMode = L.IN_COLUMN_GROUP;
          return;
        }
        case c.TABLE: {
          this.insertionMode = L.IN_TABLE;
          return;
        }
        case c.BODY: {
          this.insertionMode = L.IN_BODY;
          return;
        }
        case c.FRAMESET: {
          this.insertionMode = L.IN_FRAMESET;
          return;
        }
        case c.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case c.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case c.HTML: {
          this.insertionMode = this.headElement ? L.AFTER_HEAD : L.BEFORE_HEAD;
          return;
        }
        case c.TD:
        case c.TH: {
          if (t > 0) {
            this.insertionMode = L.IN_CELL;
            return;
          }
          break;
        }
        case c.HEAD: {
          if (t > 0) {
            this.insertionMode = L.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = L.IN_BODY;
  }
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let n = t - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === c.TEMPLATE)
          break;
        if (r === c.TABLE) {
          this.insertionMode = L.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = L.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(t) {
    return sT.has(t);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const n = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case c.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === ae.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case c.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(t) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t);
  }
  //Special elements
  _isSpecialElement(t, n) {
    const r = this.treeAdapter.getNamespaceURI(t);
    return n8[r].has(n);
  }
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      d$(this, t);
      return;
    }
    switch (this.insertionMode) {
      case L.INITIAL: {
        Xi(this, t);
        break;
      }
      case L.BEFORE_HTML: {
        is(this, t);
        break;
      }
      case L.BEFORE_HEAD: {
        ss(this, t);
        break;
      }
      case L.IN_HEAD: {
        os(this, t);
        break;
      }
      case L.IN_HEAD_NO_SCRIPT: {
        us(this, t);
        break;
      }
      case L.AFTER_HEAD: {
        ls(this, t);
        break;
      }
      case L.IN_BODY:
      case L.IN_CAPTION:
      case L.IN_CELL:
      case L.IN_TEMPLATE: {
        uT(this, t);
        break;
      }
      case L.TEXT:
      case L.IN_SELECT:
      case L.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case L.IN_TABLE:
      case L.IN_TABLE_BODY:
      case L.IN_ROW: {
        Ul(this, t);
        break;
      }
      case L.IN_TABLE_TEXT: {
        mT(this, t);
        break;
      }
      case L.IN_COLUMN_GROUP: {
        uu(this, t);
        break;
      }
      case L.AFTER_BODY: {
        lu(this, t);
        break;
      }
      case L.AFTER_AFTER_BODY: {
        Oo(this, t);
        break;
      }
    }
  }
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      f$(this, t);
      return;
    }
    switch (this.insertionMode) {
      case L.INITIAL: {
        Xi(this, t);
        break;
      }
      case L.BEFORE_HTML: {
        is(this, t);
        break;
      }
      case L.BEFORE_HEAD: {
        ss(this, t);
        break;
      }
      case L.IN_HEAD: {
        os(this, t);
        break;
      }
      case L.IN_HEAD_NO_SCRIPT: {
        us(this, t);
        break;
      }
      case L.AFTER_HEAD: {
        ls(this, t);
        break;
      }
      case L.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case L.IN_TABLE:
      case L.IN_TABLE_BODY:
      case L.IN_ROW: {
        Ul(this, t);
        break;
      }
      case L.IN_COLUMN_GROUP: {
        uu(this, t);
        break;
      }
      case L.AFTER_BODY: {
        lu(this, t);
        break;
      }
      case L.AFTER_AFTER_BODY: {
        Oo(this, t);
        break;
      }
    }
  }
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      $f(this, t);
      return;
    }
    switch (this.insertionMode) {
      case L.INITIAL:
      case L.BEFORE_HTML:
      case L.BEFORE_HEAD:
      case L.IN_HEAD:
      case L.IN_HEAD_NO_SCRIPT:
      case L.AFTER_HEAD:
      case L.IN_BODY:
      case L.IN_TABLE:
      case L.IN_CAPTION:
      case L.IN_COLUMN_GROUP:
      case L.IN_TABLE_BODY:
      case L.IN_ROW:
      case L.IN_CELL:
      case L.IN_SELECT:
      case L.IN_SELECT_IN_TABLE:
      case L.IN_TEMPLATE:
      case L.IN_FRAMESET:
      case L.AFTER_FRAMESET: {
        $f(this, t);
        break;
      }
      case L.IN_TABLE_TEXT: {
        Zi(this, t);
        break;
      }
      case L.AFTER_BODY: {
        z8(this, t);
        break;
      }
      case L.AFTER_AFTER_BODY:
      case L.AFTER_AFTER_FRAMESET: {
        V8(this, t);
        break;
      }
    }
  }
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case L.INITIAL: {
        G8(this, t);
        break;
      }
      case L.BEFORE_HEAD:
      case L.IN_HEAD:
      case L.IN_HEAD_NO_SCRIPT:
      case L.AFTER_HEAD: {
        this._err(t, te.misplacedDoctype);
        break;
      }
      case L.IN_TABLE_TEXT: {
        Zi(this, t);
        break;
      }
    }
  }
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, te.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? h$(this, t) : this._startTagOutsideForeignContent(t);
  }
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case L.INITIAL: {
        Xi(this, t);
        break;
      }
      case L.BEFORE_HTML: {
        Y8(this, t);
        break;
      }
      case L.BEFORE_HEAD: {
        q8(this, t);
        break;
      }
      case L.IN_HEAD: {
        gr(this, t);
        break;
      }
      case L.IN_HEAD_NO_SCRIPT: {
        Z8(this, t);
        break;
      }
      case L.AFTER_HEAD: {
        J8(this, t);
        break;
      }
      case L.IN_BODY: {
        pn(this, t);
        break;
      }
      case L.IN_TABLE: {
        Ti(this, t);
        break;
      }
      case L.IN_TABLE_TEXT: {
        Zi(this, t);
        break;
      }
      case L.IN_CAPTION: {
        K9(this, t);
        break;
      }
      case L.IN_COLUMN_GROUP: {
        Jd(this, t);
        break;
      }
      case L.IN_TABLE_BODY: {
        Bu(this, t);
        break;
      }
      case L.IN_ROW: {
        Fu(this, t);
        break;
      }
      case L.IN_CELL: {
        Q9(this, t);
        break;
      }
      case L.IN_SELECT: {
        bT(this, t);
        break;
      }
      case L.IN_SELECT_IN_TABLE: {
        e$(this, t);
        break;
      }
      case L.IN_TEMPLATE: {
        n$(this, t);
        break;
      }
      case L.AFTER_BODY: {
        a$(this, t);
        break;
      }
      case L.IN_FRAMESET: {
        i$(this, t);
        break;
      }
      case L.AFTER_FRAMESET: {
        o$(this, t);
        break;
      }
      case L.AFTER_AFTER_BODY: {
        l$(this, t);
        break;
      }
      case L.AFTER_AFTER_FRAMESET: {
        c$(this, t);
        break;
      }
    }
  }
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? m$(this, t) : this._endTagOutsideForeignContent(t);
  }
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case L.INITIAL: {
        Xi(this, t);
        break;
      }
      case L.BEFORE_HTML: {
        W8(this, t);
        break;
      }
      case L.BEFORE_HEAD: {
        K8(this, t);
        break;
      }
      case L.IN_HEAD: {
        X8(this, t);
        break;
      }
      case L.IN_HEAD_NO_SCRIPT: {
        Q8(this, t);
        break;
      }
      case L.AFTER_HEAD: {
        e9(this, t);
        break;
      }
      case L.IN_BODY: {
        $u(this, t);
        break;
      }
      case L.TEXT: {
        F9(this, t);
        break;
      }
      case L.IN_TABLE: {
        Ls(this, t);
        break;
      }
      case L.IN_TABLE_TEXT: {
        Zi(this, t);
        break;
      }
      case L.IN_CAPTION: {
        X9(this, t);
        break;
      }
      case L.IN_COLUMN_GROUP: {
        Z9(this, t);
        break;
      }
      case L.IN_TABLE_BODY: {
        Bf(this, t);
        break;
      }
      case L.IN_ROW: {
        gT(this, t);
        break;
      }
      case L.IN_CELL: {
        J9(this, t);
        break;
      }
      case L.IN_SELECT: {
        ET(this, t);
        break;
      }
      case L.IN_SELECT_IN_TABLE: {
        t$(this, t);
        break;
      }
      case L.IN_TEMPLATE: {
        r$(this, t);
        break;
      }
      case L.AFTER_BODY: {
        TT(this, t);
        break;
      }
      case L.IN_FRAMESET: {
        s$(this, t);
        break;
      }
      case L.AFTER_FRAMESET: {
        u$(this, t);
        break;
      }
      case L.AFTER_AFTER_BODY: {
        Oo(this, t);
        break;
      }
    }
  }
  onEof(t) {
    switch (this.insertionMode) {
      case L.INITIAL: {
        Xi(this, t);
        break;
      }
      case L.BEFORE_HTML: {
        is(this, t);
        break;
      }
      case L.BEFORE_HEAD: {
        ss(this, t);
        break;
      }
      case L.IN_HEAD: {
        os(this, t);
        break;
      }
      case L.IN_HEAD_NO_SCRIPT: {
        us(this, t);
        break;
      }
      case L.AFTER_HEAD: {
        ls(this, t);
        break;
      }
      case L.IN_BODY:
      case L.IN_TABLE:
      case L.IN_CAPTION:
      case L.IN_COLUMN_GROUP:
      case L.IN_TABLE_BODY:
      case L.IN_ROW:
      case L.IN_CELL:
      case L.IN_SELECT:
      case L.IN_SELECT_IN_TABLE: {
        dT(this, t);
        break;
      }
      case L.TEXT: {
        U9(this, t);
        break;
      }
      case L.IN_TABLE_TEXT: {
        Zi(this, t);
        break;
      }
      case L.IN_TEMPLATE: {
        vT(this, t);
        break;
      }
      case L.AFTER_BODY:
      case L.IN_FRAMESET:
      case L.AFTER_FRAMESET:
      case L.AFTER_AFTER_BODY:
      case L.AFTER_AFTER_FRAMESET: {
        Qd(this, t);
        break;
      }
    }
  }
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === S.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case L.IN_HEAD:
      case L.IN_HEAD_NO_SCRIPT:
      case L.AFTER_HEAD:
      case L.TEXT:
      case L.IN_COLUMN_GROUP:
      case L.IN_SELECT:
      case L.IN_SELECT_IN_TABLE:
      case L.IN_FRAMESET:
      case L.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case L.IN_BODY:
      case L.IN_CAPTION:
      case L.IN_CELL:
      case L.IN_TEMPLATE:
      case L.AFTER_BODY:
      case L.AFTER_AFTER_BODY:
      case L.AFTER_AFTER_FRAMESET: {
        oT(this, t);
        break;
      }
      case L.IN_TABLE:
      case L.IN_TABLE_BODY:
      case L.IN_ROW: {
        Ul(this, t);
        break;
      }
      case L.IN_TABLE_TEXT: {
        hT(this, t);
        break;
      }
    }
  }
}
function $8(e, t) {
  let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : fT(e, t), n;
}
function B8(e, t) {
  let n = null, r = e.openElements.stackTop;
  for (; r >= 0; r--) {
    const a = e.openElements.items[r];
    if (a === t.element)
      break;
    e._isSpecialElement(a, e.openElements.tagIDs[r]) && (n = a);
  }
  return n || (e.openElements.shortenToLength(r < 0 ? 0 : r), e.activeFormattingElements.removeEntry(t)), n;
}
function F8(e, t, n) {
  let r = t, a = e.openElements.getCommonAncestor(t);
  for (let i = 0, s = a; s !== n; i++, s = a) {
    a = e.openElements.getCommonAncestor(s);
    const o = e.activeFormattingElements.getElementEntry(s), u = o && i >= L8;
    !o || u ? (u && e.activeFormattingElements.removeEntry(o), e.openElements.remove(s)) : (s = U8(e, o), r === t && (e.activeFormattingElements.bookmark = o), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(s, r), r = s);
  }
  return r;
}
function U8(e, t) {
  const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs);
  return e.openElements.replace(t.element, r), t.element = r, r;
}
function H8(e, t, n) {
  const r = e.treeAdapter.getTagName(t), a = Di(r);
  if (e._isElementCausesFosterParenting(a))
    e._fosterParentElement(n);
  else {
    const i = e.treeAdapter.getNamespaceURI(t);
    a === c.TEMPLATE && i === ae.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n);
  }
}
function j8(e, t, n) {
  const r = e.treeAdapter.getNamespaceURI(n.element), { token: a } = n, i = e.treeAdapter.createElement(a.tagName, r, a.attrs);
  e._adoptNodes(t, i), e.treeAdapter.appendChild(t, i), e.activeFormattingElements.insertElementAfterBookmark(i, a), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, i, a.tagID);
}
function Zd(e, t) {
  for (let n = 0; n < P8; n++) {
    const r = $8(e, t);
    if (!r)
      break;
    const a = B8(e, r);
    if (!a)
      break;
    e.activeFormattingElements.bookmark = r;
    const i = F8(e, a, r.element), s = e.openElements.getCommonAncestor(r.element);
    e.treeAdapter.detachNode(i), s && H8(e, s, i), j8(e, a, r);
  }
}
function $f(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function z8(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function V8(e, t) {
  e._appendCommentNode(t, e.document);
}
function Qd(e, t) {
  if (e.stopped = !0, t.location) {
    const n = e.fragmentContext ? 0 : 2;
    for (let r = e.openElements.stackTop; r >= n; r--)
      e._setEndLocation(e.openElements.items[r], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const r = e.openElements.items[0], a = e.treeAdapter.getNodeSourceCodeLocation(r);
      if (a && !a.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) {
        const i = e.openElements.items[1], s = e.treeAdapter.getNodeSourceCodeLocation(i);
        s && !s.endTag && e._setEndLocation(i, t);
      }
    }
  }
}
function G8(e, t) {
  e._setDocumentType(t);
  const n = t.forceQuirks ? Bn.QUIRKS : A8(t);
  T8(t) || e._err(t, te.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = L.BEFORE_HTML;
}
function Xi(e, t) {
  e._err(t, te.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, Bn.QUIRKS), e.insertionMode = L.BEFORE_HTML, e._processToken(t);
}
function Y8(e, t) {
  t.tagID === c.HTML ? (e._insertElement(t, ae.HTML), e.insertionMode = L.BEFORE_HEAD) : is(e, t);
}
function W8(e, t) {
  const n = t.tagID;
  (n === c.HTML || n === c.HEAD || n === c.BODY || n === c.BR) && is(e, t);
}
function is(e, t) {
  e._insertFakeRootElement(), e.insertionMode = L.BEFORE_HEAD, e._processToken(t);
}
function q8(e, t) {
  switch (t.tagID) {
    case c.HTML: {
      pn(e, t);
      break;
    }
    case c.HEAD: {
      e._insertElement(t, ae.HTML), e.headElement = e.openElements.current, e.insertionMode = L.IN_HEAD;
      break;
    }
    default:
      ss(e, t);
  }
}
function K8(e, t) {
  const n = t.tagID;
  n === c.HEAD || n === c.BODY || n === c.HTML || n === c.BR ? ss(e, t) : e._err(t, te.endTagWithoutMatchingOpenElement);
}
function ss(e, t) {
  e._insertFakeElement(K.HEAD, c.HEAD), e.headElement = e.openElements.current, e.insertionMode = L.IN_HEAD, e._processToken(t);
}
function gr(e, t) {
  switch (t.tagID) {
    case c.HTML: {
      pn(e, t);
      break;
    }
    case c.BASE:
    case c.BASEFONT:
    case c.BGSOUND:
    case c.LINK:
    case c.META: {
      e._appendElement(t, ae.HTML), t.ackSelfClosing = !0;
      break;
    }
    case c.TITLE: {
      e._switchToTextParsing(t, zt.RCDATA);
      break;
    }
    case c.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, zt.RAWTEXT) : (e._insertElement(t, ae.HTML), e.insertionMode = L.IN_HEAD_NO_SCRIPT);
      break;
    }
    case c.NOFRAMES:
    case c.STYLE: {
      e._switchToTextParsing(t, zt.RAWTEXT);
      break;
    }
    case c.SCRIPT: {
      e._switchToTextParsing(t, zt.SCRIPT_DATA);
      break;
    }
    case c.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = L.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(L.IN_TEMPLATE);
      break;
    }
    case c.HEAD: {
      e._err(t, te.misplacedStartTagForHeadElement);
      break;
    }
    default:
      os(e, t);
  }
}
function X8(e, t) {
  switch (t.tagID) {
    case c.HEAD: {
      e.openElements.pop(), e.insertionMode = L.AFTER_HEAD;
      break;
    }
    case c.BODY:
    case c.BR:
    case c.HTML: {
      os(e, t);
      break;
    }
    case c.TEMPLATE: {
      ja(e, t);
      break;
    }
    default:
      e._err(t, te.endTagWithoutMatchingOpenElement);
  }
}
function ja(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== c.TEMPLATE && e._err(t, te.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(c.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, te.endTagWithoutMatchingOpenElement);
}
function os(e, t) {
  e.openElements.pop(), e.insertionMode = L.AFTER_HEAD, e._processToken(t);
}
function Z8(e, t) {
  switch (t.tagID) {
    case c.HTML: {
      pn(e, t);
      break;
    }
    case c.BASEFONT:
    case c.BGSOUND:
    case c.HEAD:
    case c.LINK:
    case c.META:
    case c.NOFRAMES:
    case c.STYLE: {
      gr(e, t);
      break;
    }
    case c.NOSCRIPT: {
      e._err(t, te.nestedNoscriptInHead);
      break;
    }
    default:
      us(e, t);
  }
}
function Q8(e, t) {
  switch (t.tagID) {
    case c.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = L.IN_HEAD;
      break;
    }
    case c.BR: {
      us(e, t);
      break;
    }
    default:
      e._err(t, te.endTagWithoutMatchingOpenElement);
  }
}
function us(e, t) {
  const n = t.type === Ze.EOF ? te.openElementsLeftAfterEof : te.disallowedContentInNoscriptInHead;
  e._err(t, n), e.openElements.pop(), e.insertionMode = L.IN_HEAD, e._processToken(t);
}
function J8(e, t) {
  switch (t.tagID) {
    case c.HTML: {
      pn(e, t);
      break;
    }
    case c.BODY: {
      e._insertElement(t, ae.HTML), e.framesetOk = !1, e.insertionMode = L.IN_BODY;
      break;
    }
    case c.FRAMESET: {
      e._insertElement(t, ae.HTML), e.insertionMode = L.IN_FRAMESET;
      break;
    }
    case c.BASE:
    case c.BASEFONT:
    case c.BGSOUND:
    case c.LINK:
    case c.META:
    case c.NOFRAMES:
    case c.SCRIPT:
    case c.STYLE:
    case c.TEMPLATE:
    case c.TITLE: {
      e._err(t, te.abandonedHeadElementChild), e.openElements.push(e.headElement, c.HEAD), gr(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case c.HEAD: {
      e._err(t, te.misplacedStartTagForHeadElement);
      break;
    }
    default:
      ls(e, t);
  }
}
function e9(e, t) {
  switch (t.tagID) {
    case c.BODY:
    case c.HTML:
    case c.BR: {
      ls(e, t);
      break;
    }
    case c.TEMPLATE: {
      ja(e, t);
      break;
    }
    default:
      e._err(t, te.endTagWithoutMatchingOpenElement);
  }
}
function ls(e, t) {
  e._insertFakeElement(K.BODY, c.BODY), e.insertionMode = L.IN_BODY, Mu(e, t);
}
function Mu(e, t) {
  switch (t.type) {
    case Ze.CHARACTER: {
      uT(e, t);
      break;
    }
    case Ze.WHITESPACE_CHARACTER: {
      oT(e, t);
      break;
    }
    case Ze.COMMENT: {
      $f(e, t);
      break;
    }
    case Ze.START_TAG: {
      pn(e, t);
      break;
    }
    case Ze.END_TAG: {
      $u(e, t);
      break;
    }
    case Ze.EOF: {
      dT(e, t);
      break;
    }
  }
}
function oT(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function uT(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function t9(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function n9(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  n && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs));
}
function r9(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, ae.HTML), e.insertionMode = L.IN_FRAMESET);
}
function a9(e, t) {
  e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, ae.HTML);
}
function i9(e, t) {
  e.openElements.hasInButtonScope(c.P) && e._closePElement(), Xv(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, ae.HTML);
}
function s9(e, t) {
  e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, ae.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function o9(e, t) {
  const n = e.openElements.tmplCount > 0;
  (!e.formElement || n) && (e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, ae.HTML), n || (e.formElement = e.openElements.current));
}
function u9(e, t) {
  e.framesetOk = !1;
  const n = t.tagID;
  for (let r = e.openElements.stackTop; r >= 0; r--) {
    const a = e.openElements.tagIDs[r];
    if (n === c.LI && a === c.LI || (n === c.DD || n === c.DT) && (a === c.DD || a === c.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(a), e.openElements.popUntilTagNamePopped(a);
      break;
    }
    if (a !== c.ADDRESS && a !== c.DIV && a !== c.P && e._isSpecialElement(e.openElements.items[r], a))
      break;
  }
  e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, ae.HTML);
}
function l9(e, t) {
  e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, ae.HTML), e.tokenizer.state = zt.PLAINTEXT;
}
function c9(e, t) {
  e.openElements.hasInScope(c.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(c.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, ae.HTML), e.framesetOk = !1;
}
function f9(e, t) {
  const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(K.A);
  n && (Zd(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, ae.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function d9(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, ae.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function h9(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(c.NOBR) && (Zd(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, ae.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function m9(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, ae.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function p9(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== Bn.QUIRKS && e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, ae.HTML), e.framesetOk = !1, e.insertionMode = L.IN_TABLE;
}
function lT(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, ae.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function cT(e) {
  const t = Wv(e, na.TYPE);
  return t != null && t.toLowerCase() === D8;
}
function g9(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, ae.HTML), cT(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function b9(e, t) {
  e._appendElement(t, ae.HTML), t.ackSelfClosing = !0;
}
function E9(e, t) {
  e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._appendElement(t, ae.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function v9(e, t) {
  t.tagName = K.IMG, t.tagID = c.IMG, lT(e, t);
}
function T9(e, t) {
  e._insertElement(t, ae.HTML), e.skipNextNewLine = !0, e.tokenizer.state = zt.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = L.TEXT;
}
function A9(e, t) {
  e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, zt.RAWTEXT);
}
function _9(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, zt.RAWTEXT);
}
function wg(e, t) {
  e._switchToTextParsing(t, zt.RAWTEXT);
}
function y9(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, ae.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === L.IN_TABLE || e.insertionMode === L.IN_CAPTION || e.insertionMode === L.IN_TABLE_BODY || e.insertionMode === L.IN_ROW || e.insertionMode === L.IN_CELL ? L.IN_SELECT_IN_TABLE : L.IN_SELECT;
}
function S9(e, t) {
  e.openElements.currentTagId === c.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, ae.HTML);
}
function C9(e, t) {
  e.openElements.hasInScope(c.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, ae.HTML);
}
function O9(e, t) {
  e.openElements.hasInScope(c.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(c.RTC), e._insertElement(t, ae.HTML);
}
function I9(e, t) {
  e._reconstructActiveFormattingElements(), aT(t), Xd(t), t.selfClosing ? e._appendElement(t, ae.MATHML) : e._insertElement(t, ae.MATHML), t.ackSelfClosing = !0;
}
function x9(e, t) {
  e._reconstructActiveFormattingElements(), iT(t), Xd(t), t.selfClosing ? e._appendElement(t, ae.SVG) : e._insertElement(t, ae.SVG), t.ackSelfClosing = !0;
}
function Dg(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, ae.HTML);
}
function pn(e, t) {
  switch (t.tagID) {
    case c.I:
    case c.S:
    case c.B:
    case c.U:
    case c.EM:
    case c.TT:
    case c.BIG:
    case c.CODE:
    case c.FONT:
    case c.SMALL:
    case c.STRIKE:
    case c.STRONG: {
      d9(e, t);
      break;
    }
    case c.A: {
      f9(e, t);
      break;
    }
    case c.H1:
    case c.H2:
    case c.H3:
    case c.H4:
    case c.H5:
    case c.H6: {
      i9(e, t);
      break;
    }
    case c.P:
    case c.DL:
    case c.OL:
    case c.UL:
    case c.DIV:
    case c.DIR:
    case c.NAV:
    case c.MAIN:
    case c.MENU:
    case c.ASIDE:
    case c.CENTER:
    case c.FIGURE:
    case c.FOOTER:
    case c.HEADER:
    case c.HGROUP:
    case c.DIALOG:
    case c.DETAILS:
    case c.ADDRESS:
    case c.ARTICLE:
    case c.SECTION:
    case c.SUMMARY:
    case c.FIELDSET:
    case c.BLOCKQUOTE:
    case c.FIGCAPTION: {
      a9(e, t);
      break;
    }
    case c.LI:
    case c.DD:
    case c.DT: {
      u9(e, t);
      break;
    }
    case c.BR:
    case c.IMG:
    case c.WBR:
    case c.AREA:
    case c.EMBED:
    case c.KEYGEN: {
      lT(e, t);
      break;
    }
    case c.HR: {
      E9(e, t);
      break;
    }
    case c.RB:
    case c.RTC: {
      C9(e, t);
      break;
    }
    case c.RT:
    case c.RP: {
      O9(e, t);
      break;
    }
    case c.PRE:
    case c.LISTING: {
      s9(e, t);
      break;
    }
    case c.XMP: {
      A9(e, t);
      break;
    }
    case c.SVG: {
      x9(e, t);
      break;
    }
    case c.HTML: {
      t9(e, t);
      break;
    }
    case c.BASE:
    case c.LINK:
    case c.META:
    case c.STYLE:
    case c.TITLE:
    case c.SCRIPT:
    case c.BGSOUND:
    case c.BASEFONT:
    case c.TEMPLATE: {
      gr(e, t);
      break;
    }
    case c.BODY: {
      n9(e, t);
      break;
    }
    case c.FORM: {
      o9(e, t);
      break;
    }
    case c.NOBR: {
      h9(e, t);
      break;
    }
    case c.MATH: {
      I9(e, t);
      break;
    }
    case c.TABLE: {
      p9(e, t);
      break;
    }
    case c.INPUT: {
      g9(e, t);
      break;
    }
    case c.PARAM:
    case c.TRACK:
    case c.SOURCE: {
      b9(e, t);
      break;
    }
    case c.IMAGE: {
      v9(e, t);
      break;
    }
    case c.BUTTON: {
      c9(e, t);
      break;
    }
    case c.APPLET:
    case c.OBJECT:
    case c.MARQUEE: {
      m9(e, t);
      break;
    }
    case c.IFRAME: {
      _9(e, t);
      break;
    }
    case c.SELECT: {
      y9(e, t);
      break;
    }
    case c.OPTION:
    case c.OPTGROUP: {
      S9(e, t);
      break;
    }
    case c.NOEMBED: {
      wg(e, t);
      break;
    }
    case c.FRAMESET: {
      r9(e, t);
      break;
    }
    case c.TEXTAREA: {
      T9(e, t);
      break;
    }
    case c.NOSCRIPT: {
      e.options.scriptingEnabled ? wg(e, t) : Dg(e, t);
      break;
    }
    case c.PLAINTEXT: {
      l9(e, t);
      break;
    }
    case c.COL:
    case c.TH:
    case c.TD:
    case c.TR:
    case c.HEAD:
    case c.FRAME:
    case c.TBODY:
    case c.TFOOT:
    case c.THEAD:
    case c.CAPTION:
    case c.COLGROUP:
      break;
    default:
      Dg(e, t);
  }
}
function N9(e, t) {
  if (e.openElements.hasInScope(c.BODY) && (e.insertionMode = L.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const n = e.openElements.tryPeekProperlyNestedBodyElement();
    n && e._setEndLocation(n, t);
  }
}
function R9(e, t) {
  e.openElements.hasInScope(c.BODY) && (e.insertionMode = L.AFTER_BODY, TT(e, t));
}
function k9(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n));
}
function w9(e) {
  const t = e.openElements.tmplCount > 0, { formElement: n } = e;
  t || (e.formElement = null), (n || t) && e.openElements.hasInScope(c.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(c.FORM) : n && e.openElements.remove(n));
}
function D9(e) {
  e.openElements.hasInButtonScope(c.P) || e._insertFakeElement(K.P, c.P), e._closePElement();
}
function P9(e) {
  e.openElements.hasInListItemScope(c.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(c.LI), e.openElements.popUntilTagNamePopped(c.LI));
}
function L9(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n));
}
function M9(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function $9(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker());
}
function B9(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(K.BR, c.BR), e.openElements.pop(), e.framesetOk = !1;
}
function fT(e, t) {
  const n = t.tagName, r = t.tagID;
  for (let a = e.openElements.stackTop; a > 0; a--) {
    const i = e.openElements.items[a], s = e.openElements.tagIDs[a];
    if (r === s && (r !== c.UNKNOWN || e.treeAdapter.getTagName(i) === n)) {
      e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= a && e.openElements.shortenToLength(a);
      break;
    }
    if (e._isSpecialElement(i, s))
      break;
  }
}
function $u(e, t) {
  switch (t.tagID) {
    case c.A:
    case c.B:
    case c.I:
    case c.S:
    case c.U:
    case c.EM:
    case c.TT:
    case c.BIG:
    case c.CODE:
    case c.FONT:
    case c.NOBR:
    case c.SMALL:
    case c.STRIKE:
    case c.STRONG: {
      Zd(e, t);
      break;
    }
    case c.P: {
      D9(e);
      break;
    }
    case c.DL:
    case c.UL:
    case c.OL:
    case c.DIR:
    case c.DIV:
    case c.NAV:
    case c.PRE:
    case c.MAIN:
    case c.MENU:
    case c.ASIDE:
    case c.BUTTON:
    case c.CENTER:
    case c.FIGURE:
    case c.FOOTER:
    case c.HEADER:
    case c.HGROUP:
    case c.DIALOG:
    case c.ADDRESS:
    case c.ARTICLE:
    case c.DETAILS:
    case c.SECTION:
    case c.SUMMARY:
    case c.LISTING:
    case c.FIELDSET:
    case c.BLOCKQUOTE:
    case c.FIGCAPTION: {
      k9(e, t);
      break;
    }
    case c.LI: {
      P9(e);
      break;
    }
    case c.DD:
    case c.DT: {
      L9(e, t);
      break;
    }
    case c.H1:
    case c.H2:
    case c.H3:
    case c.H4:
    case c.H5:
    case c.H6: {
      M9(e);
      break;
    }
    case c.BR: {
      B9(e);
      break;
    }
    case c.BODY: {
      N9(e, t);
      break;
    }
    case c.HTML: {
      R9(e, t);
      break;
    }
    case c.FORM: {
      w9(e);
      break;
    }
    case c.APPLET:
    case c.OBJECT:
    case c.MARQUEE: {
      $9(e, t);
      break;
    }
    case c.TEMPLATE: {
      ja(e, t);
      break;
    }
    default:
      fT(e, t);
  }
}
function dT(e, t) {
  e.tmplInsertionModeStack.length > 0 ? vT(e, t) : Qd(e, t);
}
function F9(e, t) {
  var n;
  t.tagID === c.SCRIPT && ((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function U9(e, t) {
  e._err(t, te.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function Ul(e, t) {
  if (sT.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = L.IN_TABLE_TEXT, t.type) {
      case Ze.CHARACTER: {
        mT(e, t);
        break;
      }
      case Ze.WHITESPACE_CHARACTER: {
        hT(e, t);
        break;
      }
    }
  else
    Vs(e, t);
}
function H9(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, ae.HTML), e.insertionMode = L.IN_CAPTION;
}
function j9(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, ae.HTML), e.insertionMode = L.IN_COLUMN_GROUP;
}
function z9(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(K.COLGROUP, c.COLGROUP), e.insertionMode = L.IN_COLUMN_GROUP, Jd(e, t);
}
function V9(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, ae.HTML), e.insertionMode = L.IN_TABLE_BODY;
}
function G9(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(K.TBODY, c.TBODY), e.insertionMode = L.IN_TABLE_BODY, Bu(e, t);
}
function Y9(e, t) {
  e.openElements.hasInTableScope(c.TABLE) && (e.openElements.popUntilTagNamePopped(c.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function W9(e, t) {
  cT(t) ? e._appendElement(t, ae.HTML) : Vs(e, t), t.ackSelfClosing = !0;
}
function q9(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, ae.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function Ti(e, t) {
  switch (t.tagID) {
    case c.TD:
    case c.TH:
    case c.TR: {
      G9(e, t);
      break;
    }
    case c.STYLE:
    case c.SCRIPT:
    case c.TEMPLATE: {
      gr(e, t);
      break;
    }
    case c.COL: {
      z9(e, t);
      break;
    }
    case c.FORM: {
      q9(e, t);
      break;
    }
    case c.TABLE: {
      Y9(e, t);
      break;
    }
    case c.TBODY:
    case c.TFOOT:
    case c.THEAD: {
      V9(e, t);
      break;
    }
    case c.INPUT: {
      W9(e, t);
      break;
    }
    case c.CAPTION: {
      H9(e, t);
      break;
    }
    case c.COLGROUP: {
      j9(e, t);
      break;
    }
    default:
      Vs(e, t);
  }
}
function Ls(e, t) {
  switch (t.tagID) {
    case c.TABLE: {
      e.openElements.hasInTableScope(c.TABLE) && (e.openElements.popUntilTagNamePopped(c.TABLE), e._resetInsertionMode());
      break;
    }
    case c.TEMPLATE: {
      ja(e, t);
      break;
    }
    case c.BODY:
    case c.CAPTION:
    case c.COL:
    case c.COLGROUP:
    case c.HTML:
    case c.TBODY:
    case c.TD:
    case c.TFOOT:
    case c.TH:
    case c.THEAD:
    case c.TR:
      break;
    default:
      Vs(e, t);
  }
}
function Vs(e, t) {
  const n = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, Mu(e, t), e.fosterParentingEnabled = n;
}
function hT(e, t) {
  e.pendingCharacterTokens.push(t);
}
function mT(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function Zi(e, t) {
  let n = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; n < e.pendingCharacterTokens.length; n++)
      Vs(e, e.pendingCharacterTokens[n]);
  else
    for (; n < e.pendingCharacterTokens.length; n++)
      e._insertCharacters(e.pendingCharacterTokens[n]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const pT = /* @__PURE__ */ new Set([c.CAPTION, c.COL, c.COLGROUP, c.TBODY, c.TD, c.TFOOT, c.TH, c.THEAD, c.TR]);
function K9(e, t) {
  const n = t.tagID;
  pT.has(n) ? e.openElements.hasInTableScope(c.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(c.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = L.IN_TABLE, Ti(e, t)) : pn(e, t);
}
function X9(e, t) {
  const n = t.tagID;
  switch (n) {
    case c.CAPTION:
    case c.TABLE: {
      e.openElements.hasInTableScope(c.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(c.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = L.IN_TABLE, n === c.TABLE && Ls(e, t));
      break;
    }
    case c.BODY:
    case c.COL:
    case c.COLGROUP:
    case c.HTML:
    case c.TBODY:
    case c.TD:
    case c.TFOOT:
    case c.TH:
    case c.THEAD:
    case c.TR:
      break;
    default:
      $u(e, t);
  }
}
function Jd(e, t) {
  switch (t.tagID) {
    case c.HTML: {
      pn(e, t);
      break;
    }
    case c.COL: {
      e._appendElement(t, ae.HTML), t.ackSelfClosing = !0;
      break;
    }
    case c.TEMPLATE: {
      gr(e, t);
      break;
    }
    default:
      uu(e, t);
  }
}
function Z9(e, t) {
  switch (t.tagID) {
    case c.COLGROUP: {
      e.openElements.currentTagId === c.COLGROUP && (e.openElements.pop(), e.insertionMode = L.IN_TABLE);
      break;
    }
    case c.TEMPLATE: {
      ja(e, t);
      break;
    }
    case c.COL:
      break;
    default:
      uu(e, t);
  }
}
function uu(e, t) {
  e.openElements.currentTagId === c.COLGROUP && (e.openElements.pop(), e.insertionMode = L.IN_TABLE, e._processToken(t));
}
function Bu(e, t) {
  switch (t.tagID) {
    case c.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, ae.HTML), e.insertionMode = L.IN_ROW;
      break;
    }
    case c.TH:
    case c.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(K.TR, c.TR), e.insertionMode = L.IN_ROW, Fu(e, t);
      break;
    }
    case c.CAPTION:
    case c.COL:
    case c.COLGROUP:
    case c.TBODY:
    case c.TFOOT:
    case c.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = L.IN_TABLE, Ti(e, t));
      break;
    }
    default:
      Ti(e, t);
  }
}
function Bf(e, t) {
  const n = t.tagID;
  switch (t.tagID) {
    case c.TBODY:
    case c.TFOOT:
    case c.THEAD: {
      e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = L.IN_TABLE);
      break;
    }
    case c.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = L.IN_TABLE, Ls(e, t));
      break;
    }
    case c.BODY:
    case c.CAPTION:
    case c.COL:
    case c.COLGROUP:
    case c.HTML:
    case c.TD:
    case c.TH:
    case c.TR:
      break;
    default:
      Ls(e, t);
  }
}
function Fu(e, t) {
  switch (t.tagID) {
    case c.TH:
    case c.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, ae.HTML), e.insertionMode = L.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case c.CAPTION:
    case c.COL:
    case c.COLGROUP:
    case c.TBODY:
    case c.TFOOT:
    case c.THEAD:
    case c.TR: {
      e.openElements.hasInTableScope(c.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = L.IN_TABLE_BODY, Bu(e, t));
      break;
    }
    default:
      Ti(e, t);
  }
}
function gT(e, t) {
  switch (t.tagID) {
    case c.TR: {
      e.openElements.hasInTableScope(c.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = L.IN_TABLE_BODY);
      break;
    }
    case c.TABLE: {
      e.openElements.hasInTableScope(c.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = L.IN_TABLE_BODY, Bf(e, t));
      break;
    }
    case c.TBODY:
    case c.TFOOT:
    case c.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(c.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = L.IN_TABLE_BODY, Bf(e, t));
      break;
    }
    case c.BODY:
    case c.CAPTION:
    case c.COL:
    case c.COLGROUP:
    case c.HTML:
    case c.TD:
    case c.TH:
      break;
    default:
      Ls(e, t);
  }
}
function Q9(e, t) {
  const n = t.tagID;
  pT.has(n) ? (e.openElements.hasInTableScope(c.TD) || e.openElements.hasInTableScope(c.TH)) && (e._closeTableCell(), Fu(e, t)) : pn(e, t);
}
function J9(e, t) {
  const n = t.tagID;
  switch (n) {
    case c.TD:
    case c.TH: {
      e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = L.IN_ROW);
      break;
    }
    case c.TABLE:
    case c.TBODY:
    case c.TFOOT:
    case c.THEAD:
    case c.TR: {
      e.openElements.hasInTableScope(n) && (e._closeTableCell(), gT(e, t));
      break;
    }
    case c.BODY:
    case c.CAPTION:
    case c.COL:
    case c.COLGROUP:
    case c.HTML:
      break;
    default:
      $u(e, t);
  }
}
function bT(e, t) {
  switch (t.tagID) {
    case c.HTML: {
      pn(e, t);
      break;
    }
    case c.OPTION: {
      e.openElements.currentTagId === c.OPTION && e.openElements.pop(), e._insertElement(t, ae.HTML);
      break;
    }
    case c.OPTGROUP: {
      e.openElements.currentTagId === c.OPTION && e.openElements.pop(), e.openElements.currentTagId === c.OPTGROUP && e.openElements.pop(), e._insertElement(t, ae.HTML);
      break;
    }
    case c.INPUT:
    case c.KEYGEN:
    case c.TEXTAREA:
    case c.SELECT: {
      e.openElements.hasInSelectScope(c.SELECT) && (e.openElements.popUntilTagNamePopped(c.SELECT), e._resetInsertionMode(), t.tagID !== c.SELECT && e._processStartTag(t));
      break;
    }
    case c.SCRIPT:
    case c.TEMPLATE: {
      gr(e, t);
      break;
    }
  }
}
function ET(e, t) {
  switch (t.tagID) {
    case c.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === c.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === c.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === c.OPTGROUP && e.openElements.pop();
      break;
    }
    case c.OPTION: {
      e.openElements.currentTagId === c.OPTION && e.openElements.pop();
      break;
    }
    case c.SELECT: {
      e.openElements.hasInSelectScope(c.SELECT) && (e.openElements.popUntilTagNamePopped(c.SELECT), e._resetInsertionMode());
      break;
    }
    case c.TEMPLATE: {
      ja(e, t);
      break;
    }
  }
}
function e$(e, t) {
  const n = t.tagID;
  n === c.CAPTION || n === c.TABLE || n === c.TBODY || n === c.TFOOT || n === c.THEAD || n === c.TR || n === c.TD || n === c.TH ? (e.openElements.popUntilTagNamePopped(c.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : bT(e, t);
}
function t$(e, t) {
  const n = t.tagID;
  n === c.CAPTION || n === c.TABLE || n === c.TBODY || n === c.TFOOT || n === c.THEAD || n === c.TR || n === c.TD || n === c.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(c.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : ET(e, t);
}
function n$(e, t) {
  switch (t.tagID) {
    case c.BASE:
    case c.BASEFONT:
    case c.BGSOUND:
    case c.LINK:
    case c.META:
    case c.NOFRAMES:
    case c.SCRIPT:
    case c.STYLE:
    case c.TEMPLATE:
    case c.TITLE: {
      gr(e, t);
      break;
    }
    case c.CAPTION:
    case c.COLGROUP:
    case c.TBODY:
    case c.TFOOT:
    case c.THEAD: {
      e.tmplInsertionModeStack[0] = L.IN_TABLE, e.insertionMode = L.IN_TABLE, Ti(e, t);
      break;
    }
    case c.COL: {
      e.tmplInsertionModeStack[0] = L.IN_COLUMN_GROUP, e.insertionMode = L.IN_COLUMN_GROUP, Jd(e, t);
      break;
    }
    case c.TR: {
      e.tmplInsertionModeStack[0] = L.IN_TABLE_BODY, e.insertionMode = L.IN_TABLE_BODY, Bu(e, t);
      break;
    }
    case c.TD:
    case c.TH: {
      e.tmplInsertionModeStack[0] = L.IN_ROW, e.insertionMode = L.IN_ROW, Fu(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = L.IN_BODY, e.insertionMode = L.IN_BODY, pn(e, t);
  }
}
function r$(e, t) {
  t.tagID === c.TEMPLATE && ja(e, t);
}
function vT(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(c.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : Qd(e, t);
}
function a$(e, t) {
  t.tagID === c.HTML ? pn(e, t) : lu(e, t);
}
function TT(e, t) {
  var n;
  if (t.tagID === c.HTML) {
    if (e.fragmentContext || (e.insertionMode = L.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === c.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const r = e.openElements.items[1];
      r && !(!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && e._setEndLocation(r, t);
    }
  } else
    lu(e, t);
}
function lu(e, t) {
  e.insertionMode = L.IN_BODY, Mu(e, t);
}
function i$(e, t) {
  switch (t.tagID) {
    case c.HTML: {
      pn(e, t);
      break;
    }
    case c.FRAMESET: {
      e._insertElement(t, ae.HTML);
      break;
    }
    case c.FRAME: {
      e._appendElement(t, ae.HTML), t.ackSelfClosing = !0;
      break;
    }
    case c.NOFRAMES: {
      gr(e, t);
      break;
    }
  }
}
function s$(e, t) {
  t.tagID === c.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== c.FRAMESET && (e.insertionMode = L.AFTER_FRAMESET));
}
function o$(e, t) {
  switch (t.tagID) {
    case c.HTML: {
      pn(e, t);
      break;
    }
    case c.NOFRAMES: {
      gr(e, t);
      break;
    }
  }
}
function u$(e, t) {
  t.tagID === c.HTML && (e.insertionMode = L.AFTER_AFTER_FRAMESET);
}
function l$(e, t) {
  t.tagID === c.HTML ? pn(e, t) : Oo(e, t);
}
function Oo(e, t) {
  e.insertionMode = L.IN_BODY, Mu(e, t);
}
function c$(e, t) {
  switch (t.tagID) {
    case c.HTML: {
      pn(e, t);
      break;
    }
    case c.NOFRAMES: {
      gr(e, t);
      break;
    }
  }
}
function f$(e, t) {
  t.chars = Lt, e._insertCharacters(t);
}
function d$(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function AT(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== ae.HTML && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function h$(e, t) {
  if (x8(t))
    AT(e), e._startTagOutsideForeignContent(t);
  else {
    const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n);
    r === ae.MATHML ? aT(t) : r === ae.SVG && (N8(t), iT(t)), Xd(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0;
  }
}
function m$(e, t) {
  if (t.tagID === c.P || t.tagID === c.BR) {
    AT(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let n = e.openElements.stackTop; n > 0; n--) {
    const r = e.openElements.items[n];
    if (e.treeAdapter.getNamespaceURI(r) === ae.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const a = e.treeAdapter.getTagName(r);
    if (a.toLowerCase() === t.tagName) {
      t.tagName = a, e.openElements.shortenToLength(n);
      break;
    }
  }
}
K.AREA, K.BASE, K.BASEFONT, K.BGSOUND, K.BR, K.COL, K.EMBED, K.FRAME, K.HR, K.IMG, K.INPUT, K.KEYGEN, K.LINK, K.META, K.PARAM, K.SOURCE, K.TRACK, K.WBR;
const _T = yT("end"), za = yT("start");
function yT(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
const Uu = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return E$;
    if (typeof e == "function")
      return Hu(e);
    if (typeof e == "object")
      return Array.isArray(e) ? p$(e) : g$(e);
    if (typeof e == "string")
      return b$(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function p$(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Uu(e[n]);
  return Hu(r);
  function r(...a) {
    let i = -1;
    for (; ++i < t.length; )
      if (t[i].apply(this, a))
        return !0;
    return !1;
  }
}
function g$(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Hu(n);
  function n(r) {
    const a = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let i;
    for (i in e)
      if (a[i] !== t[i])
        return !1;
    return !0;
  }
}
function b$(e) {
  return Hu(t);
  function t(n) {
    return n && n.type === e;
  }
}
function Hu(e) {
  return t;
  function t(n, r, a) {
    return !!(v$(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      a || void 0
    ));
  }
}
function E$() {
  return !0;
}
function v$(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const ST = [], T$ = !0, Ff = !1, A$ = "skip";
function Gs(e, t, n, r) {
  let a;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : a = t;
  const i = Uu(a), s = r ? -1 : 1;
  o(e, void 0, [])();
  function o(u, l, f) {
    const h = (
      /** @type {Record<string, unknown>} */
      u && typeof u == "object" ? u : {}
    );
    if (typeof h.type == "string") {
      const b = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(p, "name", {
        value: "node (" + (u.type + (b ? "<" + b + ">" : "")) + ")"
      });
    }
    return p;
    function p() {
      let b = ST, v, E, y;
      if ((!t || i(u, l, f[f.length - 1] || void 0)) && (b = _$(n(u, f)), b[0] === Ff))
        return b;
      if ("children" in u && u.children) {
        const N = (
          /** @type {UnistParent} */
          u
        );
        if (N.children && b[0] !== A$)
          for (E = (r ? N.children.length : -1) + s, y = f.concat(N); E > -1 && E < N.children.length; ) {
            const A = N.children[E];
            if (v = o(A, E, y)(), v[0] === Ff)
              return v;
            E = typeof v[1] == "number" ? v[1] : E + s;
          }
      }
      return b;
    }
  }
}
function _$(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [T$, e] : e == null ? ST : [e];
}
function y$(e, t, n, r) {
  let a, i, s;
  typeof t == "function" && typeof n != "function" ? (i = void 0, s = t, a = n) : (i = t, s = n, a = r), Gs(e, i, o, a);
  function o(u, l) {
    const f = l[l.length - 1], h = f ? f.children.indexOf(u) : void 0;
    return s(u, h, f);
  }
}
const S$ = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), Pg = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function CT(e, t) {
  const n = P$(e), r = jv("type", {
    handlers: { root: C$, element: O$, text: I$, comment: IT, doctype: x$, raw: R$ },
    unknown: k$
  }), a = {
    parser: n ? new kg(Pg) : kg.getFragmentParser(void 0, Pg),
    handle(o) {
      r(o, a);
    },
    stitches: !1,
    options: t || {}
  };
  r(e, a), Pi(a, za());
  const i = n ? a.parser.document : a.parser.getFragment(), s = I5(i, {
    // To do: support `space`?
    file: a.options.file
  });
  return a.stitches && y$(s, "comment", function(o, u, l) {
    const f = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (f.value.stitch && l && u !== void 0) {
      const h = l.children;
      return h[u] = f.value.stitch, u;
    }
  }), s.type === "root" && s.children.length === 1 && s.children[0].type === e.type ? s.children[0] : s;
}
function OT(e, t) {
  let n = -1;
  if (e)
    for (; ++n < e.length; )
      t.handle(e[n]);
}
function C$(e, t) {
  OT(e.children, t);
}
function O$(e, t) {
  w$(e, t), OT(e.children, t), D$(e, t);
}
function I$(e, t) {
  const n = {
    type: Ze.CHARACTER,
    chars: e.value,
    location: Ys(e)
  };
  Pi(t, za(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function x$(e, t) {
  const n = {
    type: Ze.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: Ys(e)
  };
  Pi(t, za(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function N$(e, t) {
  t.stitches = !0;
  const n = L$(e);
  if ("children" in e && "children" in n) {
    const r = (
      /** @type {Root} */
      CT({ type: "root", children: e.children }, t.options)
    );
    n.children = r.children;
  }
  IT({ type: "comment", value: { stitch: n } }, t);
}
function IT(e, t) {
  const n = e.value, r = {
    type: Ze.COMMENT,
    data: n,
    location: Ys(e)
  };
  Pi(t, za(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function R$(e, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, xT(t, za(e)), t.parser.tokenizer.write(e.value, !1), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const n = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(n);
  }
}
function k$(e, t) {
  const n = (
    /** @type {Nodes} */
    e
  );
  if (t.options.passThrough && t.options.passThrough.includes(n.type))
    N$(n, t);
  else {
    let r = "";
    throw S$.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r);
  }
}
function Pi(e, t) {
  xT(e, t);
  const n = e.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = zt.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function xT(e, t) {
  if (t && t.offset !== void 0) {
    const n = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n;
  }
}
function w$(e, t) {
  if (t.parser.tokenizer.state === zt.PLAINTEXT)
    return;
  Pi(t, za(e));
  const n = t.parser.openElements.current;
  let r = "namespaceURI" in n ? n.namespaceURI : Sa.html;
  r === Sa.html && e.tagName === "svg" && (r = Sa.svg);
  const a = w5(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e, children: [] },
    { space: r === Sa.svg ? "svg" : "html" }
  ), i = "attrs" in a ? a.attrs : [], s = {
    type: Ze.START_TAG,
    tagName: e.tagName,
    tagID: Di(e.tagName),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: i,
    location: Ys(e)
  };
  t.parser.currentToken = s, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = e.tagName;
}
function D$(e, t) {
  if (!t.parser.tokenizer.inForeignNode && U5.includes(e.tagName) || t.parser.tokenizer.state === zt.PLAINTEXT)
    return;
  Pi(t, _T(e));
  const n = {
    type: Ze.END_TAG,
    tagName: e.tagName,
    tagID: Di(e.tagName),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: Ys(e)
  };
  t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  n.tagName === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === zt.RCDATA || // `<iframe>`, `<noembed>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === zt.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === zt.SCRIPT_DATA) && (t.parser.tokenizer.state = zt.DATA);
}
function P$(e) {
  const t = e.type === "root" ? e.children[0] : e;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName === "html"));
}
function Ys(e) {
  const t = za(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = _T(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function L$(e) {
  return "children" in e ? Ma({ ...e, children: [] }) : Ma(e);
}
function NT(e) {
  return function(t, n) {
    return (
      /** @type {Root} */
      CT(t, { ...e, file: n })
    );
  };
}
const M$ = /[ \t\n\f\r]/g;
function $$(e) {
  return typeof e == "object" ? e.type === "text" ? Lg(e.value) : !1 : Lg(e);
}
function Lg(e) {
  return e.replace(M$, "") === "";
}
var eh = { exports: {} }, Mg = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, B$ = /\n/g, F$ = /^\s*/, U$ = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, H$ = /^:\s*/, j$ = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, z$ = /^[;\s]*/, V$ = /^\s+|\s+$/g, G$ = `
`, $g = "/", Bg = "*", Aa = "", Y$ = "comment", W$ = "declaration", q$ = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  t = t || {};
  var n = 1, r = 1;
  function a(v) {
    var E = v.match(B$);
    E && (n += E.length);
    var y = v.lastIndexOf(G$);
    r = ~y ? v.length - y : r + v.length;
  }
  function i() {
    var v = { line: n, column: r };
    return function(E) {
      return E.position = new s(v), l(), E;
    };
  }
  function s(v) {
    this.start = v, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function o(v) {
    var E = new Error(
      t.source + ":" + n + ":" + r + ": " + v
    );
    if (E.reason = v, E.filename = t.source, E.line = n, E.column = r, E.source = e, !t.silent)
      throw E;
  }
  function u(v) {
    var E = v.exec(e);
    if (E) {
      var y = E[0];
      return a(y), e = e.slice(y.length), E;
    }
  }
  function l() {
    u(F$);
  }
  function f(v) {
    var E;
    for (v = v || []; E = h(); )
      E !== !1 && v.push(E);
    return v;
  }
  function h() {
    var v = i();
    if (!($g != e.charAt(0) || Bg != e.charAt(1))) {
      for (var E = 2; Aa != e.charAt(E) && (Bg != e.charAt(E) || $g != e.charAt(E + 1)); )
        ++E;
      if (E += 2, Aa === e.charAt(E - 1))
        return o("End of comment missing");
      var y = e.slice(2, E - 2);
      return r += 2, a(y), e = e.slice(E), r += 2, v({
        type: Y$,
        comment: y
      });
    }
  }
  function p() {
    var v = i(), E = u(U$);
    if (E) {
      if (h(), !u(H$))
        return o("property missing ':'");
      var y = u(j$), N = v({
        type: W$,
        property: Fg(E[0].replace(Mg, Aa)),
        value: y ? Fg(y[0].replace(Mg, Aa)) : Aa
      });
      return u(z$), N;
    }
  }
  function b() {
    var v = [];
    f(v);
    for (var E; E = p(); )
      E !== !1 && (v.push(E), f(v));
    return v;
  }
  return l(), b();
};
function Fg(e) {
  return e ? e.replace(V$, Aa) : Aa;
}
var K$ = q$;
function RT(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  for (var r, a = K$(e), i = typeof t == "function", s, o, u = 0, l = a.length; u < l; u++)
    r = a[u], s = r.property, o = r.value, i ? t(s, o, r) : o && (n || (n = {}), n[s] = o);
  return n;
}
eh.exports = RT;
eh.exports.default = RT;
var X$ = eh.exports;
const Z$ = /* @__PURE__ */ Ft(X$), Q$ = J$("start");
function J$(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function eB(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Ug(e.position) : "start" in e || "end" in e ? Ug(e) : "line" in e || "column" in e ? Uf(e) : "";
}
function Uf(e) {
  return Hg(e && e.line) + ":" + Hg(e && e.column);
}
function Ug(e) {
  return Uf(e && e.start) + "-" + Uf(e && e.end);
}
function Hg(e) {
  return e && typeof e == "number" ? e : 1;
}
class Sn extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let a = "", i = {}, s = !1;
    if (n && ("line" in n && "column" in n ? i = { place: n } : "start" in n && "end" in n ? i = { place: n } : "type" in n ? i = {
      ancestors: [n],
      place: n.position
    } : i = { ...n }), typeof t == "string" ? a = t : !i.cause && t && (s = !0, a = t.message, i.cause = t), !i.ruleId && !i.source && typeof r == "string") {
      const u = r.indexOf(":");
      u === -1 ? i.ruleId = r : (i.source = r.slice(0, u), i.ruleId = r.slice(u + 1));
    }
    if (!i.place && i.ancestors && i.ancestors) {
      const u = i.ancestors[i.ancestors.length - 1];
      u && (i.place = u.position);
    }
    const o = i.place && "start" in i.place ? i.place.start : i.place;
    this.ancestors = i.ancestors || void 0, this.cause = i.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file, this.message = a, this.line = o ? o.line : void 0, this.name = eB(i.place) || "1:1", this.place = i.place || void 0, this.reason = this.message, this.ruleId = i.ruleId || void 0, this.source = i.source || void 0, this.stack = s && i.cause && typeof i.cause.stack == "string" ? i.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
Sn.prototype.file = "";
Sn.prototype.name = "";
Sn.prototype.reason = "";
Sn.prototype.message = "";
Sn.prototype.stack = "";
Sn.prototype.column = void 0;
Sn.prototype.line = void 0;
Sn.prototype.ancestors = void 0;
Sn.prototype.cause = void 0;
Sn.prototype.fatal = void 0;
Sn.prototype.place = void 0;
Sn.prototype.ruleId = void 0;
Sn.prototype.source = void 0;
const th = {}.hasOwnProperty, tB = /* @__PURE__ */ new Map(), nB = /[A-Z]/g, rB = /-([a-z])/g, aB = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), iB = /* @__PURE__ */ new Set(["td", "th"]);
function sB(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = uB(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = oB(n, t.jsx, t.jsxs);
  }
  const a = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? Ha : zs,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, i = kT(a, e, void 0);
  return i && typeof i != "string" ? i : a.create(
    e,
    a.Fragment,
    { children: i || void 0 },
    void 0
  );
}
function kT(e, t, n) {
  if (t.type === "element" || t.type === "root") {
    const r = e.schema;
    let a = r;
    t.type === "element" && t.tagName.toLowerCase() === "svg" && r.space === "html" && (a = Ha, e.schema = a), e.ancestors.push(t);
    let i = lB(e, t);
    const s = cB(e, e.ancestors);
    let o = e.Fragment;
    if (e.ancestors.pop(), t.type === "element")
      if (i && aB.has(t.tagName) && (i = i.filter(function(u) {
        return typeof u == "string" ? !$$(u) : !0;
      })), th.call(e.components, t.tagName)) {
        const u = (
          /** @type {keyof JSX.IntrinsicElements} */
          t.tagName
        );
        o = e.components[u], typeof o != "string" && o !== e.Fragment && e.passNode && (s.node = t);
      } else
        o = t.tagName;
    if (i.length > 0) {
      const u = i.length > 1 ? i : i[0];
      u && (s.children = u);
    }
    return e.schema = r, e.create(t, o, s, n);
  }
  if (t.type === "text")
    return t.value;
}
function oB(e, t, n) {
  return r;
  function r(a, i, s, o) {
    const l = Array.isArray(s.children) ? n : t;
    return o ? l(i, s, o) : l(i, s);
  }
}
function uB(e, t) {
  return n;
  function n(r, a, i, s) {
    const o = Array.isArray(i.children), u = Q$(r);
    return t(
      a,
      i,
      s,
      o,
      {
        columnNumber: u ? u.column - 1 : void 0,
        fileName: e,
        lineNumber: u ? u.line : void 0
      },
      void 0
    );
  }
}
function lB(e, t) {
  const n = [];
  let r = -1;
  const a = e.passKeys ? /* @__PURE__ */ new Map() : tB;
  for (; ++r < t.children.length; ) {
    const i = t.children[r];
    let s;
    if (e.passKeys && i.type === "element") {
      const u = a.get(i.tagName) || 0;
      s = i.tagName + "-" + u, a.set(i.tagName, u + 1);
    }
    const o = kT(e, i, s);
    o !== void 0 && n.push(o);
  }
  return n;
}
function cB(e, t) {
  const n = t[t.length - 1], r = {};
  let a;
  if ("properties" in n && n.properties) {
    let i;
    for (a in n.properties)
      if (a !== "children" && th.call(n.properties, a)) {
        const s = fB(
          e,
          t,
          a,
          n.properties[a]
        );
        if (s) {
          const [o, u] = s;
          e.tableCellAlignToStyle && o === "align" && typeof u == "string" && iB.has(n.tagName) ? i = u : r[o] = u;
        }
      }
    if (i) {
      const s = (
        /** @type {Style} */
        r.style || (r.style = {})
      );
      s[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = i;
    }
  }
  return r;
}
function fB(e, t, n, r) {
  const a = Lu(e.schema, n);
  if (!(r == null || typeof r == "number" && Number.isNaN(r))) {
    if (Array.isArray(r) && (r = a.commaSeparated ? $v(r) : Bv(r)), a.property === "style") {
      let i = typeof r == "object" ? r : dB(e, t, String(r));
      return e.stylePropertyNameCase === "css" && (i = hB(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && a.space ? p5[a.property] || a.property : a.attribute,
      r
    ];
  }
}
function dB(e, t, n) {
  const r = {};
  try {
    Z$(n, a);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const s = (
        /** @type {Error} */
        i
      ), o = new Sn("Cannot parse `style` attribute", {
        ancestors: t,
        cause: s,
        source: "hast-util-to-jsx-runtime",
        ruleId: "style"
      });
      throw o.file = e.filePath || void 0, o.url = "https://github.com/syntax-tree/hast-util-to-jsx-runtime#cannot-parse-style-attribute", o;
    }
  }
  return r;
  function a(i, s) {
    let o = i;
    o.slice(0, 2) !== "--" && (o.slice(0, 4) === "-ms-" && (o = "ms-" + o.slice(4)), o = o.replace(rB, pB)), r[o] = s;
  }
}
function hB(e) {
  const t = {};
  let n;
  for (n in e)
    th.call(e, n) && (t[mB(n)] = e[n]);
  return t;
}
function mB(e) {
  let t = e.replace(nB, gB);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function pB(e, t) {
  return t.toUpperCase();
}
function gB(e) {
  return "-" + e.toLowerCase();
}
const Hl = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, bB = da(new RegExp("\\p{P}", "u")), An = da(/[A-Za-z]/), fn = da(/[\dA-Za-z]/), EB = da(/[#-'*+\--9=?A-Z^-~]/);
function cu(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const Hf = da(/\d/), vB = da(/[\dA-Fa-f]/), wT = da(/[!-/:-@[-`{-~]/);
function we(e) {
  return e !== null && e < -2;
}
function Ct(e) {
  return e !== null && (e < 0 || e === 32);
}
function nt(e) {
  return e === -2 || e === -1 || e === 32;
}
function ju(e) {
  return wT(e) || bB(e);
}
const $a = da(/\s/);
function da(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
const TB = { '"': "quot", "&": "amp", "<": "lt", ">": "gt" };
function AB(e) {
  return e.replace(/["&<>]/g, t);
  function t(n) {
    return "&" + TB[n] + ";";
  }
}
function _B(e, t) {
  const n = AB(Va(e || ""));
  if (!t)
    return n;
  const r = n.indexOf(":"), a = n.indexOf("?"), i = n.indexOf("#"), s = n.indexOf("/");
  return (
    // If there is no protocol, its relative.
    r < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    s > -1 && r > s || a > -1 && r > a || i > -1 && r > i || // It is a protocol, it should be allowed.
    t.test(n.slice(0, r)) ? n : ""
  );
}
function Va(e) {
  const t = [];
  let n = -1, r = 0, a = 0;
  for (; ++n < e.length; ) {
    const i = e.charCodeAt(n);
    let s = "";
    if (i === 37 && fn(e.charCodeAt(n + 1)) && fn(e.charCodeAt(n + 2)))
      a = 2;
    else if (i < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (s = String.fromCharCode(i));
    else if (i > 55295 && i < 57344) {
      const o = e.charCodeAt(n + 1);
      i < 56320 && o > 56319 && o < 57344 ? (s = String.fromCharCode(i, o), a = 1) : s = "";
    } else
      s = String.fromCharCode(i);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + a + 1, s = ""), a && (n += a, a = 0);
  }
  return t.join("") + e.slice(r);
}
const yB = {};
function SB(e, t) {
  const n = t || yB, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, a = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return DT(e, r, a);
}
function DT(e, t, n) {
  if (CB(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return jg(e.children, t, n);
  }
  return Array.isArray(e) ? jg(e, t, n) : "";
}
function jg(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; )
    r[a] = DT(e[a], t, n);
  return r.join("");
}
function CB(e) {
  return !!(e && typeof e == "object");
}
const zg = document.createElement("i");
function nh(e) {
  const t = "&" + e + ";";
  zg.innerHTML = t;
  const n = zg.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function Hn(e, t, n, r) {
  const a = e.length;
  let i = 0, s;
  if (t < 0 ? t = -t > a ? 0 : a + t : t = t > a ? a : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); i < r.length; )
      s = r.slice(i, i + 1e4), s.unshift(t, 0), e.splice(...s), i += 1e4, t += 1e4;
}
function Kn(e, t) {
  return e.length > 0 ? (Hn(e, e.length, 0, t), e) : t;
}
const Vg = {}.hasOwnProperty;
function PT(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    OB(t, e[n]);
  return t;
}
function OB(e, t) {
  let n;
  for (n in t) {
    const a = (Vg.call(e, n) ? e[n] : void 0) || (e[n] = {}), i = t[n];
    let s;
    if (i)
      for (s in i) {
        Vg.call(a, s) || (a[s] = []);
        const o = i[s];
        IB(
          // @ts-expect-error Looks like a list.
          a[s],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function IB(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Hn(e, 0, 0, r);
}
function LT(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function fr(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
function dt(e, t, n, r) {
  const a = r ? r - 1 : Number.POSITIVE_INFINITY;
  let i = 0;
  return s;
  function s(u) {
    return nt(u) ? (e.enter(n), o(u)) : t(u);
  }
  function o(u) {
    return nt(u) && i++ < a ? (e.consume(u), o) : (e.exit(n), t(u));
  }
}
const xB = {
  tokenize: NB
};
function NB(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    a
  );
  let n;
  return t;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), dt(e, t, "linePrefix");
  }
  function a(o) {
    return e.enter("paragraph"), i(o);
  }
  function i(o) {
    const u = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = u), n = u, s(o);
  }
  function s(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return we(o) ? (e.consume(o), e.exit("chunkText"), i) : (e.consume(o), s);
  }
}
const RB = {
  tokenize: kB
}, Gg = {
  tokenize: wB
};
function kB(e) {
  const t = this, n = [];
  let r = 0, a, i, s;
  return o;
  function o(I) {
    if (r < n.length) {
      const j = n[r];
      return t.containerState = j[1], e.attempt(
        j[0].continuation,
        u,
        l
      )(I);
    }
    return l(I);
  }
  function u(I) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, a && A();
      const j = t.events.length;
      let $ = j, _;
      for (; $--; )
        if (t.events[$][0] === "exit" && t.events[$][1].type === "chunkFlow") {
          _ = t.events[$][1].end;
          break;
        }
      N(r);
      let M = j;
      for (; M < t.events.length; )
        t.events[M][1].end = Object.assign({}, _), M++;
      return Hn(
        t.events,
        $ + 1,
        0,
        t.events.slice(j)
      ), t.events.length = M, l(I);
    }
    return o(I);
  }
  function l(I) {
    if (r === n.length) {
      if (!a)
        return p(I);
      if (a.currentConstruct && a.currentConstruct.concrete)
        return v(I);
      t.interrupt = !!(a.currentConstruct && !a._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      Gg,
      f,
      h
    )(I);
  }
  function f(I) {
    return a && A(), N(r), p(I);
  }
  function h(I) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, v(I);
  }
  function p(I) {
    return t.containerState = {}, e.attempt(
      Gg,
      b,
      v
    )(I);
  }
  function b(I) {
    return r++, n.push([t.currentConstruct, t.containerState]), p(I);
  }
  function v(I) {
    if (I === null) {
      a && A(), N(0), e.consume(I);
      return;
    }
    return a = a || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: i,
      _tokenizer: a
    }), E(I);
  }
  function E(I) {
    if (I === null) {
      y(e.exit("chunkFlow"), !0), N(0), e.consume(I);
      return;
    }
    return we(I) ? (e.consume(I), y(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, o) : (e.consume(I), E);
  }
  function y(I, j) {
    const $ = t.sliceStream(I);
    if (j && $.push(null), I.previous = i, i && (i.next = I), i = I, a.defineSkip(I.start), a.write($), t.parser.lazy[I.start.line]) {
      let _ = a.events.length;
      for (; _--; )
        if (
          // The token starts before the line ending
          a.events[_][1].start.offset < s && // and either is not ended yet
          (!a.events[_][1].end || // or ends after it.
          a.events[_][1].end.offset > s)
        )
          return;
      const M = t.events.length;
      let V = M, G, O;
      for (; V--; )
        if (t.events[V][0] === "exit" && t.events[V][1].type === "chunkFlow") {
          if (G) {
            O = t.events[V][1].end;
            break;
          }
          G = !0;
        }
      for (N(r), _ = M; _ < t.events.length; )
        t.events[_][1].end = Object.assign({}, O), _++;
      Hn(
        t.events,
        V + 1,
        0,
        t.events.slice(M)
      ), t.events.length = _;
    }
  }
  function N(I) {
    let j = n.length;
    for (; j-- > I; ) {
      const $ = n[j];
      t.containerState = $[1], $[0].exit.call(t, e);
    }
    n.length = I;
  }
  function A() {
    a.write([null]), i = void 0, a = void 0, t.containerState._closeFlow = void 0;
  }
}
function wB(e, t, n) {
  return dt(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function fu(e) {
  if (e === null || Ct(e) || $a(e))
    return 1;
  if (ju(e))
    return 2;
}
function zu(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; ) {
    const i = e[a].resolveAll;
    i && !r.includes(i) && (t = i(t, n), r.push(i));
  }
  return t;
}
const jf = {
  name: "attention",
  tokenize: PB,
  resolveAll: DB
};
function DB(e, t) {
  let n = -1, r, a, i, s, o, u, l, f;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          u = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const h = Object.assign({}, e[r][1].end), p = Object.assign({}, e[n][1].start);
          Yg(h, -u), Yg(p, u), s = {
            type: u > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: Object.assign({}, e[r][1].end)
          }, o = {
            type: u > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: p
          }, i = {
            type: u > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, a = {
            type: u > 1 ? "strong" : "emphasis",
            start: Object.assign({}, s.start),
            end: Object.assign({}, o.end)
          }, e[r][1].end = Object.assign({}, s.start), e[n][1].start = Object.assign({}, o.end), l = [], e[r][1].end.offset - e[r][1].start.offset && (l = Kn(l, [
            ["enter", e[r][1], t],
            ["exit", e[r][1], t]
          ])), l = Kn(l, [
            ["enter", a, t],
            ["enter", s, t],
            ["exit", s, t],
            ["enter", i, t]
          ]), l = Kn(
            l,
            zu(
              t.parser.constructs.insideSpan.null,
              e.slice(r + 1, n),
              t
            )
          ), l = Kn(l, [
            ["exit", i, t],
            ["enter", o, t],
            ["exit", o, t],
            ["exit", a, t]
          ]), e[n][1].end.offset - e[n][1].start.offset ? (f = 2, l = Kn(l, [
            ["enter", e[n][1], t],
            ["exit", e[n][1], t]
          ])) : f = 0, Hn(e, r - 1, n - r + 3, l), n = r + l.length - f - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function PB(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, a = fu(r);
  let i;
  return s;
  function s(u) {
    return i = u, e.enter("attentionSequence"), o(u);
  }
  function o(u) {
    if (u === i)
      return e.consume(u), o;
    const l = e.exit("attentionSequence"), f = fu(u), h = !f || f === 2 && a || n.includes(u), p = !a || a === 2 && f || n.includes(r);
    return l._open = !!(i === 42 ? h : h && (a || !p)), l._close = !!(i === 42 ? p : p && (f || !h)), t(u);
  }
}
function Yg(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const LB = {
  name: "autolink",
  tokenize: MB
};
function MB(e, t, n) {
  let r = 0;
  return a;
  function a(b) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(b), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), i;
  }
  function i(b) {
    return An(b) ? (e.consume(b), s) : l(b);
  }
  function s(b) {
    return b === 43 || b === 45 || b === 46 || fn(b) ? (r = 1, o(b)) : l(b);
  }
  function o(b) {
    return b === 58 ? (e.consume(b), r = 0, u) : (b === 43 || b === 45 || b === 46 || fn(b)) && r++ < 32 ? (e.consume(b), o) : (r = 0, l(b));
  }
  function u(b) {
    return b === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(b), e.exit("autolinkMarker"), e.exit("autolink"), t) : b === null || b === 32 || b === 60 || cu(b) ? n(b) : (e.consume(b), u);
  }
  function l(b) {
    return b === 64 ? (e.consume(b), f) : EB(b) ? (e.consume(b), l) : n(b);
  }
  function f(b) {
    return fn(b) ? h(b) : n(b);
  }
  function h(b) {
    return b === 46 ? (e.consume(b), r = 0, f) : b === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(b), e.exit("autolinkMarker"), e.exit("autolink"), t) : p(b);
  }
  function p(b) {
    if ((b === 45 || fn(b)) && r++ < 63) {
      const v = b === 45 ? p : h;
      return e.consume(b), v;
    }
    return n(b);
  }
}
const Ws = {
  tokenize: $B,
  partial: !0
};
function $B(e, t, n) {
  return r;
  function r(i) {
    return nt(i) ? dt(e, a, "linePrefix")(i) : a(i);
  }
  function a(i) {
    return i === null || we(i) ? t(i) : n(i);
  }
}
const MT = {
  name: "blockQuote",
  tokenize: BB,
  continuation: {
    tokenize: FB
  },
  exit: UB
};
function BB(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    if (s === 62) {
      const o = r.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), i;
    }
    return n(s);
  }
  function i(s) {
    return nt(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function FB(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return nt(s) ? dt(
      e,
      i,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(s) : i(s);
  }
  function i(s) {
    return e.attempt(MT, t, n)(s);
  }
}
function UB(e) {
  e.exit("blockQuote");
}
const $T = {
  name: "characterEscape",
  tokenize: HB
};
function HB(e, t, n) {
  return r;
  function r(i) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(i), e.exit("escapeMarker"), a;
  }
  function a(i) {
    return wT(i) ? (e.enter("characterEscapeValue"), e.consume(i), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(i);
  }
}
const BT = {
  name: "characterReference",
  tokenize: jB
};
function jB(e, t, n) {
  const r = this;
  let a = 0, i, s;
  return o;
  function o(h) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), u;
  }
  function u(h) {
    return h === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(h), e.exit("characterReferenceMarkerNumeric"), l) : (e.enter("characterReferenceValue"), i = 31, s = fn, f(h));
  }
  function l(h) {
    return h === 88 || h === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(h), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), i = 6, s = vB, f) : (e.enter("characterReferenceValue"), i = 7, s = Hf, f(h));
  }
  function f(h) {
    if (h === 59 && a) {
      const p = e.exit("characterReferenceValue");
      return s === fn && !nh(r.sliceSerialize(p)) ? n(h) : (e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(h) && a++ < i ? (e.consume(h), f) : n(h);
  }
}
const Wg = {
  tokenize: VB,
  partial: !0
}, qg = {
  name: "codeFenced",
  tokenize: zB,
  concrete: !0
};
function zB(e, t, n) {
  const r = this, a = {
    tokenize: $,
    partial: !0
  };
  let i = 0, s = 0, o;
  return u;
  function u(_) {
    return l(_);
  }
  function l(_) {
    const M = r.events[r.events.length - 1];
    return i = M && M[1].type === "linePrefix" ? M[2].sliceSerialize(M[1], !0).length : 0, o = _, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), f(_);
  }
  function f(_) {
    return _ === o ? (s++, e.consume(_), f) : s < 3 ? n(_) : (e.exit("codeFencedFenceSequence"), nt(_) ? dt(e, h, "whitespace")(_) : h(_));
  }
  function h(_) {
    return _ === null || we(_) ? (e.exit("codeFencedFence"), r.interrupt ? t(_) : e.check(Wg, E, j)(_)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), p(_));
  }
  function p(_) {
    return _ === null || we(_) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), h(_)) : nt(_) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), dt(e, b, "whitespace")(_)) : _ === 96 && _ === o ? n(_) : (e.consume(_), p);
  }
  function b(_) {
    return _ === null || we(_) ? h(_) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), v(_));
  }
  function v(_) {
    return _ === null || we(_) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), h(_)) : _ === 96 && _ === o ? n(_) : (e.consume(_), v);
  }
  function E(_) {
    return e.attempt(a, j, y)(_);
  }
  function y(_) {
    return e.enter("lineEnding"), e.consume(_), e.exit("lineEnding"), N;
  }
  function N(_) {
    return i > 0 && nt(_) ? dt(
      e,
      A,
      "linePrefix",
      i + 1
    )(_) : A(_);
  }
  function A(_) {
    return _ === null || we(_) ? e.check(Wg, E, j)(_) : (e.enter("codeFlowValue"), I(_));
  }
  function I(_) {
    return _ === null || we(_) ? (e.exit("codeFlowValue"), A(_)) : (e.consume(_), I);
  }
  function j(_) {
    return e.exit("codeFenced"), t(_);
  }
  function $(_, M, V) {
    let G = 0;
    return O;
    function O(R) {
      return _.enter("lineEnding"), _.consume(R), _.exit("lineEnding"), Q;
    }
    function Q(R) {
      return _.enter("codeFencedFence"), nt(R) ? dt(
        _,
        ee,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(R) : ee(R);
    }
    function ee(R) {
      return R === o ? (_.enter("codeFencedFenceSequence"), H(R)) : V(R);
    }
    function H(R) {
      return R === o ? (G++, _.consume(R), H) : G >= s ? (_.exit("codeFencedFenceSequence"), nt(R) ? dt(_, D, "whitespace")(R) : D(R)) : V(R);
    }
    function D(R) {
      return R === null || we(R) ? (_.exit("codeFencedFence"), M(R)) : V(R);
    }
  }
}
function VB(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i);
  }
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const jl = {
  name: "codeIndented",
  tokenize: YB
}, GB = {
  tokenize: WB,
  partial: !0
};
function YB(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return e.enter("codeIndented"), dt(e, i, "linePrefix", 5)(l);
  }
  function i(l) {
    const f = r.events[r.events.length - 1];
    return f && f[1].type === "linePrefix" && f[2].sliceSerialize(f[1], !0).length >= 4 ? s(l) : n(l);
  }
  function s(l) {
    return l === null ? u(l) : we(l) ? e.attempt(GB, s, u)(l) : (e.enter("codeFlowValue"), o(l));
  }
  function o(l) {
    return l === null || we(l) ? (e.exit("codeFlowValue"), s(l)) : (e.consume(l), o);
  }
  function u(l) {
    return e.exit("codeIndented"), t(l);
  }
}
function WB(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : we(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a) : dt(e, i, "linePrefix", 5)(s);
  }
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(s) : we(s) ? a(s) : n(s);
  }
}
const qB = {
  name: "codeText",
  tokenize: ZB,
  resolve: KB,
  previous: XB
};
function KB(e) {
  let t = e.length - 4, n = 3, r, a;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    a === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (a = r) : (r === t || e[r][1].type === "lineEnding") && (e[a][1].type = "codeTextData", r !== a + 2 && (e[a][1].end = e[r - 1][1].end, e.splice(a + 2, r - a - 2), t -= r - a - 2, r = a + 2), a = void 0);
  return e;
}
function XB(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function ZB(e, t, n) {
  let r = 0, a, i;
  return s;
  function s(h) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(h);
  }
  function o(h) {
    return h === 96 ? (e.consume(h), r++, o) : (e.exit("codeTextSequence"), u(h));
  }
  function u(h) {
    return h === null ? n(h) : h === 32 ? (e.enter("space"), e.consume(h), e.exit("space"), u) : h === 96 ? (i = e.enter("codeTextSequence"), a = 0, f(h)) : we(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), u) : (e.enter("codeTextData"), l(h));
  }
  function l(h) {
    return h === null || h === 32 || h === 96 || we(h) ? (e.exit("codeTextData"), u(h)) : (e.consume(h), l);
  }
  function f(h) {
    return h === 96 ? (e.consume(h), a++, f) : a === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(h)) : (i.type = "codeTextData", l(h));
  }
}
function FT(e) {
  const t = {};
  let n = -1, r, a, i, s, o, u, l;
  for (; ++n < e.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = e[n], n && r[1].type === "chunkFlow" && e[n - 1][1].type === "listItemPrefix" && (u = r[1]._tokenizer.events, i = 0, i < u.length && u[i][1].type === "lineEndingBlank" && (i += 2), i < u.length && u[i][1].type === "content"))
      for (; ++i < u.length && u[i][1].type !== "content"; )
        u[i][1].type === "chunkText" && (u[i][1]._isInFirstContentOfListItem = !0, i++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, QB(e, n)), n = t[n], l = !0);
    else if (r[1]._container) {
      for (i = n, a = void 0; i-- && (s = e[i], s[1].type === "lineEnding" || s[1].type === "lineEndingBlank"); )
        s[0] === "enter" && (a && (e[a][1].type = "lineEndingBlank"), s[1].type = "lineEnding", a = i);
      a && (r[1].end = Object.assign({}, e[a][1].start), o = e.slice(a, n), o.unshift(r), Hn(e, a, n - a + 1, o));
    }
  }
  return !l;
}
function QB(e, t) {
  const n = e[t][1], r = e[t][2];
  let a = t - 1;
  const i = [], s = n._tokenizer || r.parser[n.contentType](n.start), o = s.events, u = [], l = {};
  let f, h, p = -1, b = n, v = 0, E = 0;
  const y = [E];
  for (; b; ) {
    for (; e[++a][1] !== b; )
      ;
    i.push(a), b._tokenizer || (f = r.sliceStream(b), b.next || f.push(null), h && s.defineSkip(b.start), b._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(f), b._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), h = b, b = b.next;
  }
  for (b = n; ++p < o.length; )
    // Find a void token that includes a break.
    o[p][0] === "exit" && o[p - 1][0] === "enter" && o[p][1].type === o[p - 1][1].type && o[p][1].start.line !== o[p][1].end.line && (E = p + 1, y.push(E), b._tokenizer = void 0, b.previous = void 0, b = b.next);
  for (s.events = [], b ? (b._tokenizer = void 0, b.previous = void 0) : y.pop(), p = y.length; p--; ) {
    const N = o.slice(y[p], y[p + 1]), A = i.pop();
    u.unshift([A, A + N.length - 1]), Hn(e, A, 2, N);
  }
  for (p = -1; ++p < u.length; )
    l[v + u[p][0]] = v + u[p][1], v += u[p][1] - u[p][0] - 1;
  return l;
}
const JB = {
  tokenize: nF,
  resolve: tF
}, eF = {
  tokenize: rF,
  partial: !0
};
function tF(e) {
  return FT(e), e;
}
function nF(e, t) {
  let n;
  return r;
  function r(o) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), a(o);
  }
  function a(o) {
    return o === null ? i(o) : we(o) ? e.check(
      eF,
      s,
      i
    )(o) : (e.consume(o), a);
  }
  function i(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function s(o) {
    return e.consume(o), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, a;
  }
}
function rF(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), dt(e, i, "linePrefix");
  }
  function i(s) {
    if (s === null || we(s))
      return n(s);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function UT(e, t, n, r, a, i, s, o, u) {
  const l = u || Number.POSITIVE_INFINITY;
  let f = 0;
  return h;
  function h(N) {
    return N === 60 ? (e.enter(r), e.enter(a), e.enter(i), e.consume(N), e.exit(i), p) : N === null || N === 32 || N === 41 || cu(N) ? n(N) : (e.enter(r), e.enter(s), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), E(N));
  }
  function p(N) {
    return N === 62 ? (e.enter(i), e.consume(N), e.exit(i), e.exit(a), e.exit(r), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), b(N));
  }
  function b(N) {
    return N === 62 ? (e.exit("chunkString"), e.exit(o), p(N)) : N === null || N === 60 || we(N) ? n(N) : (e.consume(N), N === 92 ? v : b);
  }
  function v(N) {
    return N === 60 || N === 62 || N === 92 ? (e.consume(N), b) : b(N);
  }
  function E(N) {
    return !f && (N === null || N === 41 || Ct(N)) ? (e.exit("chunkString"), e.exit(o), e.exit(s), e.exit(r), t(N)) : f < l && N === 40 ? (e.consume(N), f++, E) : N === 41 ? (e.consume(N), f--, E) : N === null || N === 32 || N === 40 || cu(N) ? n(N) : (e.consume(N), N === 92 ? y : E);
  }
  function y(N) {
    return N === 40 || N === 41 || N === 92 ? (e.consume(N), E) : E(N);
  }
}
function HT(e, t, n, r, a, i) {
  const s = this;
  let o = 0, u;
  return l;
  function l(b) {
    return e.enter(r), e.enter(a), e.consume(b), e.exit(a), e.enter(i), f;
  }
  function f(b) {
    return o > 999 || b === null || b === 91 || b === 93 && !u || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    b === 94 && !o && "_hiddenFootnoteSupport" in s.parser.constructs ? n(b) : b === 93 ? (e.exit(i), e.enter(a), e.consume(b), e.exit(a), e.exit(r), t) : we(b) ? (e.enter("lineEnding"), e.consume(b), e.exit("lineEnding"), f) : (e.enter("chunkString", {
      contentType: "string"
    }), h(b));
  }
  function h(b) {
    return b === null || b === 91 || b === 93 || we(b) || o++ > 999 ? (e.exit("chunkString"), f(b)) : (e.consume(b), u || (u = !nt(b)), b === 92 ? p : h);
  }
  function p(b) {
    return b === 91 || b === 92 || b === 93 ? (e.consume(b), o++, h) : h(b);
  }
}
function jT(e, t, n, r, a, i) {
  let s;
  return o;
  function o(p) {
    return p === 34 || p === 39 || p === 40 ? (e.enter(r), e.enter(a), e.consume(p), e.exit(a), s = p === 40 ? 41 : p, u) : n(p);
  }
  function u(p) {
    return p === s ? (e.enter(a), e.consume(p), e.exit(a), e.exit(r), t) : (e.enter(i), l(p));
  }
  function l(p) {
    return p === s ? (e.exit(i), u(s)) : p === null ? n(p) : we(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), dt(e, l, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), f(p));
  }
  function f(p) {
    return p === s || p === null || we(p) ? (e.exit("chunkString"), l(p)) : (e.consume(p), p === 92 ? h : f);
  }
  function h(p) {
    return p === s || p === 92 ? (e.consume(p), f) : f(p);
  }
}
function cs(e, t) {
  let n;
  return r;
  function r(a) {
    return we(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), n = !0, r) : nt(a) ? dt(
      e,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(a) : t(a);
  }
}
const aF = {
  name: "definition",
  tokenize: sF
}, iF = {
  tokenize: oF,
  partial: !0
};
function sF(e, t, n) {
  const r = this;
  let a;
  return i;
  function i(b) {
    return e.enter("definition"), s(b);
  }
  function s(b) {
    return HT.call(
      r,
      e,
      o,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(b);
  }
  function o(b) {
    return a = fr(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), b === 58 ? (e.enter("definitionMarker"), e.consume(b), e.exit("definitionMarker"), u) : n(b);
  }
  function u(b) {
    return Ct(b) ? cs(e, l)(b) : l(b);
  }
  function l(b) {
    return UT(
      e,
      f,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(b);
  }
  function f(b) {
    return e.attempt(iF, h, h)(b);
  }
  function h(b) {
    return nt(b) ? dt(e, p, "whitespace")(b) : p(b);
  }
  function p(b) {
    return b === null || we(b) ? (e.exit("definition"), r.parser.defined.push(a), t(b)) : n(b);
  }
}
function oF(e, t, n) {
  return r;
  function r(o) {
    return Ct(o) ? cs(e, a)(o) : n(o);
  }
  function a(o) {
    return jT(
      e,
      i,
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o);
  }
  function i(o) {
    return nt(o) ? dt(e, s, "whitespace")(o) : s(o);
  }
  function s(o) {
    return o === null || we(o) ? t(o) : n(o);
  }
}
const uF = {
  name: "hardBreakEscape",
  tokenize: lF
};
function lF(e, t, n) {
  return r;
  function r(i) {
    return e.enter("hardBreakEscape"), e.consume(i), a;
  }
  function a(i) {
    return we(i) ? (e.exit("hardBreakEscape"), t(i)) : n(i);
  }
}
const cF = {
  name: "headingAtx",
  tokenize: dF,
  resolve: fF
};
function fF(e, t) {
  let n = e.length - 2, r = 3, a, i;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (a = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, i = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Hn(e, r, n - r + 1, [
    ["enter", a, t],
    ["enter", i, t],
    ["exit", i, t],
    ["exit", a, t]
  ])), e;
}
function dF(e, t, n) {
  let r = 0;
  return a;
  function a(f) {
    return e.enter("atxHeading"), i(f);
  }
  function i(f) {
    return e.enter("atxHeadingSequence"), s(f);
  }
  function s(f) {
    return f === 35 && r++ < 6 ? (e.consume(f), s) : f === null || Ct(f) ? (e.exit("atxHeadingSequence"), o(f)) : n(f);
  }
  function o(f) {
    return f === 35 ? (e.enter("atxHeadingSequence"), u(f)) : f === null || we(f) ? (e.exit("atxHeading"), t(f)) : nt(f) ? dt(e, o, "whitespace")(f) : (e.enter("atxHeadingText"), l(f));
  }
  function u(f) {
    return f === 35 ? (e.consume(f), u) : (e.exit("atxHeadingSequence"), o(f));
  }
  function l(f) {
    return f === null || f === 35 || Ct(f) ? (e.exit("atxHeadingText"), o(f)) : (e.consume(f), l);
  }
}
const hF = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Kg = ["pre", "script", "style", "textarea"], mF = {
  name: "htmlFlow",
  tokenize: EF,
  resolveTo: bF,
  concrete: !0
}, pF = {
  tokenize: TF,
  partial: !0
}, gF = {
  tokenize: vF,
  partial: !0
};
function bF(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function EF(e, t, n) {
  const r = this;
  let a, i, s, o, u;
  return l;
  function l(w) {
    return f(w);
  }
  function f(w) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(w), h;
  }
  function h(w) {
    return w === 33 ? (e.consume(w), p) : w === 47 ? (e.consume(w), i = !0, E) : w === 63 ? (e.consume(w), a = 3, r.interrupt ? t : C) : An(w) ? (e.consume(w), s = String.fromCharCode(w), y) : n(w);
  }
  function p(w) {
    return w === 45 ? (e.consume(w), a = 2, b) : w === 91 ? (e.consume(w), a = 5, o = 0, v) : An(w) ? (e.consume(w), a = 4, r.interrupt ? t : C) : n(w);
  }
  function b(w) {
    return w === 45 ? (e.consume(w), r.interrupt ? t : C) : n(w);
  }
  function v(w) {
    const Ne = "CDATA[";
    return w === Ne.charCodeAt(o++) ? (e.consume(w), o === Ne.length ? r.interrupt ? t : ee : v) : n(w);
  }
  function E(w) {
    return An(w) ? (e.consume(w), s = String.fromCharCode(w), y) : n(w);
  }
  function y(w) {
    if (w === null || w === 47 || w === 62 || Ct(w)) {
      const Ne = w === 47, Re = s.toLowerCase();
      return !Ne && !i && Kg.includes(Re) ? (a = 1, r.interrupt ? t(w) : ee(w)) : hF.includes(s.toLowerCase()) ? (a = 6, Ne ? (e.consume(w), N) : r.interrupt ? t(w) : ee(w)) : (a = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(w) : i ? A(w) : I(w));
    }
    return w === 45 || fn(w) ? (e.consume(w), s += String.fromCharCode(w), y) : n(w);
  }
  function N(w) {
    return w === 62 ? (e.consume(w), r.interrupt ? t : ee) : n(w);
  }
  function A(w) {
    return nt(w) ? (e.consume(w), A) : O(w);
  }
  function I(w) {
    return w === 47 ? (e.consume(w), O) : w === 58 || w === 95 || An(w) ? (e.consume(w), j) : nt(w) ? (e.consume(w), I) : O(w);
  }
  function j(w) {
    return w === 45 || w === 46 || w === 58 || w === 95 || fn(w) ? (e.consume(w), j) : $(w);
  }
  function $(w) {
    return w === 61 ? (e.consume(w), _) : nt(w) ? (e.consume(w), $) : I(w);
  }
  function _(w) {
    return w === null || w === 60 || w === 61 || w === 62 || w === 96 ? n(w) : w === 34 || w === 39 ? (e.consume(w), u = w, M) : nt(w) ? (e.consume(w), _) : V(w);
  }
  function M(w) {
    return w === u ? (e.consume(w), u = null, G) : w === null || we(w) ? n(w) : (e.consume(w), M);
  }
  function V(w) {
    return w === null || w === 34 || w === 39 || w === 47 || w === 60 || w === 61 || w === 62 || w === 96 || Ct(w) ? $(w) : (e.consume(w), V);
  }
  function G(w) {
    return w === 47 || w === 62 || nt(w) ? I(w) : n(w);
  }
  function O(w) {
    return w === 62 ? (e.consume(w), Q) : n(w);
  }
  function Q(w) {
    return w === null || we(w) ? ee(w) : nt(w) ? (e.consume(w), Q) : n(w);
  }
  function ee(w) {
    return w === 45 && a === 2 ? (e.consume(w), Y) : w === 60 && a === 1 ? (e.consume(w), P) : w === 62 && a === 4 ? (e.consume(w), pe) : w === 63 && a === 3 ? (e.consume(w), C) : w === 93 && a === 5 ? (e.consume(w), W) : we(w) && (a === 6 || a === 7) ? (e.exit("htmlFlowData"), e.check(
      pF,
      me,
      H
    )(w)) : w === null || we(w) ? (e.exit("htmlFlowData"), H(w)) : (e.consume(w), ee);
  }
  function H(w) {
    return e.check(
      gF,
      D,
      me
    )(w);
  }
  function D(w) {
    return e.enter("lineEnding"), e.consume(w), e.exit("lineEnding"), R;
  }
  function R(w) {
    return w === null || we(w) ? H(w) : (e.enter("htmlFlowData"), ee(w));
  }
  function Y(w) {
    return w === 45 ? (e.consume(w), C) : ee(w);
  }
  function P(w) {
    return w === 47 ? (e.consume(w), s = "", Z) : ee(w);
  }
  function Z(w) {
    if (w === 62) {
      const Ne = s.toLowerCase();
      return Kg.includes(Ne) ? (e.consume(w), pe) : ee(w);
    }
    return An(w) && s.length < 8 ? (e.consume(w), s += String.fromCharCode(w), Z) : ee(w);
  }
  function W(w) {
    return w === 93 ? (e.consume(w), C) : ee(w);
  }
  function C(w) {
    return w === 62 ? (e.consume(w), pe) : w === 45 && a === 2 ? (e.consume(w), C) : ee(w);
  }
  function pe(w) {
    return w === null || we(w) ? (e.exit("htmlFlowData"), me(w)) : (e.consume(w), pe);
  }
  function me(w) {
    return e.exit("htmlFlow"), t(w);
  }
}
function vF(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return we(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : n(s);
  }
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function TF(e, t, n) {
  return r;
  function r(a) {
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), e.attempt(Ws, t, n);
  }
}
const AF = {
  name: "htmlText",
  tokenize: _F
};
function _F(e, t, n) {
  const r = this;
  let a, i, s;
  return o;
  function o(C) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(C), u;
  }
  function u(C) {
    return C === 33 ? (e.consume(C), l) : C === 47 ? (e.consume(C), $) : C === 63 ? (e.consume(C), I) : An(C) ? (e.consume(C), V) : n(C);
  }
  function l(C) {
    return C === 45 ? (e.consume(C), f) : C === 91 ? (e.consume(C), i = 0, v) : An(C) ? (e.consume(C), A) : n(C);
  }
  function f(C) {
    return C === 45 ? (e.consume(C), b) : n(C);
  }
  function h(C) {
    return C === null ? n(C) : C === 45 ? (e.consume(C), p) : we(C) ? (s = h, P(C)) : (e.consume(C), h);
  }
  function p(C) {
    return C === 45 ? (e.consume(C), b) : h(C);
  }
  function b(C) {
    return C === 62 ? Y(C) : C === 45 ? p(C) : h(C);
  }
  function v(C) {
    const pe = "CDATA[";
    return C === pe.charCodeAt(i++) ? (e.consume(C), i === pe.length ? E : v) : n(C);
  }
  function E(C) {
    return C === null ? n(C) : C === 93 ? (e.consume(C), y) : we(C) ? (s = E, P(C)) : (e.consume(C), E);
  }
  function y(C) {
    return C === 93 ? (e.consume(C), N) : E(C);
  }
  function N(C) {
    return C === 62 ? Y(C) : C === 93 ? (e.consume(C), N) : E(C);
  }
  function A(C) {
    return C === null || C === 62 ? Y(C) : we(C) ? (s = A, P(C)) : (e.consume(C), A);
  }
  function I(C) {
    return C === null ? n(C) : C === 63 ? (e.consume(C), j) : we(C) ? (s = I, P(C)) : (e.consume(C), I);
  }
  function j(C) {
    return C === 62 ? Y(C) : I(C);
  }
  function $(C) {
    return An(C) ? (e.consume(C), _) : n(C);
  }
  function _(C) {
    return C === 45 || fn(C) ? (e.consume(C), _) : M(C);
  }
  function M(C) {
    return we(C) ? (s = M, P(C)) : nt(C) ? (e.consume(C), M) : Y(C);
  }
  function V(C) {
    return C === 45 || fn(C) ? (e.consume(C), V) : C === 47 || C === 62 || Ct(C) ? G(C) : n(C);
  }
  function G(C) {
    return C === 47 ? (e.consume(C), Y) : C === 58 || C === 95 || An(C) ? (e.consume(C), O) : we(C) ? (s = G, P(C)) : nt(C) ? (e.consume(C), G) : Y(C);
  }
  function O(C) {
    return C === 45 || C === 46 || C === 58 || C === 95 || fn(C) ? (e.consume(C), O) : Q(C);
  }
  function Q(C) {
    return C === 61 ? (e.consume(C), ee) : we(C) ? (s = Q, P(C)) : nt(C) ? (e.consume(C), Q) : G(C);
  }
  function ee(C) {
    return C === null || C === 60 || C === 61 || C === 62 || C === 96 ? n(C) : C === 34 || C === 39 ? (e.consume(C), a = C, H) : we(C) ? (s = ee, P(C)) : nt(C) ? (e.consume(C), ee) : (e.consume(C), D);
  }
  function H(C) {
    return C === a ? (e.consume(C), a = void 0, R) : C === null ? n(C) : we(C) ? (s = H, P(C)) : (e.consume(C), H);
  }
  function D(C) {
    return C === null || C === 34 || C === 39 || C === 60 || C === 61 || C === 96 ? n(C) : C === 47 || C === 62 || Ct(C) ? G(C) : (e.consume(C), D);
  }
  function R(C) {
    return C === 47 || C === 62 || Ct(C) ? G(C) : n(C);
  }
  function Y(C) {
    return C === 62 ? (e.consume(C), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(C);
  }
  function P(C) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(C), e.exit("lineEnding"), Z;
  }
  function Z(C) {
    return nt(C) ? dt(
      e,
      W,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(C) : W(C);
  }
  function W(C) {
    return e.enter("htmlTextData"), s(C);
  }
}
const rh = {
  name: "labelEnd",
  tokenize: xF,
  resolveTo: IF,
  resolveAll: OF
}, yF = {
  tokenize: NF
}, SF = {
  tokenize: RF
}, CF = {
  tokenize: kF
};
function OF(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function IF(e, t) {
  let n = e.length, r = 0, a, i, s, o;
  for (; n--; )
    if (a = e[n][1], i) {
      if (a.type === "link" || a.type === "labelLink" && a._inactive)
        break;
      e[n][0] === "enter" && a.type === "labelLink" && (a._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (a.type === "labelImage" || a.type === "labelLink") && !a._balanced && (i = n, a.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else
      a.type === "labelEnd" && (s = n);
  const u = {
    type: e[i][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, l = {
    type: "label",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[s][1].end)
  }, f = {
    type: "labelText",
    start: Object.assign({}, e[i + r + 2][1].end),
    end: Object.assign({}, e[s - 2][1].start)
  };
  return o = [
    ["enter", u, t],
    ["enter", l, t]
  ], o = Kn(o, e.slice(i + 1, i + r + 3)), o = Kn(o, [["enter", f, t]]), o = Kn(
    o,
    zu(
      t.parser.constructs.insideSpan.null,
      e.slice(i + r + 4, s - 3),
      t
    )
  ), o = Kn(o, [
    ["exit", f, t],
    e[s - 2],
    e[s - 1],
    ["exit", l, t]
  ]), o = Kn(o, e.slice(s + 1)), o = Kn(o, [["exit", u, t]]), Hn(e, i, e.length, o), e;
}
function xF(e, t, n) {
  const r = this;
  let a = r.events.length, i, s;
  for (; a--; )
    if ((r.events[a][1].type === "labelImage" || r.events[a][1].type === "labelLink") && !r.events[a][1]._balanced) {
      i = r.events[a][1];
      break;
    }
  return o;
  function o(p) {
    return i ? i._inactive ? h(p) : (s = r.parser.defined.includes(
      fr(
        r.sliceSerialize({
          start: i.end,
          end: r.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(p), e.exit("labelMarker"), e.exit("labelEnd"), u) : n(p);
  }
  function u(p) {
    return p === 40 ? e.attempt(
      yF,
      f,
      s ? f : h
    )(p) : p === 91 ? e.attempt(
      SF,
      f,
      s ? l : h
    )(p) : s ? f(p) : h(p);
  }
  function l(p) {
    return e.attempt(
      CF,
      f,
      h
    )(p);
  }
  function f(p) {
    return t(p);
  }
  function h(p) {
    return i._balanced = !0, n(p);
  }
}
function NF(e, t, n) {
  return r;
  function r(h) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), a;
  }
  function a(h) {
    return Ct(h) ? cs(e, i)(h) : i(h);
  }
  function i(h) {
    return h === 41 ? f(h) : UT(
      e,
      s,
      o,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(h);
  }
  function s(h) {
    return Ct(h) ? cs(e, u)(h) : f(h);
  }
  function o(h) {
    return n(h);
  }
  function u(h) {
    return h === 34 || h === 39 || h === 40 ? jT(
      e,
      l,
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(h) : f(h);
  }
  function l(h) {
    return Ct(h) ? cs(e, f)(h) : f(h);
  }
  function f(h) {
    return h === 41 ? (e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), e.exit("resource"), t) : n(h);
  }
}
function RF(e, t, n) {
  const r = this;
  return a;
  function a(o) {
    return HT.call(
      r,
      e,
      i,
      s,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o);
  }
  function i(o) {
    return r.parser.defined.includes(
      fr(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(o) : n(o);
  }
  function s(o) {
    return n(o);
  }
}
function kF(e, t, n) {
  return r;
  function r(i) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), a;
  }
  function a(i) {
    return i === 93 ? (e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), e.exit("reference"), t) : n(i);
  }
}
const wF = {
  name: "labelStartImage",
  tokenize: DF,
  resolveAll: rh.resolveAll
};
function DF(e, t, n) {
  const r = this;
  return a;
  function a(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), i;
  }
  function i(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), s) : n(o);
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const PF = {
  name: "labelStartLink",
  tokenize: LF,
  resolveAll: rh.resolveAll
};
function LF(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), i;
  }
  function i(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const zl = {
  name: "lineEnding",
  tokenize: MF
};
function MF(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), dt(e, t, "linePrefix");
  }
}
const Io = {
  name: "thematicBreak",
  tokenize: $F
};
function $F(e, t, n) {
  let r = 0, a;
  return i;
  function i(l) {
    return e.enter("thematicBreak"), s(l);
  }
  function s(l) {
    return a = l, o(l);
  }
  function o(l) {
    return l === a ? (e.enter("thematicBreakSequence"), u(l)) : r >= 3 && (l === null || we(l)) ? (e.exit("thematicBreak"), t(l)) : n(l);
  }
  function u(l) {
    return l === a ? (e.consume(l), r++, u) : (e.exit("thematicBreakSequence"), nt(l) ? dt(e, o, "whitespace")(l) : o(l));
  }
}
const Nn = {
  name: "list",
  tokenize: UF,
  continuation: {
    tokenize: HF
  },
  exit: zF
}, BF = {
  tokenize: VF,
  partial: !0
}, FF = {
  tokenize: jF,
  partial: !0
};
function UF(e, t, n) {
  const r = this, a = r.events[r.events.length - 1];
  let i = a && a[1].type === "linePrefix" ? a[2].sliceSerialize(a[1], !0).length : 0, s = 0;
  return o;
  function o(b) {
    const v = r.containerState.type || (b === 42 || b === 43 || b === 45 ? "listUnordered" : "listOrdered");
    if (v === "listUnordered" ? !r.containerState.marker || b === r.containerState.marker : Hf(b)) {
      if (r.containerState.type || (r.containerState.type = v, e.enter(v, {
        _container: !0
      })), v === "listUnordered")
        return e.enter("listItemPrefix"), b === 42 || b === 45 ? e.check(Io, n, l)(b) : l(b);
      if (!r.interrupt || b === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), u(b);
    }
    return n(b);
  }
  function u(b) {
    return Hf(b) && ++s < 10 ? (e.consume(b), u) : (!r.interrupt || s < 2) && (r.containerState.marker ? b === r.containerState.marker : b === 41 || b === 46) ? (e.exit("listItemValue"), l(b)) : n(b);
  }
  function l(b) {
    return e.enter("listItemMarker"), e.consume(b), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || b, e.check(
      Ws,
      // Cant be empty when interrupting.
      r.interrupt ? n : f,
      e.attempt(
        BF,
        p,
        h
      )
    );
  }
  function f(b) {
    return r.containerState.initialBlankLine = !0, i++, p(b);
  }
  function h(b) {
    return nt(b) ? (e.enter("listItemPrefixWhitespace"), e.consume(b), e.exit("listItemPrefixWhitespace"), p) : n(b);
  }
  function p(b) {
    return r.containerState.size = i + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(b);
  }
}
function HF(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Ws, a, i);
  function a(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, dt(
      e,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(o);
  }
  function i(o) {
    return r.containerState.furtherBlankLines || !nt(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(FF, t, s)(o));
  }
  function s(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, dt(
      e,
      e.attempt(Nn, t, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o);
  }
}
function jF(e, t, n) {
  const r = this;
  return dt(
    e,
    a,
    "listItemIndent",
    r.containerState.size + 1
  );
  function a(i) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(i) : n(i);
  }
}
function zF(e) {
  e.exit(this.containerState.type);
}
function VF(e, t, n) {
  const r = this;
  return dt(
    e,
    a,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function a(i) {
    const s = r.events[r.events.length - 1];
    return !nt(i) && s && s[1].type === "listItemPrefixWhitespace" ? t(i) : n(i);
  }
}
const Xg = {
  name: "setextUnderline",
  tokenize: YF,
  resolveTo: GF
};
function GF(e, t) {
  let n = e.length, r, a, i;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (a = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !i && e[n][1].type === "definition" && (i = n);
  const s = {
    type: "setextHeading",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[a][1].type = "setextHeadingText", i ? (e.splice(a, 0, ["enter", s, t]), e.splice(i + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[i][1].end)) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function YF(e, t, n) {
  const r = this;
  let a;
  return i;
  function i(l) {
    let f = r.events.length, h;
    for (; f--; )
      if (r.events[f][1].type !== "lineEnding" && r.events[f][1].type !== "linePrefix" && r.events[f][1].type !== "content") {
        h = r.events[f][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (e.enter("setextHeadingLine"), a = l, s(l)) : n(l);
  }
  function s(l) {
    return e.enter("setextHeadingLineSequence"), o(l);
  }
  function o(l) {
    return l === a ? (e.consume(l), o) : (e.exit("setextHeadingLineSequence"), nt(l) ? dt(e, u, "lineSuffix")(l) : u(l));
  }
  function u(l) {
    return l === null || we(l) ? (e.exit("setextHeadingLine"), t(l)) : n(l);
  }
}
const WF = {
  tokenize: qF
};
function qF(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    Ws,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      a,
      dt(
        e,
        e.attempt(
          this.parser.constructs.flow,
          a,
          e.attempt(JB, a)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(i) {
    if (i === null) {
      e.consume(i);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(i), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function a(i) {
    if (i === null) {
      e.consume(i);
      return;
    }
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const KF = {
  resolveAll: VT()
}, XF = zT("string"), ZF = zT("text");
function zT(e) {
  return {
    tokenize: t,
    resolveAll: VT(
      e === "text" ? QF : void 0
    )
  };
  function t(n) {
    const r = this, a = this.parser.constructs[e], i = n.attempt(a, s, o);
    return s;
    function s(f) {
      return l(f) ? i(f) : o(f);
    }
    function o(f) {
      if (f === null) {
        n.consume(f);
        return;
      }
      return n.enter("data"), n.consume(f), u;
    }
    function u(f) {
      return l(f) ? (n.exit("data"), i(f)) : (n.consume(f), u);
    }
    function l(f) {
      if (f === null)
        return !0;
      const h = a[f];
      let p = -1;
      if (h)
        for (; ++p < h.length; ) {
          const b = h[p];
          if (!b.previous || b.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function VT(e) {
  return t;
  function t(n, r) {
    let a = -1, i;
    for (; ++a <= n.length; )
      i === void 0 ? n[a] && n[a][1].type === "data" && (i = a, a++) : (!n[a] || n[a][1].type !== "data") && (a !== i + 2 && (n[i][1].end = n[a - 1][1].end, n.splice(i + 2, a - i - 2), a = i + 2), i = void 0);
    return e ? e(n, r) : n;
  }
}
function QF(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], a = t.sliceStream(r);
      let i = a.length, s = -1, o = 0, u;
      for (; i--; ) {
        const l = a[i];
        if (typeof l == "string") {
          for (s = l.length; l.charCodeAt(s - 1) === 32; )
            o++, s--;
          if (s)
            break;
          s = -1;
        } else if (l === -2)
          u = !0, o++;
        else if (l !== -1) {
          i++;
          break;
        }
      }
      if (o) {
        const l = {
          type: n === e.length || u || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o,
            _index: r.start._index + i,
            _bufferIndex: i ? s : r.start._bufferIndex + s
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, l.start), r.start.offset === r.end.offset ? Object.assign(r, l) : (e.splice(
          n,
          0,
          ["enter", l, t],
          ["exit", l, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function JF(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const a = {}, i = [];
  let s = [], o = [];
  const u = {
    consume: A,
    enter: I,
    exit: j,
    attempt: M($),
    check: M(_),
    interrupt: M(_, {
      interrupt: !0
    })
  }, l = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: b,
    sliceSerialize: p,
    now: v,
    defineSkip: E,
    write: h
  };
  let f = t.tokenize.call(l, u);
  return t.resolveAll && i.push(t), l;
  function h(Q) {
    return s = Kn(s, Q), y(), s[s.length - 1] !== null ? [] : (V(t, 0), l.events = zu(i, l.events, l), l.events);
  }
  function p(Q, ee) {
    return t7(b(Q), ee);
  }
  function b(Q) {
    return e7(s, Q);
  }
  function v() {
    const { line: Q, column: ee, offset: H, _index: D, _bufferIndex: R } = r;
    return {
      line: Q,
      column: ee,
      offset: H,
      _index: D,
      _bufferIndex: R
    };
  }
  function E(Q) {
    a[Q.line] = Q.column, O();
  }
  function y() {
    let Q;
    for (; r._index < s.length; ) {
      const ee = s[r._index];
      if (typeof ee == "string")
        for (Q = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === Q && r._bufferIndex < ee.length; )
          N(ee.charCodeAt(r._bufferIndex));
      else
        N(ee);
    }
  }
  function N(Q) {
    f = f(Q);
  }
  function A(Q) {
    we(Q) ? (r.line++, r.column = 1, r.offset += Q === -3 ? 2 : 1, O()) : Q !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === s[r._index].length && (r._bufferIndex = -1, r._index++)), l.previous = Q;
  }
  function I(Q, ee) {
    const H = ee || {};
    return H.type = Q, H.start = v(), l.events.push(["enter", H, l]), o.push(H), H;
  }
  function j(Q) {
    const ee = o.pop();
    return ee.end = v(), l.events.push(["exit", ee, l]), ee;
  }
  function $(Q, ee) {
    V(Q, ee.from);
  }
  function _(Q, ee) {
    ee.restore();
  }
  function M(Q, ee) {
    return H;
    function H(D, R, Y) {
      let P, Z, W, C;
      return Array.isArray(D) ? me(D) : "tokenize" in D ? (
        // @ts-expect-error Looks like a construct.
        me([D])
      ) : pe(D);
      function pe(De) {
        return Qe;
        function Qe(Ue) {
          const Ae = Ue !== null && De[Ue], Me = Ue !== null && De.null, it = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Ae) ? Ae : Ae ? [Ae] : [],
            ...Array.isArray(Me) ? Me : Me ? [Me] : []
          ];
          return me(it)(Ue);
        }
      }
      function me(De) {
        return P = De, Z = 0, De.length === 0 ? Y : w(De[Z]);
      }
      function w(De) {
        return Qe;
        function Qe(Ue) {
          return C = G(), W = De, De.partial || (l.currentConstruct = De), De.name && l.parser.constructs.disable.null.includes(De.name) ? Re() : De.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            ee ? Object.assign(Object.create(l), ee) : l,
            u,
            Ne,
            Re
          )(Ue);
        }
      }
      function Ne(De) {
        return Q(W, C), R;
      }
      function Re(De) {
        return C.restore(), ++Z < P.length ? w(P[Z]) : Y;
      }
    }
  }
  function V(Q, ee) {
    Q.resolveAll && !i.includes(Q) && i.push(Q), Q.resolve && Hn(
      l.events,
      ee,
      l.events.length - ee,
      Q.resolve(l.events.slice(ee), l)
    ), Q.resolveTo && (l.events = Q.resolveTo(l.events, l));
  }
  function G() {
    const Q = v(), ee = l.previous, H = l.currentConstruct, D = l.events.length, R = Array.from(o);
    return {
      restore: Y,
      from: D
    };
    function Y() {
      r = Q, l.previous = ee, l.currentConstruct = H, l.events.length = D, o = R, O();
    }
  }
  function O() {
    r.line in a && r.column < 2 && (r.column = a[r.line], r.offset += a[r.line] - 1);
  }
}
function e7(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, a = t.end._index, i = t.end._bufferIndex;
  let s;
  if (n === a)
    s = [e[n].slice(r, i)];
  else {
    if (s = e.slice(n, a), r > -1) {
      const o = s[0];
      typeof o == "string" ? s[0] = o.slice(r) : s.shift();
    }
    i > 0 && s.push(e[a].slice(0, i));
  }
  return s;
}
function t7(e, t) {
  let n = -1;
  const r = [];
  let a;
  for (; ++n < e.length; ) {
    const i = e[n];
    let s;
    if (typeof i == "string")
      s = i;
    else
      switch (i) {
        case -5: {
          s = "\r";
          break;
        }
        case -4: {
          s = `
`;
          break;
        }
        case -3: {
          s = `\r
`;
          break;
        }
        case -2: {
          s = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && a)
            continue;
          s = " ";
          break;
        }
        default:
          s = String.fromCharCode(i);
      }
    a = i === -2, r.push(s);
  }
  return r.join("");
}
const n7 = {
  42: Nn,
  43: Nn,
  45: Nn,
  48: Nn,
  49: Nn,
  50: Nn,
  51: Nn,
  52: Nn,
  53: Nn,
  54: Nn,
  55: Nn,
  56: Nn,
  57: Nn,
  62: MT
}, r7 = {
  91: aF
}, a7 = {
  [-2]: jl,
  [-1]: jl,
  32: jl
}, i7 = {
  35: cF,
  42: Io,
  45: [Xg, Io],
  60: mF,
  61: Xg,
  95: Io,
  96: qg,
  126: qg
}, s7 = {
  38: BT,
  92: $T
}, o7 = {
  [-5]: zl,
  [-4]: zl,
  [-3]: zl,
  33: wF,
  38: BT,
  42: jf,
  60: [LB, AF],
  91: PF,
  92: [uF, $T],
  93: rh,
  95: jf,
  96: qB
}, u7 = {
  null: [jf, KF]
}, l7 = {
  null: [42, 95]
}, c7 = {
  null: []
}, f7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: l7,
  contentInitial: r7,
  disable: c7,
  document: n7,
  flow: i7,
  flowInitial: a7,
  insideSpan: u7,
  string: s7,
  text: o7
}, Symbol.toStringTag, { value: "Module" }));
function d7(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    PT([f7, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: a(xB),
    document: a(RB),
    flow: a(WF),
    string: a(XF),
    text: a(ZF)
  };
  return r;
  function a(i) {
    return s;
    function s(o) {
      return JF(r, i, o);
    }
  }
}
function h7(e) {
  for (; !FT(e); )
    ;
  return e;
}
const Zg = /[\0\t\n\r]/g;
function m7() {
  let e = 1, t = "", n = !0, r;
  return a;
  function a(i, s, o) {
    const u = [];
    let l, f, h, p, b;
    for (i = t + (typeof i == "string" ? i.toString() : new TextDecoder(s || void 0).decode(i)), h = 0, t = "", n && (i.charCodeAt(0) === 65279 && h++, n = void 0); h < i.length; ) {
      if (Zg.lastIndex = h, l = Zg.exec(i), p = l && l.index !== void 0 ? l.index : i.length, b = i.charCodeAt(p), !l) {
        t = i.slice(h);
        break;
      }
      if (b === 10 && h === p && r)
        u.push(-3), r = void 0;
      else
        switch (r && (u.push(-5), r = void 0), h < p && (u.push(i.slice(h, p)), e += p - h), b) {
          case 0: {
            u.push(65533), e++;
            break;
          }
          case 9: {
            for (f = Math.ceil(e / 4) * 4, u.push(-2); e++ < f; )
              u.push(-1);
            break;
          }
          case 10: {
            u.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      h = p + 1;
    }
    return o && (r && u.push(-5), t && u.push(t), u.push(null)), u;
  }
}
const p7 = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function g7(e) {
  return e.replace(p7, b7);
}
function b7(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const a = n.charCodeAt(1), i = a === 120 || a === 88;
    return LT(n.slice(i ? 2 : 1), i ? 16 : 10);
  }
  return nh(n) || e;
}
function xo(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Qg(e.position) : "start" in e || "end" in e ? Qg(e) : "line" in e || "column" in e ? zf(e) : "";
}
function zf(e) {
  return Jg(e && e.line) + ":" + Jg(e && e.column);
}
function Qg(e) {
  return zf(e && e.start) + "-" + zf(e && e.end);
}
function Jg(e) {
  return e && typeof e == "number" ? e : 1;
}
const GT = {}.hasOwnProperty;
function E7(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), v7(n)(
    h7(
      d7(n).document().write(m7()(e, t, !0))
    )
  );
}
function v7(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: i(Gn),
      autolinkProtocol: G,
      autolinkEmail: G,
      atxHeading: i(Xt),
      blockQuote: i(Ae),
      characterEscape: G,
      characterReference: G,
      codeFenced: i(Me),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: i(Me, s),
      codeText: i(it, s),
      codeTextData: G,
      data: G,
      codeFlowValue: G,
      definition: i(pt),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: i(Kt),
      hardBreakEscape: i(un),
      hardBreakTrailing: i(un),
      htmlFlow: i(wn, s),
      htmlFlowData: G,
      htmlText: i(wn, s),
      htmlTextData: G,
      image: i(br),
      label: s,
      link: i(Gn),
      listItem: i(Dn),
      listItemValue: p,
      listOrdered: i(Nr, h),
      listUnordered: i(Nr),
      paragraph: i(Er),
      reference: w,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: i(Xt),
      strong: i(Pn),
      thematicBreak: i(Rr)
    },
    exit: {
      atxHeading: u(),
      atxHeadingSequence: $,
      autolink: u(),
      autolinkEmail: Ue,
      autolinkProtocol: Qe,
      blockQuote: u(),
      characterEscapeValue: O,
      characterReferenceMarkerHexadecimal: Re,
      characterReferenceMarkerNumeric: Re,
      characterReferenceValue: De,
      codeFenced: u(y),
      codeFencedFence: E,
      codeFencedFenceInfo: b,
      codeFencedFenceMeta: v,
      codeFlowValue: O,
      codeIndented: u(N),
      codeText: u(R),
      codeTextData: O,
      data: O,
      definition: u(),
      definitionDestinationString: j,
      definitionLabelString: A,
      definitionTitleString: I,
      emphasis: u(),
      hardBreakEscape: u(ee),
      hardBreakTrailing: u(ee),
      htmlFlow: u(H),
      htmlFlowData: O,
      htmlText: u(D),
      htmlTextData: O,
      image: u(P),
      label: W,
      labelText: Z,
      lineEnding: Q,
      link: u(Y),
      listItem: u(),
      listOrdered: u(),
      listUnordered: u(),
      paragraph: u(),
      referenceString: Ne,
      resourceDestinationString: C,
      resourceTitleString: pe,
      resource: me,
      setextHeading: u(V),
      setextHeadingLineSequence: M,
      setextHeadingText: _,
      strong: u(),
      thematicBreak: u()
    }
  };
  YT(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(ne) {
    let be = {
      type: "root",
      children: []
    };
    const ke = {
      stack: [be],
      tokenStack: [],
      config: t,
      enter: o,
      exit: l,
      buffer: s,
      resume: f,
      data: n
    }, Pe = [];
    let Je = -1;
    for (; ++Je < ne.length; )
      if (ne[Je][1].type === "listOrdered" || ne[Je][1].type === "listUnordered")
        if (ne[Je][0] === "enter")
          Pe.push(Je);
        else {
          const Vt = Pe.pop();
          Je = a(ne, Vt, Je);
        }
    for (Je = -1; ++Je < ne.length; ) {
      const Vt = t[ne[Je][0]];
      GT.call(Vt, ne[Je][1].type) && Vt[ne[Je][1].type].call(
        Object.assign(
          {
            sliceSerialize: ne[Je][2].sliceSerialize
          },
          ke
        ),
        ne[Je][1]
      );
    }
    if (ke.tokenStack.length > 0) {
      const Vt = ke.tokenStack[ke.tokenStack.length - 1];
      (Vt[1] || e1).call(ke, void 0, Vt[0]);
    }
    for (be.position = {
      start: Kr(
        ne.length > 0 ? ne[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: Kr(
        ne.length > 0 ? ne[ne.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, Je = -1; ++Je < t.transforms.length; )
      be = t.transforms[Je](be) || be;
    return be;
  }
  function a(ne, be, ke) {
    let Pe = be - 1, Je = -1, Vt = !1, Gt, tn, Yn, Cn;
    for (; ++Pe <= ke; ) {
      const qt = ne[Pe];
      switch (qt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          qt[0] === "enter" ? Je++ : Je--, Cn = void 0;
          break;
        }
        case "lineEndingBlank": {
          qt[0] === "enter" && (Gt && !Cn && !Je && !Yn && (Yn = Pe), Cn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Cn = void 0;
      }
      if (!Je && qt[0] === "enter" && qt[1].type === "listItemPrefix" || Je === -1 && qt[0] === "exit" && (qt[1].type === "listUnordered" || qt[1].type === "listOrdered")) {
        if (Gt) {
          let Wn = Pe;
          for (tn = void 0; Wn--; ) {
            const ln = ne[Wn];
            if (ln[1].type === "lineEnding" || ln[1].type === "lineEndingBlank") {
              if (ln[0] === "exit")
                continue;
              tn && (ne[tn][1].type = "lineEndingBlank", Vt = !0), ln[1].type = "lineEnding", tn = Wn;
            } else if (!(ln[1].type === "linePrefix" || ln[1].type === "blockQuotePrefix" || ln[1].type === "blockQuotePrefixWhitespace" || ln[1].type === "blockQuoteMarker" || ln[1].type === "listItemIndent"))
              break;
          }
          Yn && (!tn || Yn < tn) && (Gt._spread = !0), Gt.end = Object.assign(
            {},
            tn ? ne[tn][1].start : qt[1].end
          ), ne.splice(tn || Pe, 0, ["exit", Gt, qt[2]]), Pe++, ke++;
        }
        if (qt[1].type === "listItemPrefix") {
          const Wn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, qt[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          Gt = Wn, ne.splice(Pe, 0, ["enter", Wn, qt[2]]), Pe++, ke++, Yn = void 0, Cn = !0;
        }
      }
    }
    return ne[be][1]._spread = Vt, ke;
  }
  function i(ne, be) {
    return ke;
    function ke(Pe) {
      o.call(this, ne(Pe), Pe), be && be.call(this, Pe);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(ne, be, ke) {
    this.stack[this.stack.length - 1].children.push(ne), this.stack.push(ne), this.tokenStack.push([be, ke]), ne.position = {
      start: Kr(be.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function u(ne) {
    return be;
    function be(ke) {
      ne && ne.call(this, ke), l.call(this, ke);
    }
  }
  function l(ne, be) {
    const ke = this.stack.pop(), Pe = this.tokenStack.pop();
    if (Pe)
      Pe[0].type !== ne.type && (be ? be.call(this, ne, Pe[0]) : (Pe[1] || e1).call(this, ne, Pe[0]));
    else
      throw new Error(
        "Cannot close `" + ne.type + "` (" + xo({
          start: ne.start,
          end: ne.end
        }) + "): its not open"
      );
    ke.position.end = Kr(ne.end);
  }
  function f() {
    return SB(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function p(ne) {
    if (this.data.expectingFirstListItemValue) {
      const be = this.stack[this.stack.length - 2];
      be.start = Number.parseInt(this.sliceSerialize(ne), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function b() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.lang = ne;
  }
  function v() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.meta = ne;
  }
  function E() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function y() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.value = ne.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function N() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.value = ne.replace(/(\r?\n|\r)$/g, "");
  }
  function A(ne) {
    const be = this.resume(), ke = this.stack[this.stack.length - 1];
    ke.label = be, ke.identifier = fr(
      this.sliceSerialize(ne)
    ).toLowerCase();
  }
  function I() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.title = ne;
  }
  function j() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.url = ne;
  }
  function $(ne) {
    const be = this.stack[this.stack.length - 1];
    if (!be.depth) {
      const ke = this.sliceSerialize(ne).length;
      be.depth = ke;
    }
  }
  function _() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function M(ne) {
    const be = this.stack[this.stack.length - 1];
    be.depth = this.sliceSerialize(ne).codePointAt(0) === 61 ? 1 : 2;
  }
  function V() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function G(ne) {
    const ke = this.stack[this.stack.length - 1].children;
    let Pe = ke[ke.length - 1];
    (!Pe || Pe.type !== "text") && (Pe = er(), Pe.position = {
      start: Kr(ne.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, ke.push(Pe)), this.stack.push(Pe);
  }
  function O(ne) {
    const be = this.stack.pop();
    be.value += this.sliceSerialize(ne), be.position.end = Kr(ne.end);
  }
  function Q(ne) {
    const be = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const ke = be.children[be.children.length - 1];
      ke.position.end = Kr(ne.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(be.type) && (G.call(this, ne), O.call(this, ne));
  }
  function ee() {
    this.data.atHardBreak = !0;
  }
  function H() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.value = ne;
  }
  function D() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.value = ne;
  }
  function R() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.value = ne;
  }
  function Y() {
    const ne = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const be = this.data.referenceType || "shortcut";
      ne.type += "Reference", ne.referenceType = be, delete ne.url, delete ne.title;
    } else
      delete ne.identifier, delete ne.label;
    this.data.referenceType = void 0;
  }
  function P() {
    const ne = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const be = this.data.referenceType || "shortcut";
      ne.type += "Reference", ne.referenceType = be, delete ne.url, delete ne.title;
    } else
      delete ne.identifier, delete ne.label;
    this.data.referenceType = void 0;
  }
  function Z(ne) {
    const be = this.sliceSerialize(ne), ke = this.stack[this.stack.length - 2];
    ke.label = g7(be), ke.identifier = fr(be).toLowerCase();
  }
  function W() {
    const ne = this.stack[this.stack.length - 1], be = this.resume(), ke = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, ke.type === "link") {
      const Pe = ne.children;
      ke.children = Pe;
    } else
      ke.alt = be;
  }
  function C() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.url = ne;
  }
  function pe() {
    const ne = this.resume(), be = this.stack[this.stack.length - 1];
    be.title = ne;
  }
  function me() {
    this.data.inReference = void 0;
  }
  function w() {
    this.data.referenceType = "collapsed";
  }
  function Ne(ne) {
    const be = this.resume(), ke = this.stack[this.stack.length - 1];
    ke.label = be, ke.identifier = fr(
      this.sliceSerialize(ne)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function Re(ne) {
    this.data.characterReferenceType = ne.type;
  }
  function De(ne) {
    const be = this.sliceSerialize(ne), ke = this.data.characterReferenceType;
    let Pe;
    ke ? (Pe = LT(
      be,
      ke === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : Pe = nh(be);
    const Je = this.stack.pop();
    Je.value += Pe, Je.position.end = Kr(ne.end);
  }
  function Qe(ne) {
    O.call(this, ne);
    const be = this.stack[this.stack.length - 1];
    be.url = this.sliceSerialize(ne);
  }
  function Ue(ne) {
    O.call(this, ne);
    const be = this.stack[this.stack.length - 1];
    be.url = "mailto:" + this.sliceSerialize(ne);
  }
  function Ae() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Me() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function it() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function pt() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Kt() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Xt() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function un() {
    return {
      type: "break"
    };
  }
  function wn() {
    return {
      type: "html",
      value: ""
    };
  }
  function br() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Gn() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Nr(ne) {
    return {
      type: "list",
      ordered: ne.type === "listOrdered",
      start: null,
      spread: ne._spread,
      children: []
    };
  }
  function Dn(ne) {
    return {
      type: "listItem",
      spread: ne._spread,
      checked: null,
      children: []
    };
  }
  function Er() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Pn() {
    return {
      type: "strong",
      children: []
    };
  }
  function er() {
    return {
      type: "text",
      value: ""
    };
  }
  function Rr() {
    return {
      type: "thematicBreak"
    };
  }
}
function Kr(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function YT(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? YT(e, r) : T7(e, r);
  }
}
function T7(e, t) {
  let n;
  for (n in t)
    if (GT.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function e1(e, t) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + xo({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + xo({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + xo({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function A7(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return E7(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function _7(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function y7(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function S7(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let a = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (a.data = { meta: t.meta }), e.patch(t, a), a = e.applyData(t, a), a = { type: "element", tagName: "pre", properties: {}, children: [a] }, e.patch(t, a), a;
}
function C7(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function O7(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function I7(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), a = Va(r.toLowerCase()), i = e.footnoteOrder.indexOf(r);
  let s, o = e.footnoteCounts.get(r);
  o === void 0 ? (o = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = i + 1, o += 1, e.footnoteCounts.set(r, o);
  const u = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + a,
      id: n + "fnref-" + a + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, u);
  const l = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [u]
  };
  return e.patch(t, l), e.applyData(t, l);
}
function x7(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function N7(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function WT(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const a = e.all(t), i = a[0];
  i && i.type === "text" ? i.value = "[" + i.value : a.unshift({ type: "text", value: "[" });
  const s = a[a.length - 1];
  return s && s.type === "text" ? s.value += r : a.push({ type: "text", value: r }), a;
}
function R7(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return WT(e, t);
  const a = { src: Va(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (a.title = r.title);
  const i = { type: "element", tagName: "img", properties: a, children: [] };
  return e.patch(t, i), e.applyData(t, i);
}
function k7(e, t) {
  const n = { src: Va(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function w7(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function D7(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return WT(e, t);
  const a = { href: Va(r.url || "") };
  r.title !== null && r.title !== void 0 && (a.title = r.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: a,
    children: e.all(t)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function P7(e, t) {
  const n = { href: Va(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function L7(e, t, n) {
  const r = e.all(t), a = n ? M7(n) : qT(t), i = {}, s = [];
  if (typeof t.checked == "boolean") {
    const f = r[0];
    let h;
    f && f.type === "element" && f.tagName === "p" ? h = f : (h = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), i.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const f = r[o];
    (a || o !== 0 || f.type !== "element" || f.tagName !== "p") && s.push({ type: "text", value: `
` }), f.type === "element" && f.tagName === "p" && !a ? s.push(...f.children) : s.push(f);
  }
  const u = r[r.length - 1];
  u && (a || u.type !== "element" || u.tagName !== "p") && s.push({ type: "text", value: `
` });
  const l = { type: "element", tagName: "li", properties: i, children: s };
  return e.patch(t, l), e.applyData(t, l);
}
function M7(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = qT(n[r]);
  }
  return t;
}
function qT(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function $7(e, t) {
  const n = {}, r = e.all(t);
  let a = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++a < r.length; ) {
    const s = r[a];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const i = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function B7(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function F7(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function U7(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const KT = ZT("end"), XT = ZT("start");
function ZT(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function H7(e) {
  const t = XT(e), n = KT(e);
  if (t && n)
    return { start: t, end: n };
}
function j7(e, t) {
  const n = e.all(t), r = n.shift(), a = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), a.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, o = XT(t.children[1]), u = KT(t.children[t.children.length - 1]);
    o && u && (s.position = { start: o, end: u }), a.push(s);
  }
  const i = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(a, !0)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function z7(e, t, n) {
  const r = n ? n.children : void 0, i = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, o = s ? s.length : t.children.length;
  let u = -1;
  const l = [];
  for (; ++u < o; ) {
    const h = t.children[u], p = {}, b = s ? s[u] : void 0;
    b && (p.align = b);
    let v = { type: "element", tagName: i, properties: p, children: [] };
    h && (v.children = e.all(h), e.patch(h, v), v = e.applyData(h, v)), l.push(v);
  }
  const f = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(l, !0)
  };
  return e.patch(t, f), e.applyData(t, f);
}
function V7(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const t1 = 9, n1 = 32;
function G7(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), a = 0;
  const i = [];
  for (; r; )
    i.push(
      r1(t.slice(a, r.index), a > 0, !0),
      r[0]
    ), a = r.index + r[0].length, r = n.exec(t);
  return i.push(r1(t.slice(a), a > 0, !1)), i.join("");
}
function r1(e, t, n) {
  let r = 0, a = e.length;
  if (t) {
    let i = e.codePointAt(r);
    for (; i === t1 || i === n1; )
      r++, i = e.codePointAt(r);
  }
  if (n) {
    let i = e.codePointAt(a - 1);
    for (; i === t1 || i === n1; )
      a--, i = e.codePointAt(a - 1);
  }
  return a > r ? e.slice(r, a) : "";
}
function Y7(e, t) {
  const n = { type: "text", value: G7(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function W7(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const q7 = {
  blockquote: _7,
  break: y7,
  code: S7,
  delete: C7,
  emphasis: O7,
  footnoteReference: I7,
  heading: x7,
  html: N7,
  imageReference: R7,
  image: k7,
  inlineCode: w7,
  linkReference: D7,
  link: P7,
  listItem: L7,
  list: $7,
  paragraph: B7,
  // @ts-expect-error: root is different, but hard to type.
  root: F7,
  strong: U7,
  table: j7,
  tableCell: V7,
  tableRow: z7,
  text: Y7,
  thematicBreak: W7,
  toml: bo,
  yaml: bo,
  definition: bo,
  footnoteDefinition: bo
};
function bo() {
}
function K7(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function X7(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function Z7(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || K7, r = e.options.footnoteBackLabel || X7, a = e.options.footnoteLabel || "Footnotes", i = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let u = -1;
  for (; ++u < e.footnoteOrder.length; ) {
    const l = e.footnoteById.get(e.footnoteOrder[u]);
    if (!l)
      continue;
    const f = e.all(l), h = String(l.identifier).toUpperCase(), p = Va(h.toLowerCase());
    let b = 0;
    const v = [], E = e.footnoteCounts.get(h);
    for (; E !== void 0 && ++b <= E; ) {
      v.length > 0 && v.push({ type: "text", value: " " });
      let A = typeof n == "string" ? n : n(u, b);
      typeof A == "string" && (A = { type: "text", value: A }), v.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + p + (b > 1 ? "-" + b : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(u, b),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(A) ? A : [A]
      });
    }
    const y = f[f.length - 1];
    if (y && y.type === "element" && y.tagName === "p") {
      const A = y.children[y.children.length - 1];
      A && A.type === "text" ? A.value += " " : y.children.push({ type: "text", value: " " }), y.children.push(...v);
    } else
      f.push(...v);
    const N = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + p },
      children: e.wrap(f, !0)
    };
    e.patch(l, N), o.push(N);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: i,
          properties: {
            ...Ma(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: a }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
function Q7(e, t, n, r) {
  let a, i, s;
  typeof t == "function" && typeof n != "function" ? (i = void 0, s = t, a = n) : (i = t, s = n, a = r), Gs(e, i, o, a);
  function o(u, l) {
    const f = l[l.length - 1], h = f ? f.children.indexOf(u) : void 0;
    return s(u, h, f);
  }
}
const Vf = {}.hasOwnProperty, J7 = {};
function eU(e, t) {
  const n = t || J7, r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = { ...q7, ...n.handlers }, o = {
    all: l,
    applyData: nU,
    definitionById: r,
    footnoteById: a,
    footnoteCounts: i,
    footnoteOrder: [],
    handlers: s,
    one: u,
    options: n,
    patch: tU,
    wrap: aU
  };
  return Q7(e, function(f) {
    if (f.type === "definition" || f.type === "footnoteDefinition") {
      const h = f.type === "definition" ? r : a, p = String(f.identifier).toUpperCase();
      h.has(p) || h.set(p, f);
    }
  }), o;
  function u(f, h) {
    const p = f.type, b = o.handlers[p];
    if (Vf.call(o.handlers, p) && b)
      return b(o, f, h);
    if (o.options.passThrough && o.options.passThrough.includes(p)) {
      if ("children" in f) {
        const { children: E, ...y } = f, N = Ma(y);
        return N.children = o.all(f), N;
      }
      return Ma(f);
    }
    return (o.options.unknownHandler || rU)(o, f, h);
  }
  function l(f) {
    const h = [];
    if ("children" in f) {
      const p = f.children;
      let b = -1;
      for (; ++b < p.length; ) {
        const v = o.one(p[b], f);
        if (v) {
          if (b && p[b - 1].type === "break" && (!Array.isArray(v) && v.type === "text" && (v.value = a1(v.value)), !Array.isArray(v) && v.type === "element")) {
            const E = v.children[0];
            E && E.type === "text" && (E.value = a1(E.value));
          }
          Array.isArray(v) ? h.push(...v) : h.push(v);
        }
      }
    }
    return h;
  }
}
function tU(e, t) {
  e.position && (t.position = H7(e));
}
function nU(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, a = e.data.hChildren, i = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && i && Object.assign(n.properties, Ma(i)), "children" in n && n.children && a !== null && a !== void 0 && (n.children = a);
  }
  return n;
}
function rU(e, t) {
  const n = t.data || {}, r = "value" in t && !(Vf.call(n, "hProperties") || Vf.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function aU(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function a1(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function i1(e, t) {
  const n = eU(e, t), r = n.one(e, void 0), a = Z7(n), i = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return a && i.children.push({ type: "text", value: `
` }, a), i;
}
function iU(e, t) {
  return e && "run" in e ? async function(n, r) {
    const a = (
      /** @type {HastRoot} */
      i1(n, t)
    );
    await e.run(a, r);
  } : function(n) {
    return (
      /** @type {HastRoot} */
      i1(n, t || e)
    );
  };
}
function s1(e) {
  if (e)
    throw e;
}
var No = Object.prototype.hasOwnProperty, QT = Object.prototype.toString, o1 = Object.defineProperty, u1 = Object.getOwnPropertyDescriptor, l1 = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : QT.call(t) === "[object Array]";
}, c1 = function(t) {
  if (!t || QT.call(t) !== "[object Object]")
    return !1;
  var n = No.call(t, "constructor"), r = t.constructor && t.constructor.prototype && No.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var a;
  for (a in t)
    ;
  return typeof a > "u" || No.call(t, a);
}, f1 = function(t, n) {
  o1 && n.name === "__proto__" ? o1(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, d1 = function(t, n) {
  if (n === "__proto__")
    if (No.call(t, n)) {
      if (u1)
        return u1(t, n).value;
    } else
      return;
  return t[n];
}, sU = function e() {
  var t, n, r, a, i, s, o = arguments[0], u = 1, l = arguments.length, f = !1;
  for (typeof o == "boolean" && (f = o, o = arguments[1] || {}, u = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); u < l; ++u)
    if (t = arguments[u], t != null)
      for (n in t)
        r = d1(o, n), a = d1(t, n), o !== a && (f && a && (c1(a) || (i = l1(a))) ? (i ? (i = !1, s = r && l1(r) ? r : []) : s = r && c1(r) ? r : {}, f1(o, { name: n, newValue: e(f, s, a) })) : typeof a < "u" && f1(o, { name: n, newValue: a }));
  return o;
};
const Vl = /* @__PURE__ */ Ft(sU);
function Gf(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function oU() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...a) {
    let i = -1;
    const s = a.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    o(null, ...a);
    function o(u, ...l) {
      const f = e[++i];
      let h = -1;
      if (u) {
        s(u);
        return;
      }
      for (; ++h < a.length; )
        (l[h] === null || l[h] === void 0) && (l[h] = a[h]);
      a = l, f ? uU(f, o)(...l) : s(null, ...l);
    }
  }
  function r(a) {
    if (typeof a != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + a
      );
    return e.push(a), t;
  }
}
function uU(e, t) {
  let n;
  return r;
  function r(...s) {
    const o = e.length > s.length;
    let u;
    o && s.push(a);
    try {
      u = e.apply(this, s);
    } catch (l) {
      const f = (
        /** @type {Error} */
        l
      );
      if (o && n)
        throw f;
      return a(f);
    }
    o || (u instanceof Promise ? u.then(i, a) : u instanceof Error ? a(u) : i(u));
  }
  function a(s, ...o) {
    n || (n = !0, t(s, ...o));
  }
  function i(s) {
    a(null, s);
  }
}
const vr = { basename: lU, dirname: cU, extname: fU, join: dU, sep: "/" };
function lU(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  qs(e);
  let n = 0, r = -1, a = e.length, i;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; a--; )
      if (e.codePointAt(a) === 47) {
        if (i) {
          n = a + 1;
          break;
        }
      } else
        r < 0 && (i = !0, r = a + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, o = t.length - 1;
  for (; a--; )
    if (e.codePointAt(a) === 47) {
      if (i) {
        n = a + 1;
        break;
      }
    } else
      s < 0 && (i = !0, s = a + 1), o > -1 && (e.codePointAt(a) === t.codePointAt(o--) ? o < 0 && (r = a) : (o = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function cU(e) {
  if (qs(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else
      r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function fU(e) {
  qs(e);
  let t = e.length, n = -1, r = 0, a = -1, i = 0, s;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), o === 46 ? a < 0 ? a = t : i !== 1 && (i = 1) : a > -1 && (i = -1);
  }
  return a < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  i === 0 || // The (right-most) trimmed path component is exactly `..`.
  i === 1 && a === n - 1 && a === r + 1 ? "" : e.slice(a, n);
}
function dU(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    qs(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : hU(n);
}
function hU(e) {
  qs(e);
  const t = e.codePointAt(0) === 47;
  let n = mU(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function mU(e, t) {
  let n = "", r = 0, a = -1, i = 0, s = -1, o, u;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      o = e.codePointAt(s);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(a === s - 1 || i === 1))
        if (a !== s - 1 && i === 2) {
          if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              if (u = n.lastIndexOf("/"), u !== n.length - 1) {
                u < 0 ? (n = "", r = 0) : (n = n.slice(0, u), r = n.length - 1 - n.lastIndexOf("/")), a = s, i = 0;
                continue;
              }
            } else if (n.length > 0) {
              n = "", r = 0, a = s, i = 0;
              continue;
            }
          }
          t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
        } else
          n.length > 0 ? n += "/" + e.slice(a + 1, s) : n = e.slice(a + 1, s), r = s - a - 1;
      a = s, i = 0;
    } else
      o === 46 && i > -1 ? i++ : i = -1;
  }
  return n;
}
function qs(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const pU = { cwd: gU };
function gU() {
  return "/";
}
function Yf(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function bU(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Yf(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return EU(e);
}
function EU(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const a = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw a.code = "ERR_INVALID_FILE_URL_PATH", a;
      }
    }
  return decodeURIComponent(t);
}
const Gl = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class JT {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Yf(t) ? n = { path: t } : typeof t == "string" || vU(t) ? n = { value: t } : n = t : n = {}, this.cwd = pU.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Gl.length; ) {
      const i = Gl[r];
      i in n && n[i] !== void 0 && n[i] !== null && (this[i] = i === "history" ? [...n[i]] : n[i]);
    }
    let a;
    for (a in n)
      Gl.includes(a) || (this[a] = n[a]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? vr.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    Wl(t, "basename"), Yl(t, "basename"), this.path = vr.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? vr.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    h1(this.basename, "dirname"), this.path = vr.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? vr.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (Yl(t, "extname"), h1(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = vr.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Yf(t) && (t = bU(t)), Wl(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? vr.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    Wl(t, "stem"), Yl(t, "stem"), this.path = vr.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const a = this.message(t, n, r);
    throw a.fatal = !0, a;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const a = this.message(t, n, r);
    return a.fatal = void 0, a;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const a = new Sn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (a.name = this.path + ":" + a.name, a.file = this.path), a.fatal = !1, this.messages.push(a), a;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function Yl(e, t) {
  if (e && e.includes(vr.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + vr.sep + "`"
    );
}
function Wl(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function h1(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function vU(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const TU = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), a = r[e], i = function() {
      return a.apply(i, arguments);
    };
    Object.setPrototypeOf(i, r);
    const s = Object.getOwnPropertyNames(a);
    for (const o of s) {
      const u = Object.getOwnPropertyDescriptor(a, o);
      u && Object.defineProperty(i, o, u);
    }
    return i;
  }
), AU = {}.hasOwnProperty;
class ah extends TU {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = oU();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new ah()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(Vl(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * >  **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * >  **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (Xl("data", this.frozen), this.namespace[t] = n, this) : AU.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Xl("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const a = n.call(t, ...r);
      typeof a == "function" && this.transformers.use(a);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * >  **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Eo(t), r = this.parser || this.Parser;
    return ql("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * >  **Note**: `process` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), ql("process", this.parser || this.Parser), Kl("process", this.compiler || this.Compiler), n ? a(void 0, n) : new Promise(a);
    function a(i, s) {
      const o = Eo(t), u = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(u, o, function(f, h, p) {
        if (f || !h || !p)
          return l(f);
        const b = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), v = r.stringify(b, p);
        SU(v) ? p.value = v : p.result = v, l(
          f,
          /** @type {VFileWithOutput<CompileResult>} */
          p
        );
      });
      function l(f, h) {
        f || !h ? s(f) : i ? i(h) : n(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), ql("processSync", this.parser || this.Parser), Kl("processSync", this.compiler || this.Compiler), this.process(t, a), p1("processSync", "process", n), r;
    function a(i, s) {
      n = !0, s1(i), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * >  **Note**: `run` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    m1(t), this.freeze();
    const a = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? i(void 0, r) : new Promise(i);
    function i(s, o) {
      const u = Eo(n);
      a.run(t, u, l);
      function l(f, h, p) {
        const b = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || t
        );
        f ? o(f) : s ? s(b) : r(void 0, b, p);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, a;
    return this.run(t, n, i), p1("runSync", "run", r), a;
    function i(s, o) {
      s1(s), a = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * >  **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Eo(n), a = this.compiler || this.Compiler;
    return Kl("stringify", a), m1(t), a(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * >  **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, a = this.namespace;
    if (Xl("use", this.frozen), t != null)
      if (typeof t == "function")
        u(t, n);
      else if (typeof t == "object")
        Array.isArray(t) ? o(t) : s(t);
      else
        throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function i(l) {
      if (typeof l == "function")
        u(l, []);
      else if (typeof l == "object")
        if (Array.isArray(l)) {
          const [f, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            l
          );
          u(f, h);
        } else
          s(l);
      else
        throw new TypeError("Expected usable value, not `" + l + "`");
    }
    function s(l) {
      if (!("plugins" in l) && !("settings" in l))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(l.plugins), l.settings && (a.settings = Vl(!0, a.settings, l.settings));
    }
    function o(l) {
      let f = -1;
      if (l != null)
        if (Array.isArray(l))
          for (; ++f < l.length; ) {
            const h = l[f];
            i(h);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + l + "`");
    }
    function u(l, f) {
      let h = -1, p = -1;
      for (; ++h < r.length; )
        if (r[h][0] === l) {
          p = h;
          break;
        }
      if (p === -1)
        r.push([l, ...f]);
      else if (f.length > 0) {
        let [b, ...v] = f;
        const E = r[p][1];
        Gf(E) && Gf(b) && (b = Vl(!0, E, b)), r[p] = [l, b, ...v];
      }
    }
  }
}
const _U = new ah().freeze();
function ql(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function Kl(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Xl(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function m1(e) {
  if (!Gf(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function p1(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Eo(e) {
  return yU(e) ? e : new JT(e);
}
function yU(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function SU(e) {
  return typeof e == "string" || CU(e);
}
function CU(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
function OU(e, t, n, r) {
  let a, i, s;
  typeof t == "function" && typeof n != "function" ? (i = void 0, s = t, a = n) : (i = t, s = n, a = r), Gs(e, i, o, a);
  function o(u, l) {
    const f = l[l.length - 1], h = f ? f.children.indexOf(u) : void 0;
    return s(u, h, f);
  }
}
const g1 = {}.hasOwnProperty, IU = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", b1 = [], E1 = { allowDangerousHtml: !0 }, xU = /^(https?|ircs?|mailto|xmpp)$/i, NU = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function RU(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", a = e.className, i = e.components, s = e.disallowedElements, o = e.rehypePlugins || b1, u = e.remarkPlugins || b1, l = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...E1 } : E1, f = e.skipHtml, h = e.unwrapDisallowed, p = e.urlTransform || kU, b = _U().use(A7).use(u).use(iU, l).use(o), v = new JT();
  typeof r == "string" && (v.value = r);
  for (const A of NU)
    Object.hasOwn(e, A.from) && ("" + A.from + (A.to ? "use `" + A.to + "` instead" : "remove it") + IU + A.id, void 0);
  const E = b.parse(v);
  let y = b.runSync(E, v);
  return a && (y = {
    type: "element",
    tagName: "div",
    properties: { className: a },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      y.type === "root" ? y.children : [y]
    )
  }), OU(y, N), sB(y, {
    Fragment: J.Fragment,
    components: i,
    ignoreInvalidStyle: !0,
    jsx: J.jsx,
    jsxs: J.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function N(A, I, j) {
    if (A.type === "raw" && j && typeof I == "number")
      return f ? j.children.splice(I, 1) : j.children[I] = { type: "text", value: A.value }, I;
    if (A.type === "element") {
      let $;
      for ($ in Hl)
        if (g1.call(Hl, $) && g1.call(A.properties, $)) {
          const _ = A.properties[$], M = Hl[$];
          (M === null || M.includes(A.tagName)) && (A.properties[$] = p(String(_ || ""), $, A));
        }
    }
    if (A.type === "element") {
      let $ = t ? !t.includes(A.tagName) : s ? s.includes(A.tagName) : !1;
      if (!$ && n && typeof I == "number" && ($ = !n(A, I, j)), $ && j && typeof I == "number")
        return h && A.children ? j.children.splice(I, 1, ...A.children) : j.children.splice(I, 1), I;
    }
  }
}
function kU(e) {
  return _B(e, xU);
}
const wU = eA("end"), DU = eA("start");
function eA(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function PU(e) {
  const t = DU(e), n = wU(e);
  if (t && n)
    return { start: t, end: n };
}
const ba = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"], _a = {
  ancestors: {
    tbody: ["table"],
    td: ["table"],
    th: ["table"],
    thead: ["table"],
    tfoot: ["table"],
    tr: ["table"]
  },
  attributes: {
    a: [
      ...ba,
      // Note: these 3 are used by GFM footnotes, they do work on all links.
      "dataFootnoteBackref",
      "dataFootnoteRef",
      ["className", "data-footnote-backref"],
      "href"
    ],
    blockquote: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `code` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    code: [["className", /^language-./]],
    del: ["cite"],
    div: ["itemScope", "itemType"],
    dl: [...ba],
    // Note: this is used by GFM footnotes.
    h2: [["className", "sr-only"]],
    img: [...ba, "longDesc", "src"],
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We cant do that, so we have to allow it.
    input: [
      ["disabled", !0],
      ["type", "checkbox"]
    ],
    ins: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `li` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    li: [["className", "task-list-item"]],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    ol: [...ba, ["className", "contains-task-list"]],
    q: ["cite"],
    section: ["dataFootnotes", ["className", "footnotes"]],
    source: ["srcSet"],
    summary: [...ba],
    table: [...ba],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    ul: [...ba, ["className", "contains-task-list"]],
    "*": [
      "abbr",
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "align",
      "alt",
      "axis",
      "border",
      "cellPadding",
      "cellSpacing",
      "char",
      "charOff",
      "charSet",
      "checked",
      "clear",
      "colSpan",
      "color",
      "cols",
      "compact",
      "coords",
      "dateTime",
      "dir",
      // Note: `disabled` is technically allowed on all elements by GH.
      // But it is useless on everything except `input`.
      // Because `input`s are normally not allowed, but we allow them for
      // checkboxes due to tasklists, we allow `disabled` only there.
      "encType",
      "frame",
      "hSpace",
      "headers",
      "height",
      "hrefLang",
      "htmlFor",
      "id",
      "isMap",
      "itemProp",
      "label",
      "lang",
      "maxLength",
      "media",
      "method",
      "multiple",
      "name",
      "noHref",
      "noShade",
      "noWrap",
      "open",
      "prompt",
      "readOnly",
      "rev",
      "rowSpan",
      "rows",
      "rules",
      "scope",
      "selected",
      "shape",
      "size",
      "span",
      "start",
      "summary",
      "tabIndex",
      "title",
      "useMap",
      "vAlign",
      "value",
      "width"
    ]
  },
  clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
  clobberPrefix: "user-content-",
  protocols: {
    cite: ["http", "https"],
    href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
    longDesc: ["http", "https"],
    src: ["http", "https"]
  },
  required: {
    input: { disabled: !0, type: "checkbox" }
  },
  strip: ["script"],
  tagNames: [
    "a",
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "del",
    "details",
    "div",
    "dl",
    "dt",
    "em",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We cant do that, so we have to allow it.
    "input",
    "ins",
    "kbd",
    "li",
    "ol",
    "p",
    "picture",
    "pre",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "source",
    "span",
    "strike",
    "strong",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr",
    "tt",
    "ul",
    "var"
  ]
}, ea = {}.hasOwnProperty;
function LU(e, t) {
  let n = { type: "root", children: [] };
  const r = {
    schema: t ? { ..._a, ...t } : _a,
    stack: []
  }, a = tA(r, e);
  return a && (Array.isArray(a) ? a.length === 1 ? n = a[0] : n.children = a : n = a), n;
}
function tA(e, t) {
  if (t && typeof t == "object") {
    const n = (
      /** @type {Record<string, Readonly<unknown>>} */
      t
    );
    switch (typeof n.type == "string" ? n.type : "") {
      case "comment":
        return MU(e, n);
      case "doctype":
        return $U(e, n);
      case "element":
        return BU(e, n);
      case "root":
        return FU(e, n);
      case "text":
        return UU(e, n);
    }
  }
}
function MU(e, t) {
  if (e.schema.allowComments) {
    const n = typeof t.value == "string" ? t.value : "", r = n.indexOf("-->"), i = { type: "comment", value: r < 0 ? n : n.slice(0, r) };
    return Ks(i, t), i;
  }
}
function $U(e, t) {
  if (e.schema.allowDoctypes) {
    const n = { type: "doctype" };
    return Ks(n, t), n;
  }
}
function BU(e, t) {
  const n = typeof t.tagName == "string" ? t.tagName : "";
  e.stack.push(n);
  const r = (
    /** @type {Array<ElementContent>} */
    nA(e, t.children)
  ), a = HU(e, t.properties);
  e.stack.pop();
  let i = !1;
  if (n && n !== "*" && (!e.schema.tagNames || e.schema.tagNames.includes(n)) && (i = !0, e.schema.ancestors && ea.call(e.schema.ancestors, n))) {
    const o = e.schema.ancestors[n];
    let u = -1;
    for (i = !1; ++u < o.length; )
      e.stack.includes(o[u]) && (i = !0);
  }
  if (!i)
    return e.schema.strip && !e.schema.strip.includes(n) ? r : void 0;
  const s = {
    type: "element",
    tagName: n,
    properties: a,
    children: r
  };
  return Ks(s, t), s;
}
function FU(e, t) {
  const r = { type: "root", children: (
    /** @type {Array<RootContent>} */
    nA(e, t.children)
  ) };
  return Ks(r, t), r;
}
function UU(e, t) {
  const r = { type: "text", value: typeof t.value == "string" ? t.value : "" };
  return Ks(r, t), r;
}
function nA(e, t) {
  const n = [];
  if (Array.isArray(t)) {
    const r = (
      /** @type {Array<Readonly<unknown>>} */
      t
    );
    let a = -1;
    for (; ++a < r.length; ) {
      const i = tA(e, r[a]);
      i && (Array.isArray(i) ? n.push(...i) : n.push(i));
    }
  }
  return n;
}
function HU(e, t) {
  const n = e.stack[e.stack.length - 1], r = e.schema.attributes, a = e.schema.required, i = r && ea.call(r, n) ? r[n] : void 0, s = r && ea.call(r, "*") ? r["*"] : void 0, o = (
    /** @type {Readonly<Record<string, Readonly<unknown>>>} */
    t && typeof t == "object" ? t : {}
  ), u = {};
  let l;
  for (l in o)
    if (ea.call(o, l)) {
      const f = o[l];
      let h = v1(
        e,
        T1(i, l),
        l,
        f
      );
      h == null && (h = v1(e, T1(s, l), l, f)), h != null && (u[l] = h);
    }
  if (a && ea.call(a, n)) {
    const f = a[n];
    for (l in f)
      ea.call(f, l) && !ea.call(u, l) && (u[l] = f[l]);
  }
  return u;
}
function v1(e, t, n, r) {
  return t ? Array.isArray(r) ? jU(e, t, n, r) : rA(e, t, n, r) : void 0;
}
function jU(e, t, n, r) {
  let a = -1;
  const i = [];
  for (; ++a < r.length; ) {
    const s = rA(e, t, n, r[a]);
    (typeof s == "number" || typeof s == "string") && i.push(s);
  }
  return i;
}
function rA(e, t, n, r) {
  if (!(typeof r != "boolean" && typeof r != "number" && typeof r != "string") && zU(e, n, r)) {
    if (typeof t == "object" && t.length > 1) {
      let a = !1, i = 0;
      for (; ++i < t.length; ) {
        const s = t[i];
        if (s && typeof s == "object" && "flags" in s) {
          if (s.test(String(r))) {
            a = !0;
            break;
          }
        } else if (s === r) {
          a = !0;
          break;
        }
      }
      if (!a)
        return;
    }
    return e.schema.clobber && e.schema.clobberPrefix && e.schema.clobber.includes(n) ? e.schema.clobberPrefix + r : r;
  }
}
function zU(e, t, n) {
  const r = e.schema.protocols && ea.call(e.schema.protocols, t) ? e.schema.protocols[t] : void 0;
  if (!r || r.length === 0)
    return !0;
  const a = String(n), i = a.indexOf(":"), s = a.indexOf("?"), o = a.indexOf("#"), u = a.indexOf("/");
  if (i < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
  u > -1 && i > u || s > -1 && i > s || o > -1 && i > o)
    return !0;
  let l = -1;
  for (; ++l < r.length; ) {
    const f = r[l];
    if (i === f.length && a.slice(0, f.length) === f)
      return !0;
  }
  return !1;
}
function Ks(e, t) {
  const n = PU(
    // @ts-expect-error: looks like a node.
    t
  );
  t.data && (e.data = Ma(t.data)), n && (e.position = n);
}
function T1(e, t) {
  let n, r = -1;
  if (e)
    for (; ++r < e.length; ) {
      const a = e[r], i = typeof a == "string" ? a : a[0];
      if (i === t)
        return a;
      i === "data*" && (n = a);
    }
  if (t.length > 4 && t.slice(0, 4).toLowerCase() === "data")
    return n;
}
function VU(e) {
  return function(t) {
    return (
      /** @type {Root} */
      LU(t, e)
    );
  };
}
function A1(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, a = n.indexOf(t);
  for (; a !== -1; )
    r++, a = n.indexOf(t, a + t.length);
  return r;
}
function GU(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function YU(e, t, n) {
  const a = Uu((n || {}).ignore || []), i = WU(t);
  let s = -1;
  for (; ++s < i.length; )
    Gs(e, "text", o);
  function o(l, f) {
    let h = -1, p;
    for (; ++h < f.length; ) {
      const b = f[h], v = p ? p.children : void 0;
      if (a(
        b,
        v ? v.indexOf(b) : void 0,
        p
      ))
        return;
      p = b;
    }
    if (p)
      return u(l, f);
  }
  function u(l, f) {
    const h = f[f.length - 1], p = i[s][0], b = i[s][1];
    let v = 0;
    const y = h.children.indexOf(l);
    let N = !1, A = [];
    p.lastIndex = 0;
    let I = p.exec(l.value);
    for (; I; ) {
      const j = I.index, $ = {
        index: I.index,
        input: I.input,
        stack: [...f, l]
      };
      let _ = b(...I, $);
      if (typeof _ == "string" && (_ = _.length > 0 ? { type: "text", value: _ } : void 0), _ === !1 ? p.lastIndex = j + 1 : (v !== j && A.push({
        type: "text",
        value: l.value.slice(v, j)
      }), Array.isArray(_) ? A.push(..._) : _ && A.push(_), v = j + I[0].length, N = !0), !p.global)
        break;
      I = p.exec(l.value);
    }
    return N ? (v < l.value.length && A.push({ type: "text", value: l.value.slice(v) }), h.children.splice(y, 1, ...A)) : A = [l], y + A.length;
  }
}
function WU(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const a = n[r];
    t.push([qU(a[0]), KU(a[1])]);
  }
  return t;
}
function qU(e) {
  return typeof e == "string" ? new RegExp(GU(e), "g") : e;
}
function KU(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const Zl = "phrasing", Ql = ["autolink", "link", "image", "label"];
function XU() {
  return {
    transforms: [rH],
    enter: {
      literalAutolink: QU,
      literalAutolinkEmail: Jl,
      literalAutolinkHttp: Jl,
      literalAutolinkWww: Jl
    },
    exit: {
      literalAutolink: nH,
      literalAutolinkEmail: tH,
      literalAutolinkHttp: JU,
      literalAutolinkWww: eH
    }
  };
}
function ZU() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Zl,
        notInConstruct: Ql
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Zl,
        notInConstruct: Ql
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Zl,
        notInConstruct: Ql
      }
    ]
  };
}
function QU(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function Jl(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function JU(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function eH(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function tH(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function nH(e) {
  this.exit(e);
}
function rH(e) {
  YU(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, aH],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, iH]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function aH(e, t, n, r, a) {
  let i = "";
  if (!aA(a) || (/^w/i.test(t) && (n = t + n, t = "", i = "http://"), !sH(n)))
    return !1;
  const s = oH(n + r);
  if (!s[0])
    return !1;
  const o = {
    type: "link",
    title: null,
    url: i + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [o, { type: "text", value: s[1] }] : o;
}
function iH(e, t, n, r) {
  return (
    // Not an expected previous character.
    !aA(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function sH(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function oH(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const a = A1(e, "(");
  let i = A1(e, ")");
  for (; r !== -1 && a > i; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), i++;
  return [e, n];
}
function aA(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || $a(n) || ju(n)) && (!t || n !== 47);
}
iA.peek = EH;
function uH() {
  return {
    enter: {
      gfmFootnoteDefinition: cH,
      gfmFootnoteDefinitionLabelString: fH,
      gfmFootnoteCall: mH,
      gfmFootnoteCallString: pH
    },
    exit: {
      gfmFootnoteDefinition: hH,
      gfmFootnoteDefinitionLabelString: dH,
      gfmFootnoteCall: bH,
      gfmFootnoteCallString: gH
    }
  };
}
function lH() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: vH, footnoteReference: iA }
  };
}
function cH(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function fH() {
  this.buffer();
}
function dH(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = fr(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function hH(e) {
  this.exit(e);
}
function mH(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function pH() {
  this.buffer();
}
function gH(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = fr(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function bH(e) {
  this.exit(e);
}
function iA(e, t, n, r) {
  const a = n.createTracker(r);
  let i = a.move("[^");
  const s = n.enter("footnoteReference"), o = n.enter("reference");
  return i += a.move(
    n.safe(n.associationId(e), {
      ...a.current(),
      before: i,
      after: "]"
    })
  ), o(), s(), i += a.move("]"), i;
}
function EH() {
  return "[";
}
function vH(e, t, n, r) {
  const a = n.createTracker(r);
  let i = a.move("[^");
  const s = n.enter("footnoteDefinition"), o = n.enter("label");
  return i += a.move(
    n.safe(n.associationId(e), {
      ...a.current(),
      before: i,
      after: "]"
    })
  ), o(), i += a.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), a.shift(4), i += a.move(
    n.indentLines(n.containerFlow(e, a.current()), TH)
  ), s(), i;
}
function TH(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const AH = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
sA.peek = OH;
function _H() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: SH },
    exit: { strikethrough: CH }
  };
}
function yH() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: AH
      }
    ],
    handlers: { delete: sA }
  };
}
function SH(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function CH(e) {
  this.exit(e);
}
function sA(e, t, n, r) {
  const a = n.createTracker(r), i = n.enter("strikethrough");
  let s = a.move("~~");
  return s += n.containerPhrasing(e, {
    ...a.current(),
    before: s,
    after: "~"
  }), s += a.move("~~"), i(), s;
}
function OH() {
  return "~";
}
function IH(e, t = {}) {
  const n = (t.align || []).concat(), r = t.stringLength || NH, a = [], i = [], s = [], o = [];
  let u = 0, l = -1;
  for (; ++l < e.length; ) {
    const v = [], E = [];
    let y = -1;
    for (e[l].length > u && (u = e[l].length); ++y < e[l].length; ) {
      const N = xH(e[l][y]);
      if (t.alignDelimiters !== !1) {
        const A = r(N);
        E[y] = A, (o[y] === void 0 || A > o[y]) && (o[y] = A);
      }
      v.push(N);
    }
    i[l] = v, s[l] = E;
  }
  let f = -1;
  if (typeof n == "object" && "length" in n)
    for (; ++f < u; )
      a[f] = _1(n[f]);
  else {
    const v = _1(n);
    for (; ++f < u; )
      a[f] = v;
  }
  f = -1;
  const h = [], p = [];
  for (; ++f < u; ) {
    const v = a[f];
    let E = "", y = "";
    v === 99 ? (E = ":", y = ":") : v === 108 ? E = ":" : v === 114 && (y = ":");
    let N = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      o[f] - E.length - y.length
    );
    const A = E + "-".repeat(N) + y;
    t.alignDelimiters !== !1 && (N = E.length + N + y.length, N > o[f] && (o[f] = N), p[f] = N), h[f] = A;
  }
  i.splice(1, 0, h), s.splice(1, 0, p), l = -1;
  const b = [];
  for (; ++l < i.length; ) {
    const v = i[l], E = s[l];
    f = -1;
    const y = [];
    for (; ++f < u; ) {
      const N = v[f] || "";
      let A = "", I = "";
      if (t.alignDelimiters !== !1) {
        const j = o[f] - (E[f] || 0), $ = a[f];
        $ === 114 ? A = " ".repeat(j) : $ === 99 ? j % 2 ? (A = " ".repeat(j / 2 + 0.5), I = " ".repeat(j / 2 - 0.5)) : (A = " ".repeat(j / 2), I = A) : I = " ".repeat(j);
      }
      t.delimiterStart !== !1 && !f && y.push("|"), t.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && N === "") && (t.delimiterStart !== !1 || f) && y.push(" "), t.alignDelimiters !== !1 && y.push(A), y.push(N), t.alignDelimiters !== !1 && y.push(I), t.padding !== !1 && y.push(" "), (t.delimiterEnd !== !1 || f !== u - 1) && y.push("|");
    }
    b.push(
      t.delimiterEnd === !1 ? y.join("").replace(/ +$/, "") : y.join("")
    );
  }
  return b.join(`
`);
}
function xH(e) {
  return e == null ? "" : String(e);
}
function NH(e) {
  return e.length;
}
function _1(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function RH(e, t, n, r) {
  const a = n.enter("blockquote"), i = n.createTracker(r);
  i.move("> "), i.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, i.current()),
    kH
  );
  return a(), s;
}
function kH(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function wH(e, t) {
  return y1(e, t.inConstruct, !0) && !y1(e, t.notInConstruct, !1);
}
function y1(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function S1(e, t, n, r) {
  let a = -1;
  for (; ++a < n.unsafe.length; )
    if (n.unsafe[a].character === `
` && wH(n.stack, n.unsafe[a]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function DH(e, t) {
  const n = String(e);
  let r = n.indexOf(t), a = r, i = 0, s = 0;
  if (typeof t != "string" || t.length !== 1)
    throw new Error("Expected character");
  for (; r !== -1; )
    r === a ? ++i > s && (s = i) : i = 1, a = r + 1, r = n.indexOf(t, a);
  return s;
}
function PH(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function LH(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function MH(e, t, n, r) {
  const a = LH(n), i = e.value || "", s = a === "`" ? "GraveAccent" : "Tilde";
  if (PH(e, n)) {
    const h = n.enter("codeIndented"), p = n.indentLines(i, $H);
    return h(), p;
  }
  const o = n.createTracker(r), u = a.repeat(Math.max(DH(i, a) + 1, 3)), l = n.enter("codeFenced");
  let f = o.move(u);
  if (e.lang) {
    const h = n.enter(`codeFencedLang${s}`);
    f += o.move(
      n.safe(e.lang, {
        before: f,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), h();
  }
  if (e.lang && e.meta) {
    const h = n.enter(`codeFencedMeta${s}`);
    f += o.move(" "), f += o.move(
      n.safe(e.meta, {
        before: f,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), h();
  }
  return f += o.move(`
`), i && (f += o.move(i + `
`)), f += o.move(u), l(), f;
}
function $H(e, t, n) {
  return (n ? "" : "    ") + e;
}
function ih(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function BH(e, t, n, r) {
  const a = ih(n), i = a === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let l = u.move("[");
  return l += u.move(
    n.safe(n.associationId(e), {
      before: l,
      after: "]",
      ...u.current()
    })
  ), l += u.move("]: "), o(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), l += u.move("<"), l += u.move(
    n.safe(e.url, { before: l, after: ">", ...u.current() })
  ), l += u.move(">")) : (o = n.enter("destinationRaw"), l += u.move(
    n.safe(e.url, {
      before: l,
      after: e.title ? " " : `
`,
      ...u.current()
    })
  )), o(), e.title && (o = n.enter(`title${i}`), l += u.move(" " + a), l += u.move(
    n.safe(e.title, {
      before: l,
      after: a,
      ...u.current()
    })
  ), l += u.move(a), o()), s(), l;
}
function FH(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
oA.peek = UH;
function oA(e, t, n, r) {
  const a = FH(n), i = n.enter("emphasis"), s = n.createTracker(r);
  let o = s.move(a);
  return o += s.move(
    n.containerPhrasing(e, {
      before: o,
      after: a,
      ...s.current()
    })
  ), o += s.move(a), i(), o;
}
function UH(e, t, n) {
  return n.options.emphasis || "*";
}
function HH(e, t, n, r) {
  let a, i, s;
  typeof t == "function" && typeof n != "function" ? (i = void 0, s = t, a = n) : (i = t, s = n, a = r), Gs(e, i, o, a);
  function o(u, l) {
    const f = l[l.length - 1], h = f ? f.children.indexOf(u) : void 0;
    return s(u, h, f);
  }
}
const jH = {};
function uA(e, t) {
  const n = t || jH, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, a = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return lA(e, r, a);
}
function lA(e, t, n) {
  if (zH(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return C1(e.children, t, n);
  }
  return Array.isArray(e) ? C1(e, t, n) : "";
}
function C1(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; )
    r[a] = lA(e[a], t, n);
  return r.join("");
}
function zH(e) {
  return !!(e && typeof e == "object");
}
function VH(e, t) {
  let n = !1;
  return HH(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Ff;
  }), !!((!e.depth || e.depth < 3) && uA(e) && (t.options.setext || n));
}
function GH(e, t, n, r) {
  const a = Math.max(Math.min(6, e.depth || 1), 1), i = n.createTracker(r);
  if (VH(e, n)) {
    const f = n.enter("headingSetext"), h = n.enter("phrasing"), p = n.containerPhrasing(e, {
      ...i.current(),
      before: `
`,
      after: `
`
    });
    return h(), f(), p + `
` + (a === 1 ? "=" : "-").repeat(
      // The whole size
      p.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(p.lastIndexOf("\r"), p.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(a), o = n.enter("headingAtx"), u = n.enter("phrasing");
  i.move(s + " ");
  let l = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...i.current()
  });
  return /^[\t ]/.test(l) && (l = "&#x" + l.charCodeAt(0).toString(16).toUpperCase() + ";" + l.slice(1)), l = l ? s + " " + l : s, n.options.closeAtx && (l += " " + s), u(), o(), l;
}
cA.peek = YH;
function cA(e) {
  return e.value || "";
}
function YH() {
  return "<";
}
fA.peek = WH;
function fA(e, t, n, r) {
  const a = ih(n), i = a === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let l = u.move("![");
  return l += u.move(
    n.safe(e.alt, { before: l, after: "]", ...u.current() })
  ), l += u.move("]("), o(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), l += u.move("<"), l += u.move(
    n.safe(e.url, { before: l, after: ">", ...u.current() })
  ), l += u.move(">")) : (o = n.enter("destinationRaw"), l += u.move(
    n.safe(e.url, {
      before: l,
      after: e.title ? " " : ")",
      ...u.current()
    })
  )), o(), e.title && (o = n.enter(`title${i}`), l += u.move(" " + a), l += u.move(
    n.safe(e.title, {
      before: l,
      after: a,
      ...u.current()
    })
  ), l += u.move(a), o()), l += u.move(")"), s(), l;
}
function WH() {
  return "!";
}
dA.peek = qH;
function dA(e, t, n, r) {
  const a = e.referenceType, i = n.enter("imageReference");
  let s = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("![");
  const l = n.safe(e.alt, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(l + "]["), s();
  const f = n.stack;
  n.stack = [], s = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: u,
    after: "]",
    ...o.current()
  });
  return s(), n.stack = f, i(), a === "full" || !l || l !== h ? u += o.move(h + "]") : a === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function qH() {
  return "!";
}
hA.peek = KH;
function hA(e, t, n) {
  let r = e.value || "", a = "`", i = -1;
  for (; new RegExp("(^|[^`])" + a + "([^`]|$)").test(r); )
    a += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length; ) {
    const s = n.unsafe[i], o = n.compilePattern(s);
    let u;
    if (s.atBreak)
      for (; u = o.exec(r); ) {
        let l = u.index;
        r.charCodeAt(l) === 10 && r.charCodeAt(l - 1) === 13 && l--, r = r.slice(0, l) + " " + r.slice(u.index + 1);
      }
  }
  return a + r + a;
}
function KH() {
  return "`";
}
function mA(e, t) {
  const n = uA(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
pA.peek = XH;
function pA(e, t, n, r) {
  const a = ih(n), i = a === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let o, u;
  if (mA(e, n)) {
    const f = n.stack;
    n.stack = [], o = n.enter("autolink");
    let h = s.move("<");
    return h += s.move(
      n.containerPhrasing(e, {
        before: h,
        after: ">",
        ...s.current()
      })
    ), h += s.move(">"), o(), n.stack = f, h;
  }
  o = n.enter("link"), u = n.enter("label");
  let l = s.move("[");
  return l += s.move(
    n.containerPhrasing(e, {
      before: l,
      after: "](",
      ...s.current()
    })
  ), l += s.move("]("), u(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), l += s.move("<"), l += s.move(
    n.safe(e.url, { before: l, after: ">", ...s.current() })
  ), l += s.move(">")) : (u = n.enter("destinationRaw"), l += s.move(
    n.safe(e.url, {
      before: l,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), u(), e.title && (u = n.enter(`title${i}`), l += s.move(" " + a), l += s.move(
    n.safe(e.title, {
      before: l,
      after: a,
      ...s.current()
    })
  ), l += s.move(a), u()), l += s.move(")"), o(), l;
}
function XH(e, t, n) {
  return mA(e, n) ? "<" : "[";
}
gA.peek = ZH;
function gA(e, t, n, r) {
  const a = e.referenceType, i = n.enter("linkReference");
  let s = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("[");
  const l = n.containerPhrasing(e, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(l + "]["), s();
  const f = n.stack;
  n.stack = [], s = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: u,
    after: "]",
    ...o.current()
  });
  return s(), n.stack = f, i(), a === "full" || !l || l !== h ? u += o.move(h + "]") : a === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function ZH() {
  return "[";
}
function sh(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function QH(e) {
  const t = sh(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function JH(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function bA(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function ej(e, t, n, r) {
  const a = n.enter("list"), i = n.bulletCurrent;
  let s = e.ordered ? JH(n) : sh(n);
  const o = e.ordered ? s === "." ? ")" : "." : QH(n);
  let u = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const f = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      f && (!f.children || !f.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), bA(n) === s && f
    ) {
      let h = -1;
      for (; ++h < e.children.length; ) {
        const p = e.children[h];
        if (p && p.type === "listItem" && p.children && p.children[0] && p.children[0].type === "thematicBreak") {
          u = !0;
          break;
        }
      }
    }
  }
  u && (s = o), n.bulletCurrent = s;
  const l = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = i, a(), l;
}
function tj(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function nj(e, t, n, r) {
  const a = tj(n);
  let i = n.bulletCurrent || sh(n);
  t && t.type === "list" && t.ordered && (i = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + i);
  let s = i.length + 1;
  (a === "tab" || a === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const o = n.createTracker(r);
  o.move(i + " ".repeat(s - i.length)), o.shift(s);
  const u = n.enter("listItem"), l = n.indentLines(
    n.containerFlow(e, o.current()),
    f
  );
  return u(), l;
  function f(h, p, b) {
    return p ? (b ? "" : " ".repeat(s)) + h : (b ? i : i + " ".repeat(s - i.length)) + h;
  }
}
function rj(e, t, n, r) {
  const a = n.enter("paragraph"), i = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return i(), a(), s;
}
const aj = (
  /** @type {(node?: unknown) => node is PhrasingContent} */
  Uu([
    "break",
    "delete",
    "emphasis",
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    "link",
    "linkReference",
    "strong",
    "text"
  ])
);
function ij(e, t, n, r) {
  return (e.children.some(function(s) {
    return aj(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function sj(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
EA.peek = oj;
function EA(e, t, n, r) {
  const a = sj(n), i = n.enter("strong"), s = n.createTracker(r);
  let o = s.move(a + a);
  return o += s.move(
    n.containerPhrasing(e, {
      before: o,
      after: a,
      ...s.current()
    })
  ), o += s.move(a + a), i(), o;
}
function oj(e, t, n) {
  return n.options.strong || "*";
}
function uj(e, t, n, r) {
  return n.safe(e.value, r);
}
function lj(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function cj(e, t, n) {
  const r = (bA(n) + (n.options.ruleSpaces ? " " : "")).repeat(lj(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const vA = {
  blockquote: RH,
  break: S1,
  code: MH,
  definition: BH,
  emphasis: oA,
  hardBreak: S1,
  heading: GH,
  html: cA,
  image: fA,
  imageReference: dA,
  inlineCode: hA,
  link: pA,
  linkReference: gA,
  list: ej,
  listItem: nj,
  paragraph: rj,
  root: ij,
  strong: EA,
  text: uj,
  thematicBreak: cj
};
function fj() {
  return {
    enter: {
      table: dj,
      tableData: O1,
      tableHeader: O1,
      tableRow: mj
    },
    exit: {
      codeText: pj,
      table: hj,
      tableData: ec,
      tableHeader: ec,
      tableRow: ec
    }
  };
}
function dj(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function hj(e) {
  this.exit(e), this.data.inTable = void 0;
}
function mj(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function ec(e) {
  this.exit(e);
}
function O1(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function pj(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, gj));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function gj(e, t) {
  return t === "|" ? t : e;
}
function bj(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, a = t.stringLength, i = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: p,
      table: s,
      tableCell: u,
      tableRow: o
    }
  };
  function s(b, v, E, y) {
    return l(f(b, E, y), b.align);
  }
  function o(b, v, E, y) {
    const N = h(b, E, y), A = l([N]);
    return A.slice(0, A.indexOf(`
`));
  }
  function u(b, v, E, y) {
    const N = E.enter("tableCell"), A = E.enter("phrasing"), I = E.containerPhrasing(b, {
      ...y,
      before: i,
      after: i
    });
    return A(), N(), I;
  }
  function l(b, v) {
    return IH(b, {
      align: v,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: a
    });
  }
  function f(b, v, E) {
    const y = b.children;
    let N = -1;
    const A = [], I = v.enter("table");
    for (; ++N < y.length; )
      A[N] = h(y[N], v, E);
    return I(), A;
  }
  function h(b, v, E) {
    const y = b.children;
    let N = -1;
    const A = [], I = v.enter("tableRow");
    for (; ++N < y.length; )
      A[N] = u(y[N], b, v, E);
    return I(), A;
  }
  function p(b, v, E) {
    let y = vA.inlineCode(b, v, E);
    return E.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
function Ej() {
  return {
    exit: {
      taskListCheckValueChecked: I1,
      taskListCheckValueUnchecked: I1,
      paragraph: Tj
    }
  };
}
function vj() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: Aj }
  };
}
function I1(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function Tj(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const a = t.children;
      let i = -1, s;
      for (; ++i < a.length; ) {
        const o = a[i];
        if (o.type === "paragraph") {
          s = o;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function Aj(e, t, n, r) {
  const a = e.children[0], i = typeof e.checked == "boolean" && a && a.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  i && o.move(s);
  let u = vA.listItem(e, t, n, {
    ...r,
    ...o.current()
  });
  return i && (u = u.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, l)), u;
  function l(f) {
    return f + s;
  }
}
function _j() {
  return [
    XU(),
    uH(),
    _H(),
    fj(),
    Ej()
  ];
}
function yj(e) {
  return {
    extensions: [
      ZU(),
      lH(),
      yH(),
      bj(e),
      vj()
    ]
  };
}
const Sj = {
  tokenize: Rj,
  partial: !0
}, TA = {
  tokenize: kj,
  partial: !0
}, AA = {
  tokenize: wj,
  partial: !0
}, _A = {
  tokenize: Dj,
  partial: !0
}, Cj = {
  tokenize: Pj,
  partial: !0
}, yA = {
  tokenize: xj,
  previous: CA
}, SA = {
  tokenize: Nj,
  previous: OA
}, jr = {
  tokenize: Ij,
  previous: IA
}, xr = {};
function Oj() {
  return {
    text: xr
  };
}
let Ea = 48;
for (; Ea < 123; )
  xr[Ea] = jr, Ea++, Ea === 58 ? Ea = 65 : Ea === 91 && (Ea = 97);
xr[43] = jr;
xr[45] = jr;
xr[46] = jr;
xr[95] = jr;
xr[72] = [jr, SA];
xr[104] = [jr, SA];
xr[87] = [jr, yA];
xr[119] = [jr, yA];
function Ij(e, t, n) {
  const r = this;
  let a, i;
  return s;
  function s(h) {
    return !Wf(h) || !IA.call(r, r.previous) || oh(r.events) ? n(h) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(h));
  }
  function o(h) {
    return Wf(h) ? (e.consume(h), o) : h === 64 ? (e.consume(h), u) : n(h);
  }
  function u(h) {
    return h === 46 ? e.check(
      Cj,
      f,
      l
    )(h) : h === 45 || h === 95 || fn(h) ? (i = !0, e.consume(h), u) : f(h);
  }
  function l(h) {
    return e.consume(h), a = !0, u;
  }
  function f(h) {
    return i && a && An(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(h)) : n(h);
  }
}
function xj(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return s !== 87 && s !== 119 || !CA.call(r, r.previous) || oh(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(
      Sj,
      e.attempt(TA, e.attempt(AA, i), n),
      n
    )(s));
  }
  function i(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function Nj(e, t, n) {
  const r = this;
  let a = "", i = !1;
  return s;
  function s(h) {
    return (h === 72 || h === 104) && OA.call(r, r.previous) && !oh(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), a += String.fromCodePoint(h), e.consume(h), o) : n(h);
  }
  function o(h) {
    if (An(h) && a.length < 5)
      return a += String.fromCodePoint(h), e.consume(h), o;
    if (h === 58) {
      const p = a.toLowerCase();
      if (p === "http" || p === "https")
        return e.consume(h), u;
    }
    return n(h);
  }
  function u(h) {
    return h === 47 ? (e.consume(h), i ? l : (i = !0, u)) : n(h);
  }
  function l(h) {
    return h === null || cu(h) || Ct(h) || $a(h) || ju(h) ? n(h) : e.attempt(TA, e.attempt(AA, f), n)(h);
  }
  function f(h) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(h);
  }
}
function Rj(e, t, n) {
  let r = 0;
  return a;
  function a(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), a) : s === 46 && r === 3 ? (e.consume(s), i) : n(s);
  }
  function i(s) {
    return s === null ? n(s) : t(s);
  }
}
function kj(e, t, n) {
  let r, a, i;
  return s;
  function s(l) {
    return l === 46 || l === 95 ? e.check(_A, u, o)(l) : l === null || Ct(l) || $a(l) || l !== 45 && ju(l) ? u(l) : (i = !0, e.consume(l), s);
  }
  function o(l) {
    return l === 95 ? r = !0 : (a = r, r = void 0), e.consume(l), s;
  }
  function u(l) {
    return a || r || !i ? n(l) : t(l);
  }
}
function wj(e, t) {
  let n = 0, r = 0;
  return a;
  function a(s) {
    return s === 40 ? (n++, e.consume(s), a) : s === 41 && r < n ? i(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(_A, t, i)(s) : s === null || Ct(s) || $a(s) ? t(s) : (e.consume(s), a);
  }
  function i(s) {
    return s === 41 && r++, e.consume(s), a;
  }
}
function Dj(e, t, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), r) : o === 38 ? (e.consume(o), i) : o === 93 ? (e.consume(o), a) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || Ct(o) || $a(o) ? t(o) : n(o)
    );
  }
  function a(o) {
    return o === null || o === 40 || o === 91 || Ct(o) || $a(o) ? t(o) : r(o);
  }
  function i(o) {
    return An(o) ? s(o) : n(o);
  }
  function s(o) {
    return o === 59 ? (e.consume(o), r) : An(o) ? (e.consume(o), s) : n(o);
  }
}
function Pj(e, t, n) {
  return r;
  function r(i) {
    return e.consume(i), a;
  }
  function a(i) {
    return fn(i) ? n(i) : t(i);
  }
}
function CA(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Ct(e);
}
function OA(e) {
  return !An(e);
}
function IA(e) {
  return !(e === 47 || Wf(e));
}
function Wf(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || fn(e);
}
function oh(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const Lj = {
  tokenize: zj,
  partial: !0
};
function Mj() {
  return {
    document: {
      91: {
        tokenize: Uj,
        continuation: {
          tokenize: Hj
        },
        exit: jj
      }
    },
    text: {
      91: {
        tokenize: Fj
      },
      93: {
        add: "after",
        tokenize: $j,
        resolveTo: Bj
      }
    }
  };
}
function $j(e, t, n) {
  const r = this;
  let a = r.events.length;
  const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; a--; ) {
    const u = r.events[a][1];
    if (u.type === "labelImage") {
      s = u;
      break;
    }
    if (u.type === "gfmFootnoteCall" || u.type === "labelLink" || u.type === "label" || u.type === "image" || u.type === "link")
      break;
  }
  return o;
  function o(u) {
    if (!s || !s._balanced)
      return n(u);
    const l = fr(
      r.sliceSerialize({
        start: s.end,
        end: r.now()
      })
    );
    return l.codePointAt(0) !== 94 || !i.includes(l.slice(1)) ? n(u) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(u), e.exit("gfmFootnoteCallLabelMarker"), t(u));
  }
}
function Bj(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, a = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  a.end.column++, a.end.offset++, a.end._bufferIndex++;
  const i = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, a.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, i.start),
    end: Object.assign({}, i.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", a, t],
    ["exit", a, t],
    // Everything in between.
    ["enter", i, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", i, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...o), e;
}
function Fj(e, t, n) {
  const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i = 0, s;
  return o;
  function o(h) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), u;
  }
  function u(h) {
    return h !== 94 ? n(h) : (e.enter("gfmFootnoteCallMarker"), e.consume(h), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", l);
  }
  function l(h) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      h === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Ct(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const p = e.exit("gfmFootnoteCallString");
      return a.includes(fr(r.sliceSerialize(p))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(h);
    }
    return Ct(h) || (s = !0), i++, e.consume(h), h === 92 ? f : l;
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), i++, l) : l(h);
  }
}
function Uj(e, t, n) {
  const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i, s = 0, o;
  return u;
  function u(v) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionLabelMarker"), l;
  }
  function l(v) {
    return v === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", f) : n(v);
  }
  function f(v) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      v === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      v === null || v === 91 || Ct(v)
    )
      return n(v);
    if (v === 93) {
      e.exit("chunkString");
      const E = e.exit("gfmFootnoteDefinitionLabelString");
      return i = fr(r.sliceSerialize(E)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), p;
    }
    return Ct(v) || (o = !0), s++, e.consume(v), v === 92 ? h : f;
  }
  function h(v) {
    return v === 91 || v === 92 || v === 93 ? (e.consume(v), s++, f) : f(v);
  }
  function p(v) {
    return v === 58 ? (e.enter("definitionMarker"), e.consume(v), e.exit("definitionMarker"), a.includes(i) || a.push(i), dt(
      e,
      b,
      "gfmFootnoteDefinitionWhitespace"
    )) : n(v);
  }
  function b(v) {
    return t(v);
  }
}
function Hj(e, t, n) {
  return e.check(Ws, t, e.attempt(Lj, t, n));
}
function jj(e) {
  e.exit("gfmFootnoteDefinition");
}
function zj(e, t, n) {
  const r = this;
  return dt(
    e,
    a,
    "gfmFootnoteDefinitionIndent",
    5
  );
  function a(i) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(i) : n(i);
  }
}
function Vj(e) {
  let n = (e || {}).singleTilde;
  const r = {
    tokenize: i,
    resolveAll: a
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function a(s, o) {
    let u = -1;
    for (; ++u < s.length; )
      if (s[u][0] === "enter" && s[u][1].type === "strikethroughSequenceTemporary" && s[u][1]._close) {
        let l = u;
        for (; l--; )
          if (s[l][0] === "exit" && s[l][1].type === "strikethroughSequenceTemporary" && s[l][1]._open && // If the sizes are the same:
          s[u][1].end.offset - s[u][1].start.offset === s[l][1].end.offset - s[l][1].start.offset) {
            s[u][1].type = "strikethroughSequence", s[l][1].type = "strikethroughSequence";
            const f = {
              type: "strikethrough",
              start: Object.assign({}, s[l][1].start),
              end: Object.assign({}, s[u][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, s[l][1].end),
              end: Object.assign({}, s[u][1].start)
            }, p = [
              ["enter", f, o],
              ["enter", s[l][1], o],
              ["exit", s[l][1], o],
              ["enter", h, o]
            ], b = o.parser.constructs.insideSpan.null;
            b && Hn(
              p,
              p.length,
              0,
              zu(b, s.slice(l + 1, u), o)
            ), Hn(p, p.length, 0, [
              ["exit", h, o],
              ["enter", s[u][1], o],
              ["exit", s[u][1], o],
              ["exit", f, o]
            ]), Hn(s, l - 1, u - l + 3, p), u = l + p.length - 2;
            break;
          }
      }
    for (u = -1; ++u < s.length; )
      s[u][1].type === "strikethroughSequenceTemporary" && (s[u][1].type = "data");
    return s;
  }
  function i(s, o, u) {
    const l = this.previous, f = this.events;
    let h = 0;
    return p;
    function p(v) {
      return l === 126 && f[f.length - 1][1].type !== "characterEscape" ? u(v) : (s.enter("strikethroughSequenceTemporary"), b(v));
    }
    function b(v) {
      const E = fu(l);
      if (v === 126)
        return h > 1 ? u(v) : (s.consume(v), h++, b);
      if (h < 2 && !n)
        return u(v);
      const y = s.exit("strikethroughSequenceTemporary"), N = fu(v);
      return y._open = !N || N === 2 && !!E, y._close = !E || E === 2 && !!N, o(v);
    }
  }
}
class Gj {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    Yj(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(i, s) {
      return i[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(
        t.slice(this.map[n][0] + this.map[n][1]),
        this.map[n][2]
      ), t.length = this.map[n][0];
    r.push([...t]), t.length = 0;
    let a = r.pop();
    for (; a; )
      t.push(...a), a = r.pop();
    this.map.length = 0;
  }
}
function Yj(e, t, n, r) {
  let a = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; a < e.map.length; ) {
      if (e.map[a][0] === t) {
        e.map[a][1] += n, e.map[a][2].push(...r);
        return;
      }
      a += 1;
    }
    e.map.push([t, n, r]);
  }
}
function Wj(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const a = e[t];
    if (n) {
      if (a[0] === "enter")
        a[1].type === "tableContent" && r.push(
          e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
        );
      else if (a[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const i = r.length - 1;
          r[i] = r[i] === "left" ? "center" : "right";
        }
      } else if (a[1].type === "tableDelimiterRow")
        break;
    } else
      a[0] === "enter" && a[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function qj() {
  return {
    flow: {
      null: {
        tokenize: Kj,
        resolveAll: Xj
      }
    }
  };
}
function Kj(e, t, n) {
  const r = this;
  let a = 0, i = 0, s;
  return o;
  function o(O) {
    let Q = r.events.length - 1;
    for (; Q > -1; ) {
      const D = r.events[Q][1].type;
      if (D === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      D === "linePrefix")
        Q--;
      else
        break;
    }
    const ee = Q > -1 ? r.events[Q][1].type : null, H = ee === "tableHead" || ee === "tableRow" ? _ : u;
    return H === _ && r.parser.lazy[r.now().line] ? n(O) : H(O);
  }
  function u(O) {
    return e.enter("tableHead"), e.enter("tableRow"), l(O);
  }
  function l(O) {
    return O === 124 || (s = !0, i += 1), f(O);
  }
  function f(O) {
    return O === null ? n(O) : we(O) ? i > 1 ? (i = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), b) : n(O) : nt(O) ? dt(e, f, "whitespace")(O) : (i += 1, s && (s = !1, a += 1), O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), s = !0, f) : (e.enter("data"), h(O)));
  }
  function h(O) {
    return O === null || O === 124 || Ct(O) ? (e.exit("data"), f(O)) : (e.consume(O), O === 92 ? p : h);
  }
  function p(O) {
    return O === 92 || O === 124 ? (e.consume(O), h) : h(O);
  }
  function b(O) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(O) : (e.enter("tableDelimiterRow"), s = !1, nt(O) ? dt(
      e,
      v,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(O) : v(O));
  }
  function v(O) {
    return O === 45 || O === 58 ? y(O) : O === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), E) : $(O);
  }
  function E(O) {
    return nt(O) ? dt(e, y, "whitespace")(O) : y(O);
  }
  function y(O) {
    return O === 58 ? (i += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), N) : O === 45 ? (i += 1, N(O)) : O === null || we(O) ? j(O) : $(O);
  }
  function N(O) {
    return O === 45 ? (e.enter("tableDelimiterFiller"), A(O)) : $(O);
  }
  function A(O) {
    return O === 45 ? (e.consume(O), A) : O === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), I) : (e.exit("tableDelimiterFiller"), I(O));
  }
  function I(O) {
    return nt(O) ? dt(e, j, "whitespace")(O) : j(O);
  }
  function j(O) {
    return O === 124 ? v(O) : O === null || we(O) ? !s || a !== i ? $(O) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(O)) : $(O);
  }
  function $(O) {
    return n(O);
  }
  function _(O) {
    return e.enter("tableRow"), M(O);
  }
  function M(O) {
    return O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), M) : O === null || we(O) ? (e.exit("tableRow"), t(O)) : nt(O) ? dt(e, M, "whitespace")(O) : (e.enter("data"), V(O));
  }
  function V(O) {
    return O === null || O === 124 || Ct(O) ? (e.exit("data"), M(O)) : (e.consume(O), O === 92 ? G : V);
  }
  function G(O) {
    return O === 92 || O === 124 ? (e.consume(O), V) : V(O);
  }
}
function Xj(e, t) {
  let n = -1, r = !0, a = 0, i = [0, 0, 0, 0], s = [0, 0, 0, 0], o = !1, u = 0, l, f, h;
  const p = new Gj();
  for (; ++n < e.length; ) {
    const b = e[n], v = b[1];
    b[0] === "enter" ? v.type === "tableHead" ? (o = !1, u !== 0 && (x1(p, t, u, l, f), f = void 0, u = 0), l = {
      type: "table",
      start: Object.assign({}, v.start),
      // Note: correct end is set later.
      end: Object.assign({}, v.end)
    }, p.add(n, 0, [["enter", l, t]])) : v.type === "tableRow" || v.type === "tableDelimiterRow" ? (r = !0, h = void 0, i = [0, 0, 0, 0], s = [0, n + 1, 0, 0], o && (o = !1, f = {
      type: "tableBody",
      start: Object.assign({}, v.start),
      // Note: correct end is set later.
      end: Object.assign({}, v.end)
    }, p.add(n, 0, [["enter", f, t]])), a = v.type === "tableDelimiterRow" ? 2 : f ? 3 : 1) : a && (v.type === "data" || v.type === "tableDelimiterMarker" || v.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (i[1] !== 0 && (s[0] = s[1], h = vo(
      p,
      t,
      i,
      a,
      void 0,
      h
    ), i = [0, 0, 0, 0]), s[2] = n)) : v.type === "tableCellDivider" && (r ? r = !1 : (i[1] !== 0 && (s[0] = s[1], h = vo(
      p,
      t,
      i,
      a,
      void 0,
      h
    )), i = s, s = [i[1], n, 0, 0])) : v.type === "tableHead" ? (o = !0, u = n) : v.type === "tableRow" || v.type === "tableDelimiterRow" ? (u = n, i[1] !== 0 ? (s[0] = s[1], h = vo(
      p,
      t,
      i,
      a,
      n,
      h
    )) : s[1] !== 0 && (h = vo(p, t, s, a, n, h)), a = 0) : a && (v.type === "data" || v.type === "tableDelimiterMarker" || v.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (u !== 0 && x1(p, t, u, l, f), p.consume(t.events), n = -1; ++n < t.events.length; ) {
    const b = t.events[n];
    b[0] === "enter" && b[1].type === "table" && (b[1]._align = Wj(t.events, n));
  }
  return e;
}
function vo(e, t, n, r, a, i) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (i.end = Object.assign({}, li(t.events, n[0])), e.add(n[0], 0, [["exit", i, t]]));
  const u = li(t.events, n[1]);
  if (i = {
    type: s,
    start: Object.assign({}, u),
    // Note: correct end is set later.
    end: Object.assign({}, u)
  }, e.add(n[1], 0, [["enter", i, t]]), n[2] !== 0) {
    const l = li(t.events, n[2]), f = li(t.events, n[3]), h = {
      type: o,
      start: Object.assign({}, l),
      end: Object.assign({}, f)
    };
    if (e.add(n[2], 0, [["enter", h, t]]), r !== 2) {
      const p = t.events[n[2]], b = t.events[n[3]];
      if (p[1].end = Object.assign({}, b[1].end), p[1].type = "chunkText", p[1].contentType = "text", n[3] > n[2] + 1) {
        const v = n[2] + 1, E = n[3] - n[2] - 1;
        e.add(v, E, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", h, t]]);
  }
  return a !== void 0 && (i.end = Object.assign({}, li(t.events, a)), e.add(a, 0, [["exit", i, t]]), i = void 0), i;
}
function x1(e, t, n, r, a) {
  const i = [], s = li(t.events, n);
  a && (a.end = Object.assign({}, s), i.push(["exit", a, t])), r.end = Object.assign({}, s), i.push(["exit", r, t]), e.add(n + 1, 0, i);
}
function li(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const Zj = {
  tokenize: Jj
};
function Qj() {
  return {
    text: {
      91: Zj
    }
  };
}
function Jj(e, t, n) {
  const r = this;
  return a;
  function a(u) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(u) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(u), e.exit("taskListCheckMarker"), i)
    );
  }
  function i(u) {
    return Ct(u) ? (e.enter("taskListCheckValueUnchecked"), e.consume(u), e.exit("taskListCheckValueUnchecked"), s) : u === 88 || u === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(u), e.exit("taskListCheckValueChecked"), s) : n(u);
  }
  function s(u) {
    return u === 93 ? (e.enter("taskListCheckMarker"), e.consume(u), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(u);
  }
  function o(u) {
    return we(u) ? t(u) : nt(u) ? e.check(
      {
        tokenize: ez
      },
      t,
      n
    )(u) : n(u);
  }
}
function ez(e, t, n) {
  return dt(e, r, "whitespace");
  function r(a) {
    return a === null ? n(a) : t(a);
  }
}
function tz(e) {
  return PT([
    Oj(),
    Mj(),
    Vj(e),
    qj(),
    Qj()
  ]);
}
const nz = {};
function rz(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || nz, r = t.data(), a = r.micromarkExtensions || (r.micromarkExtensions = []), i = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  a.push(tz(n)), i.push(_j()), s.push(yj(n));
}
const N1 = ["controls", "src", "type", "autoPlay", "loop", "muted", "playsInline", "poster"], az = {
  ..._a,
  attributes: {
    ..._a.attributes,
    video: N1,
    audio: N1,
    "*": [..._a.attributes["*"], "style"]
  },
  protocols: {
    ..._a.protocols,
    poster: ["https"]
  },
  tagNames: [..._a.tagNames, "video", "audio"]
}, iz = /^(https?|ircs?|mailto|xmpp)$/i;
function sz(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), a = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    a > -1 && t > a || n > -1 && t > n || r > -1 && t > r || // It is a protocol, it should be allowed.
    iz.test(e.slice(0, t)) ? e : ""
  );
}
const xA = Ce(RU, {
  blockquote: {
    marginLeft: 0,
    paddingLeft: "$4",
    borderLeft: "3px solid $medGrey"
  },
  code: {
    color: "#e83e8c",
    whiteSpace: "pre-wrap"
  },
  p: {
    marginTop: 0,
    whiteSpace: "pre-wrap"
  },
  "img,video": {
    maxWidth: "100%",
    borderRadius: "$2",
    marginBottom: "$4"
  },
  "ol,ul": {
    paddingInlineStart: "$5"
  },
  "> *:first-child, blockquote>:first-child": {
    marginTop: 0
  },
  "> *:last-child, blockquote>:last-child": {
    marginBottom: 0
  }
});
xA.defaultProps = {
  urlTransform: sz,
  rehypePlugins: [NT, [VU, az]],
  remarkPlugins: [rz],
  components: {
    a: ({ node: e, href: t, children: n, ...r }) => /* @__PURE__ */ J.jsx("a", { href: t, target: "_blank", rel: "noopener noreferrer", ...r, children: n })
  },
  remarkRehypeOptions: {
    handlers: {
      break: () => [{ type: "text", value: `
` }]
    }
  }
};
class R1 extends AS {
  constructor() {
    super(...arguments), this.state = {
      hasError: !1
    };
  }
  static getDerivedStateFromError() {
    return { hasError: !0 };
  }
  componentDidUpdate(t) {
    t.children !== this.props.children && this.setState({ hasError: !1 });
  }
  componentDidCatch(t, n) {
    console.error(t, n);
  }
  render() {
    return this.state.hasError ? /* @__PURE__ */ J.jsx(J.Fragment, { children: "Couldn't render markdown." }) : /* @__PURE__ */ J.jsx(xA, { ...this.props });
  }
}
const oz = ({ text: e }) => {
  var r;
  const t = Tn.useContext(pr), n = typeof e == "string" ? e : n5(e);
  return (r = t == null ? void 0 : t.config) != null && r.allowDangerousHTML ? /* @__PURE__ */ J.jsx(Ur, { from: "system", children: /* @__PURE__ */ J.jsx(R1, { rehypePlugins: [NT], children: n }) }) : /* @__PURE__ */ J.jsx(Ur, { from: "system", children: /* @__PURE__ */ J.jsx(R1, { children: n }) });
}, uz = Tn.memo(oz), Vu = Ot(yt.FEEDBACK), lz = Ce(Vu("div"), {
  display: "inline-flex",
  alignItems: "center",
  boxSizing: "border-box",
  marginTop: "8.5px"
}), cz = Ce(Vu("div", "description"), {
  color: "$darkGrey",
  marginRight: 4,
  lineHeight: 17,
  typo: {
    size: 12
  }
}), fz = Ce(Vu("div", "buttons"), {
  display: "flex",
  gap: 4
}), k1 = Ce(Vu("button", "button"), {
  display: "inline-flex",
  backgroundColor: "transparent",
  border: 0,
  borderRadius: "$round",
  width: 24,
  height: 24,
  padding: 0,
  margin: 0,
  cursor: "pointer",
  variants: {
    active: {
      false: {
        color: "rgb(115 115 118 / 85%)",
        "&:hover": {
          color: "rgb(115 115 118 / 100%)"
        }
      },
      true: {
        color: "$white",
        backgroundColor: "$primary"
      }
    },
    orientation: {
      positive: {
        transform: "none"
      },
      negative: {
        transform: "rotate(180deg)"
      }
    }
  },
  defaultVariants: {
    active: !1,
    orientation: "positive"
  }
}), dz = ({ question: e = "Was this helpful?", onClick: t, ...n }) => {
  const [r, a] = Tn.useState(null), i = (s) => {
    s !== r && (t(s), a(s));
  };
  return /* @__PURE__ */ J.jsxs(lz, { ...n, children: [
    /* @__PURE__ */ J.jsx(cz, { children: e }),
    /* @__PURE__ */ J.jsxs(fz, { children: [
      /* @__PURE__ */ J.jsx(
        k1,
        {
          orientation: "positive",
          active: r === es.POSITIVE,
          onClick: () => i(es.POSITIVE),
          children: /* @__PURE__ */ J.jsx(sc, { width: "24px", height: "24px" })
        }
      ),
      /* @__PURE__ */ J.jsx(
        k1,
        {
          orientation: "negative",
          active: r === es.NEGATIVE,
          onClick: () => i(es.NEGATIVE),
          children: /* @__PURE__ */ J.jsx(sc, { width: "24px", height: "24px" })
        }
      )
    ] })
  ] });
}, hz = ({ extension: e, trace: t }) => {
  const n = Xn(null);
  return Sr(() => {
    var r;
    try {
      const a = (r = e.render) == null ? void 0 : r.call(e, { trace: t, element: n.current });
      return a ? () => {
        try {
          a == null || a();
        } catch (i) {
          console.error(`Extension '${e.name}' threw an error while unmounting: ${i}`);
        }
      } : void 0;
    } catch (a) {
      console.error(`Extension '${e.name}' threw an error while mounting: ${a}`);
      return;
    }
  }, []), /* @__PURE__ */ J.jsx(Ur, { from: "system", className: `vfrc-message--extension-${e.name}`, children: /* @__PURE__ */ J.jsx("span", { ref: n }) });
}, mz = () => {
  const e = jn(pr);
  return Sr(() => {
    e.setStatus(or.ENDED);
  }, []), null;
}, NA = ({ avatar: e, feedback: t, timestamp: n, message: r, withImage: a, children: i }) => {
  const s = Xn(null), o = Xn(null), { config: u } = jn(pr);
  return !i && (r == null ? void 0 : r.type) === vn.END ? /* @__PURE__ */ J.jsx(mz, {}) : /* @__PURE__ */ J.jsxs(J.Fragment, { children: [
    /* @__PURE__ */ J.jsx(yv, { ref: o }),
    /* @__PURE__ */ J.jsxs(XM, { ref: s, withImage: a, scrollable: (r == null ? void 0 : r.type) === vn.CAROUSEL, children: [
      /* @__PURE__ */ J.jsx(aa, { avatar: e }),
      /* @__PURE__ */ J.jsxs(Sv, { children: [
        i ?? Du(r).with({ type: vn.TEXT }, ({ text: l }) => /* @__PURE__ */ J.jsx(uz, { text: l })).with({ type: vn.IMAGE }, ({ url: l }) => {
          var f;
          return /* @__PURE__ */ J.jsx(rb, { image: l, mode: (f = u.render) == null ? void 0 : f.mode });
        }).with({ type: vn.CARD }, (l) => /* @__PURE__ */ J.jsx(wd, { ...Ro(l, ["type"]) })).with({ type: vn.CAROUSEL }, (l) => /* @__PURE__ */ J.jsx(nM, { ...Ro(l, ["type"]), containerRef: s, controlsRef: o })).with({ type: vn.EXTENSION }, ({ payload: l }) => /* @__PURE__ */ J.jsx(hz, { extension: l.extension, trace: l.trace })).otherwise(() => null),
        t && /* @__PURE__ */ J.jsx(dz, { ...t })
      ] }),
      /* @__PURE__ */ J.jsx(La, { value: n })
    ] })
  ] });
}, pz = ({
  feedback: e,
  avatar: t,
  timestamp: n,
  messages: r,
  actions: a = [],
  isLast: i,
  Message: s = NA
}) => {
  const o = jn(pr), { showIndicator: u, visibleMessages: l, complete: f } = UM({
    messages: r,
    isLast: i
  });
  return fv([u, f, l.length]), !r.length && !a.length ? null : /* @__PURE__ */ J.jsxs(J.Fragment, { children: [
    l.map((h, p) => /* @__PURE__ */ J.jsx(
      s,
      {
        message: h,
        withImage: !u && p === l.length - 1,
        feedback: f && !u && p === l.length - 1 ? e : void 0,
        avatar: t,
        timestamp: n
      },
      p
    )),
    i && f && !!a.length && /* @__PURE__ */ J.jsx(_v, { children: a.map(({ request: h, name: p }, b) => /* @__PURE__ */ J.jsx(Zn, { variant: "secondary", onClick: () => o == null ? void 0 : o.interact(h, p), children: p }, b)) }),
    u && /* @__PURE__ */ J.jsx(Cv, { avatar: t })
  ] });
}, ir = Object.assign(pz, {
  Message: vn,
  Container: Hd,
  Controls: yv,
  List: Sv,
  Actions: _v,
  Indicator: Cv,
  SystemMessage: NA
}), RA = Ot(yt.TOOLTIP), kA = Ce(RA(Zn.Reset, "button"), {
  height: "$md",
  border: "1px solid $medGrey",
  borderTopColor: "rgba(223,223,223,0.5)",
  borderRadius: "$1",
  borderTopLeftRadius: 0,
  borderTopRightRadius: 0,
  typo: { weight: "$2" },
  color: "$primary",
  backgroundColor: "#fbfbfb"
}), wA = Ce(RA("div"), {
  display: "inline-flex",
  flexDirection: "column",
  variants: {
    withAction: {
      true: {
        boxShadow: "0 1px 2px $shadow2",
        [`& ${Ur.Debug.Container}`]: {
          boxShadow: "none",
          borderBottom: 0,
          borderBottomLeftRadius: 0,
          borderBottomRightRadius: 0
        }
      }
    }
  }
}), gz = ({ label: e, onClick: t, children: n, ...r }) => /* @__PURE__ */ J.jsxs(wA, { withAction: !!e, children: [
  /* @__PURE__ */ J.jsx(Ur.Debug, { ...r, children: n }),
  e && /* @__PURE__ */ J.jsx(kA, { onClick: t, children: e })
] }), DA = Object.assign(gz, {
  Button: kA,
  Container: wA
}), uh = Ot(yt.USER_RESPONSE), PA = Ce(uh("aside", "debug"), {
  typo: { size: "12px", height: "17px" },
  color: "$darkGrey",
  marginTop: "$2"
}), LA = Ce(uh("div"), {
  display: "flex",
  flexDirection: "column",
  flexShrink: 0,
  alignItems: "flex-end",
  [`& > ${DA.Container}`]: {
    marginTop: "$1"
  },
  variants: {
    mode: {
      overlay: {
        [`& ${Ur.Container}`]: {
          maxWidth: "248px"
        }
      },
      embedded: {
        [`& ${Ur.Container}`]: {
          maxWidth: "80%"
        }
      }
    }
  },
  defaultVariants: {
    mode: "overlay"
  }
}), MA = Ce(uh("div", "row"), {
  display: "flex",
  width: "100%",
  alignItems: "center",
  [`& ${La.Container}`]: {
    flexGrow: 1,
    marginRight: 8,
    textAlign: "end",
    opacity: "0%",
    trans: ["opacity"]
  },
  [`&:hover ${La.Container}`]: {
    opacity: "100%"
  }
}), bz = ({ message: e, timestamp: t, debug: n }) => {
  var a, i;
  fv();
  const { config: r } = jn(pr);
  return /* @__PURE__ */ J.jsxs(LA, { mode: r.render.mode, children: [
    /* @__PURE__ */ J.jsxs(MA, { children: [
      /* @__PURE__ */ J.jsx(La, { value: t }),
      /* @__PURE__ */ J.jsx(Ur, { from: "user", children: e })
    ] }),
    n && /* @__PURE__ */ J.jsxs(J.Fragment, { children: [
      /* @__PURE__ */ J.jsx(PA, { children: n.message }),
      n.reason && /* @__PURE__ */ J.jsx(DA, { label: (a = n.action) == null ? void 0 : a.label, onClick: (i = n.action) == null ? void 0 : i.onClick, orientation: "right", children: n.reason })
    ] })
  ] });
}, Jr = Object.assign(bz, {
  Container: LA,
  Debug: PA,
  Row: MA
}), tc = 10, Li = Ot(yt.CHAT), du = Ce(Li("div", "overlay"), {
  position: "absolute",
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  backgroundColor: "$shadow12"
}), qf = Ce(Li("article"), {
  position: "relative",
  display: "flex",
  overflow: "hidden",
  flexDirection: "column",
  backgroundColor: "$white",
  [`& > ${ov}`]: {
    margin: "auto"
  },
  [`& ${sv.Container}`]: {
    animation: `${z1} 150ms ease forwards`
  },
  [`& ${rv.Container}`]: {
    ...nd({ duration: 300, delay: 300 })
  },
  [`& ${du}`]: {
    opacity: 0,
    pointerEvents: "none",
    trans: ["opacity"]
  },
  [`& ${So.Container}`]: {
    position: "absolute",
    bottom: 0,
    width: "100%",
    boxSizing: "border-box",
    paddingBottom: `calc($3 + ${tc}px)`,
    transition: `transform 320ms cubic-bezier(0.45, 1.29, 0.64, 1), ${j1(["box-shadow"], 300)}`,
    transform: `translateY(calc(100% + ${tc}px))`
  },
  variants: {
    withPrompt: {
      true: {
        [`& ${du}`]: {
          opacity: 1,
          zIndex: 2,
          pointerEvents: "auto"
        },
        [`& ${So.Container}`]: {
          zIndex: 3,
          transform: `translateY(${tc}px)`
        }
      },
      false: {
        [`& ${So.Container}`]: {
          boxShadow: "none"
        }
      }
    }
  }
}), $A = {
  display: "flex",
  justifyContent: "center",
  typo: { size: 12 },
  color: "$darkGrey"
}, lh = Ce(Li("div", "status"), {
  ...$A
}), Ez = Ce(Li("span", "session-time"), {
  ...$A,
  paddingBottom: "$3"
}), BA = Ce(Li("main", "dialog"), {
  display: "flex",
  flexDirection: "column",
  height: "100%",
  overflowY: "scroll",
  overflowX: "hidden",
  paddingBottom: "$3",
  [`
    & ${Jr.Container},
    & ${ir.List},
    & ${ir.Actions},
    & ${q1.Container}
  `]: {
    ...nd({ duration: 150, delay: 0 })
  },
  [`
    & > ${Jr.Container},
    & > ${ir.Container}
  `]: {
    padding: "0 $5"
  },
  [`& > ${ir.Actions}`]: {
    padding: "0 $5 0 54px"
  },
  [`& ${ir.Container}`]: {
    marginBottom: "$1",
    "&:last-of-type": {
      marginBottom: 0
    }
  },
  [`& ${Jr.Container} + ${Jr.Container}`]: {
    marginTop: "$1"
  },
  [`
    & ${ir.Container} + ${Jr.Container},
    & ${ir.Actions} + ${Jr.Container},
    & ${Jr.Container} + ${ir.Controls} + ${ir.Container}
  `]: {
    marginTop: "$5"
  },
  [`& ${La.Container}`]: { width: 50 },
  [`& ${lh}`]: {
    marginTop: "$3",
    marginBottom: 8
  }
}), FA = Ce(Li("div", "spacer"), {
  flexGrow: 1
}), vz = ({
  hasEnded: e = !1,
  title: t,
  image: n,
  avatar: r,
  description: a,
  startTime: i,
  isLoading: s,
  withWatermark: o,
  onMinimize: u,
  onEnd: l,
  onStart: f,
  onSend: h,
  children: p
}) => {
  const b = LM(i), v = Xn(null), [E, y] = _n(!1), { config: N } = jn(pr), A = jn(Ru), I = (_) => {
    e ? l == null || l(_) : y(!0);
  }, j = () => y(!1), $ = ua(() => {
    var _;
    return ((_ = N.render) == null ? void 0 : _.mode) === wu.OVERLAY ? [
      { svg: "minus", onClick: u },
      { svg: "close", onClick: I }
    ] : [{ svg: "close", onClick: I }];
  }, [N.render, I, u]);
  return s ? /* @__PURE__ */ J.jsx(qf, { children: /* @__PURE__ */ J.jsx(ov, {}) }) : /* @__PURE__ */ J.jsxs(qf, { withPrompt: E, children: [
    /* @__PURE__ */ J.jsx(sv, { title: t, image: n, actions: $ }),
    /* @__PURE__ */ J.jsx(BA, { ref: v, children: /* @__PURE__ */ J.jsxs($C, { target: v, children: [
      /* @__PURE__ */ J.jsx(q1, { title: t, avatar: r, description: a }),
      /* @__PURE__ */ J.jsx(FA, {}),
      !!b && !!A.session.turns.length && /* @__PURE__ */ J.jsx(Ez, { children: b }),
      p,
      e && !!A.session.turns.length && /* @__PURE__ */ J.jsx(lh, { children: "The chat has ended" })
    ] }) }),
    /* @__PURE__ */ J.jsx(
      rv,
      {
        withWatermark: o,
        hasEnded: e,
        onStart: f,
        onSend: h,
        disableSend: A.indicator
      }
    ),
    /* @__PURE__ */ J.jsx(du, {}),
    /* @__PURE__ */ J.jsx(
      So,
      {
        accept: { label: "End Chat", type: "warn", onClick: Ld(l, j) },
        cancel: { label: "Cancel", onClick: j }
      }
    )
  ] });
}, UA = Object.assign(_S(vz), {
  Container: qf,
  Dialog: BA,
  Overlay: du,
  Spacer: FA,
  Status: lh
}), Tz = "data:image/svg+xml,%3csvg%20viewBox='0%200%2036%2036'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cpath%20d='M18.0000533,7%20C24.6266329,7%2030,11.4789312%2030,16.9976931%20C30,22.5163617%2024.6266329,26.9953062%2018.0000533,26.9953062%20C17.123351,26.9971724%2016.2483812,26.9169271%2015.386606,26.7553699%20C14.0404188,27.7431078%2012.5315125,28.4873102%2010.9284053,28.9541197%20C10.4583473,29.0903502%209.95341047,28.916663%209.66660965,28.5199682%20C9.37982216,28.1234068%209.37297168,27.5894152%209.64952342,27.1855224%20C10.1505552,26.5172998%2010.5515886,25.7796289%2010.840002,24.9957036%20C7.9365286,23.3624038%206.10015838,20.3278759%206,16.9976931%20C6,11.4789179%2011.3733271,7%2018.0000533,7%20Z%20M18.0000533,18.0020932%20L14.0000889,18.0020932%20L13.8644511,18.0112196%20C13.3765531,18.0774186%2013.0005042,18.4957012%2013.0005042,19.0018279%20C13.0005042,19.5539661%2013.4480335,20.0015625%2014.0000889,20.0015625%20L18.0000533,20.0015625%20L18.135691,19.9924361%20C18.623589,19.9262371%2018.9996379,19.5079545%2018.9996379,19.0018279%20C18.9996379,18.4496896%2018.5521087,18.0020932%2018.0000533,18.0020932%20Z%20M22.0001244,14.001515%20L14.0000889,14.001515%20L13.8644511,14.0106414%20C13.3765531,14.0768404%2013.0005042,14.495123%2013.0005042,15.0012497%20C13.0005042,15.5533879%2013.4480335,16.0009843%2014.0000889,16.0009843%20L22.0001244,16.0009843%20L22.1357621,15.9918579%20C22.6236601,15.9256589%2022.999709,15.5073764%2022.999709,15.0012497%20C22.999709,14.4491115%2022.5521797,14.001515%2022.0001244,14.001515%20Z'%20fill='%23ffffff'%3e%3c/path%3e%3c/g%3e%3c/svg%3e", Az = Ot(yt.LAUNCHER), _z = Ce(Az("button"), {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "$round",
  backgroundColor: "$primary",
  trans: ["background-color", "box-shadow"],
  height: "$xl",
  width: "$xl",
  border: "1px solid $shadow4",
  boxShadow: "0 1px 6px $shadow6, 0 2px 24px $shadow8",
  "&:focus": {
    outline: 0
  },
  "&:hover": {
    cursor: "pointer",
    backgroundColor: "$darkPrimary"
  },
  "& > img": {
    width: "$sm",
    height: "$sm"
  },
  padding: 0,
  margin: 0
}), HA = ({ image: e, onClick: t }) => /* @__PURE__ */ J.jsx(_z, { onClick: t, children: /* @__PURE__ */ J.jsx("img", { src: e || Tz, alt: "launch" }) }), yz = Ot(yt.PROACTIVE_CLOSE), Kf = Ce(yz("div"), {
  width: 32,
  height: 32,
  borderRadius: "$round",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: "#656D75",
  cursor: "pointer",
  background: "$white",
  boxShadow: "$surfaceZ1Light",
  [`& ${Rn.Frame}`]: {
    width: 10,
    height: 10
  },
  "&:hover, &:active": {
    color: "#2B3239"
  }
}), jA = ({ ...e }) => /* @__PURE__ */ J.jsx(Kf, { ...e, children: /* @__PURE__ */ J.jsx(Rn, { svg: "closeV2" }) }), Sz = Ot(yt.PROACTIVE_MESSAGE), ch = Ce(Sz("div"), {
  padding: "11px 16px 10px 16px",
  maxWidth: 256,
  color: "#1A1E23",
  boxShadow: "$surfaceZ1Light",
  borderRadius: "$2",
  background: "$white",
  typo: { size: 14 }
}), zA = Ot(yt.PROACTIVE), VA = Ce("div", {
  display: "flex",
  flexDirection: "column",
  gap: 8,
  margin: "$4 0",
  alignItems: "inherit",
  [`& ${ch}`]: {
    ...nd({ duration: 150, delay: 0 })
  }
}), GA = Ce(zA("div"), {
  position: "absolute",
  bottom: "100%",
  width: 256,
  display: "flex",
  flexDirection: "column",
  [`& ${Kf}`]: {
    opacity: 0
  },
  "&:hover": {
    [`& ${Kf}`]: {
      opacity: 1
    }
  }
}), Cz = ({ side: e, messages: t }) => {
  const [n, r] = Tn.useState(!1), a = Tn.useMemo(
    () => t.map(
      (i, s) => Du(i).with({ type: ps.TEXT }, ({ payload: o }) => /* @__PURE__ */ J.jsx(ch, { children: String(o.message) }, s)).otherwise(() => null)
    ),
    [t]
  );
  return Tn.useEffect(() => {
    a.length && r(!1);
  }, [a]), n || !a.length ? null : /* @__PURE__ */ J.jsxs(GA, { style: { [e]: 0, alignItems: e === Un.ChatPosition.LEFT ? "start" : "end" }, children: [
    /* @__PURE__ */ J.jsx(jA, { onClick: () => r(!0) }),
    /* @__PURE__ */ J.jsx(VA, { children: a })
  ] });
}, YA = Object.assign(Cz, {
  Message: ch,
  Close: jA
}), Gz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProactiveContainer: GA,
  ProactiveMessageContainer: VA,
  default: YA,
  tag: zA
}, Symbol.toStringTag, { value: "Module" })), w1 = "https://cdn.voiceflow.com/assets/logo.png", Yz = d.object({
  title: d.string().default("Voiceflow Assistant"),
  color: d.string().default(ic),
  image: d.string().default(w1),
  avatar: d.string().default(w1),
  launcher: d.string().optional(),
  watermark: d.boolean().default(!0),
  feedback: d.boolean().default(!1),
  stylesheet: d.union([d.string(), d.string().array()]).optional(),
  description: d.string().default(""),
  position: d.nativeEnum(Un.ChatPosition).default(Un.ChatPosition.RIGHT),
  persistence: d.nativeEnum(Un.ChatPersistence).default(Un.ChatPersistence.LOCAL_STORAGE),
  spacing: d.object({
    side: d.number().default(30),
    bottom: d.number().default(30)
  }).default({}),
  extensions: FP.array().default([])
}).default({}), Oz = "https://general-runtime.voiceflow.com", Iz = (e) => {
  try {
    return decodeURIComponent(e);
  } catch {
    return e;
  }
}, xz = d.object({
  projectID: d.string()
}), Nz = d.object({
  event: d.object({ type: d.string() }).passthrough().transform((e) => e)
}).partial(), Rz = d.object({
  name: d.string(),
  image: d.string()
}).partial(), Wz = d.object({
  autostart: d.boolean().optional(),
  // default to true during migration period, turn off later
  allowDangerousHTML: d.boolean().default(!0),
  url: d.string().default(Oz),
  userID: d.union([d.number(), d.string()]).transform((e) => typeof e == "number" ? String(e) : Iz(e)).optional(),
  versionID: d.string().optional(),
  verify: xz,
  user: Rz.optional(),
  render: kM,
  launch: Nz.optional()
}).transform((e) => ({
  ...e,
  // if not configured default to enabling autostart during overlay mode and disabling it otherwise
  autostart: e.autostart ?? e.render.mode === wu.OVERLAY
})), kz = async (e, t) => {
  const n = document.createElement("link"), r = new Promise((a, i) => {
    n.onload = a, n.onerror = i;
  });
  n.rel = "stylesheet", n.href = e, t.appendChild(n), await r;
}, WA = (e, t) => {
  const [n, r] = _n(!1);
  return Sr(() => {
    if (!e || n)
      return;
    if (!e.stylesheet) {
      r(!0);
      return;
    }
    const a = Array.isArray(e.stylesheet) ? e.stylesheet[0] : e.stylesheet;
    (async () => (await kz(a, t ?? document.head).catch((i) => {
      console.error(`failed to load stylesheet: ${e.stylesheet}`), console.error(i);
    }), r(!0)))();
  }, [e]), n;
}, qA = Ce("div", {
  height: "100%",
  [`& ${UA.Container}`]: {
    height: "100%"
  }
}), wz = ({ className: e }) => {
  const t = jn(pr), n = jn(Ru), { assistant: r, config: a } = t, i = ra(() => {
    t.setStatus(or.ENDED), t.close();
  }, []), s = ra(
    (o) => {
      const u = n.session.turns[o - 1];
      return (u == null ? void 0 : u.type) === hi.USER ? u : null;
    },
    [n.session.turns]
  );
  return /* @__PURE__ */ J.jsx(qA, { className: e, children: /* @__PURE__ */ J.jsxs(
    UA,
    {
      title: r.title,
      description: r.description,
      image: r.image,
      avatar: r.avatar,
      withWatermark: r.watermark,
      startTime: n.session.startTime,
      hasEnded: t.isStatus(or.ENDED),
      isLoading: t.isStatus(or.IDLE) && n.session.turns.length === 0 && a.autostart,
      onStart: t.launch,
      onEnd: i,
      onSend: t.reply,
      onMinimize: t.close,
      children: [
        n.session.turns.map(
          (o, u) => Du(o).with({ type: hi.USER }, ({ id: l, ...f }) => /* @__PURE__ */ Zf(Jr, { ...Ro(f, ["type"]), key: l })).with({ type: hi.SYSTEM }, ({ id: l, ...f }) => /* @__PURE__ */ J.jsx(
            ir,
            {
              ...Ro(f, ["type"]),
              feedback: r.feedback ? {
                onClick: (h) => {
                  t.feedback(h, f.messages, s(u));
                }
              } : void 0,
              avatar: r.avatar,
              isLast: u === n.session.turns.length - 1
            },
            l
          )).exhaustive()
        ),
        n.indicator && /* @__PURE__ */ J.jsx(ir.Indicator, { avatar: r.avatar })
      ]
    }
  ) });
}, KA = Object.assign(wz, { Container: qA }), qz = ({ shadowRoot: e, chatAPI: t, ready: n }) => {
  const { assistant: r, interact: a, open: i } = jn(pr), s = hv(r), o = WA(r, e);
  return dv(
    t,
    () => (console.info("Methods open, close, hide, show, proactive.clear, proactive.push have no effect in this mode."), { interact: a }),
    n
  ), Sr(() => {
    i();
  }, []), o ? /* @__PURE__ */ J.jsx(KA, { className: s }) : null;
}, Dz = 380, Pz = 800, fh = Ot(yt.WIDGET), fs = Ce(fh("div", "chat"), {
  width: Dz,
  overflow: "hidden",
  borderRadius: "$2",
  boxShadow: "0 2px 48px rgba(19,33,68,0.16), 0 0 0 1px $shadow4",
  height: "90%",
  maxHeight: Pz,
  "@mobile": {
    position: "fixed",
    height: "unset",
    maxHeight: "unset",
    width: "unset",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    borderRadius: 0,
    boxShadow: "none"
  }
}), ds = Ce(fh("div", "launcher"), {}), D1 = {
  opacity: 1,
  pointerEvents: "auto",
  transform: "translateY(0%)",
  transition: "transform 300ms cubic-bezier(0, 0.95, 0.1, 1), opacity 150ms linear"
}, P1 = {
  opacity: 0,
  pointerEvents: "none",
  transform: "translateY(100%)",
  transition: "transform 300ms cubic-bezier(0.85, 0, 0.6, 1), opacity 150ms linear"
}, XA = Ce(fh("div"), {
  position: "fixed",
  inset: 0,
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  pointerEvents: "none",
  zIndex: 1e4,
  [`
    & > ${ds},
    & > ${fs}
  `]: {
    position: "absolute"
  },
  variants: {
    withChat: {
      true: {
        [`& > ${fs}`]: {
          ...D1
        },
        [`& > ${ds}`]: {
          ...P1
        }
      },
      false: {
        [`& > ${fs}`]: {
          ...P1
        },
        [`& > ${ds}`]: {
          ...D1
        }
      }
    },
    isHidden: {
      true: {
        display: "none"
      }
    }
  }
}), Lz = ({ shadowRoot: e, chatAPI: t, ready: n }) => {
  const { assistant: r, open: a, close: i, interact: s } = jn(pr), { isOpen: o } = jn(Ru), [u, l] = _n(!1), [f, h] = _n([]), p = ua(() => window.matchMedia("(max-width: 768px)").matches, []), b = hv(r);
  dv(
    t,
    () => ({
      open: a,
      close: i,
      hide: () => l(!0),
      show: () => l(!1),
      interact: s,
      proactive: {
        clear: () => h([]),
        push: (...N) => h((A) => [...A, ...N])
      }
    }),
    n
  );
  const v = r.position, E = { bottom: r.spacing.bottom, [v]: r.spacing.side };
  return WA(r, e) ? /* @__PURE__ */ J.jsxs(XA, { withChat: o, isHidden: u, className: b, children: [
    /* @__PURE__ */ J.jsxs(ds, { style: E, children: [
      /* @__PURE__ */ J.jsx(YA, { side: v, messages: f }),
      /* @__PURE__ */ J.jsx(HA, { onClick: a, image: r.launcher })
    ] }),
    /* @__PURE__ */ J.jsx(fs, { style: p ? {} : E, children: /* @__PURE__ */ J.jsx(KA, {}) })
  ] }) : null;
}, Kz = Object.assign(Lz, {
  Launcher: HA,
  Container: XA,
  ChatContainer: fs,
  LauncherContainer: ds
});
export {
  FP as AnyExtension,
  q1 as AssistantInfo,
  Yz as AssistantOptions,
  Hz as AutoScrollConsumer,
  od as AutoScrollContext,
  $C as AutoScrollProvider,
  aa as Avatar,
  oc as Bubble,
  Zn as Button,
  wd as Card,
  nM as Carousel,
  UA as Chat,
  Wz as ChatConfig,
  qz as ChatEmbed,
  vM as ChatInput,
  Kz as ChatWidget,
  KA as ChatWindow,
  w1 as DEFAULT_AVATAR,
  RM as EMBEDDED_TARGET,
  $P as EffectExtension,
  md as ExtensionType,
  rv as Footer,
  sv as Header,
  Rn as Icon,
  rb as Image,
  yM as Input,
  Nz as LaunchOptions,
  HA as Launcher,
  ov as Loader,
  R1 as Markdown,
  Ur as Message,
  cC as PALETTE,
  ic as PRIMARY,
  Gz as Proactive,
  So as Prompt,
  Oz as RUNTIME_URL,
  wu as RenderMode,
  kM as RenderOptions,
  BP as ResponseExtension,
  zz as RuntimeProvider,
  pr as RuntimeStateAPIContext,
  Ru as RuntimeStateContext,
  F1 as SHADOWS,
  ir as SystemResponse,
  uz as Text,
  yo as Textarea,
  La as Timestamp,
  DA as Tooltip,
  hi as TurnType,
  zM as TypingIndicator,
  Rz as UserOptions,
  Jr as UserResponse,
  xz as VerifyOptions,
  Om as WARN,
  nd as animationStyles,
  Ld as chain,
  gC as createCustomTheme,
  U1 as createPrimaryColors,
  pC as createTheme,
  j1 as createTransition,
  z1 as fadeIn,
  hC as getDefaultTheme,
  OS as isObject,
  hu as keyframes,
  Vz as noop,
  bC as pulse,
  EC as rotate,
  vC as shift,
  mC as stitches,
  Ce as styled,
  V1 as textOverflowStyles,
  Uz as theme,
  fv as useAutoScroll,
  dv as useChatAPI,
  MM as useDidUpdateEffect,
  jw as useStateRef,
  hv as useTheme
};
